diff --git a/include/ipmitool/Makefile.am b/include/ipmitool/Makefile.am
index 5a9062c..2bca573 100644
--- a/include/ipmitool/Makefile.am
+++ b/include/ipmitool/Makefile.am
@@ -35,8 +35,8 @@ noinst_HEADERS = log.h bswap.h hpm2.h helper.h ipmi.h ipmi_cc.h ipmi_intf.h \
 	ipmi_sdr.h ipmi_sel.h ipmi_sol.h ipmi_mc.h ipmi_raw.h \
 	ipmi_channel.h ipmi_sensor.h ipmi_event.h ipmi_session.h \
 	ipmi_strings.h ipmi_constants.h ipmi_user.h ipmi_pef.h \
-	ipmi_oem.h ipmi_sdradd.h ipmi_isol.h ipmi_sunoem.h ipmi_picmg.h \
-	ipmi_fwum.h ipmi_main.h ipmi_tsol.h ipmi_firewall.h \
-	ipmi_kontronoem.h ipmi_ekanalyzer.h ipmi_gendev.h ipmi_ime.h \
-	ipmi_delloem.h ipmi_dcmi.h ipmi_vita.h
+	ipmi_oem.h ipmi_sdradd.h ipmi_isol.h ipmi_picmg.h \
+	ipmi_main.h ipmi_tsol.h ipmi_firewall.h \
+	ipmi_gendev.h ipmi_ime.h \
+	ipmi_dcmi.h
 
diff --git a/include/ipmitool/ipmi_delloem.h b/include/ipmitool/ipmi_delloem.h
deleted file mode 100644
index 7543e4f..0000000
--- a/include/ipmitool/ipmi_delloem.h
+++ /dev/null
@@ -1,370 +0,0 @@
-/****************************************************************************
-Copyright (c) 2008, Dell Inc
-All rights reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution. 
-- Neither the name of Dell Inc nor the names of its contributors
-may be used to endorse or promote products derived from this software 
-without specific prior written permission. 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE. 
-
-
-*****************************************************************************/
-#ifndef IPMI_DELLOEM_H
-#define IPMI_DELLOEM_H
-
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#pragma pack(1)
-
-#define MIN(a,b) ((a) < (b) ? (a) : (b))
-#define MAX(a,b) ((a) > (b) ? (a) : (b))
-
-
-/* Dell selector for LCD control - get and set unless specified */
-#define IPMI_DELL_LCD_STRING_SELECTOR       0xC1        /* RW get/set the user string */
-#define IPMI_DELL_LCD_CONFIG_SELECTOR       0xC2        /* RW set to user/default/none */
-#define IPMI_DELL_LCD_GET_CAPS_SELECTOR     0xCF        /* RO use when available*/
-#define IPMI_DELL_LCD_STRINGEX_SELECTOR     0xD0        /* RW get/set the user string use first when available*/
-#define IPMI_DELL_LCD_STATUS_SELECTOR       0xE7        /* LCD string when config set to default.*/
-#define IPMI_DELL_PLATFORM_MODEL_NAME_SELECTOR 0xD1    /* LCD string when config set to default.*/
-
-/* Dell defines for picking which string to use */
-#define IPMI_DELL_LCD_CONFIG_USER_DEFINED   0x00 /* use string set by user*/
-#define IPMI_DELL_LCD_CONFIG_DEFAULT        0x01 /* use platform model name*/
-#define IPMI_DELL_LCD_CONFIG_NONE           0x02 /* blank*/
-#define IPMI_DELL_LCD_iDRAC_IPV4ADRESS      0x04 /* use string set by user*/
-#define IPMI_DELL_LCD_IDRAC_MAC_ADDRESS     0x08 /* use platform model name*/
-#define IPMI_DELL_LCD_OS_SYSTEM_NAME        0x10 /* blank*/
-
-#define IPMI_DELL_LCD_SERVICE_TAG           0x20  /* use string set by user*/
-#define IPMI_DELL_LCD_iDRAC_IPV6ADRESS      0x40  /* use string set by user*/
-#define IPMI_DELL_LCD_AMBEINT_TEMP          0x80  /* use platform model name*/
-#define IPMI_DELL_LCD_SYSTEM_WATTS          0x100 /* blank*/
-#define IPMI_DELL_LCD_ASSET_TAG             0x200
-
-#define IPMI_DELL_LCD_ERROR_DISP_SEL        0x01  /* use platform model name*/
-#define IPMI_DELL_LCD_ERROR_DISP_VERBOSE    0x02  /* blank*/
-
-#define IPMI_DELL_IDRAC_VALIDATOR           0xDD    
-#define IPMI_DELL_POWER_CAP_STATUS          0xBA   
-#define IPMI_DELL_AVG_POWER_CONSMP_HST 	0xEB
-#define IPMI_DELL_PEAK_POWER_CONSMP_HST 0xEC
-#define SYSTEM_BOARD_SYSTEM_LEVEL_SENSOR_NUM 0x98
-
-#define	IDRAC_11G					1
-#define	IDRAC_12G					2
-#define	IDRAC_13G					3
-// Return Error code for license
-#define	LICENSE_NOT_SUPPORTED		0x6F
-#define	VFL_NOT_LICENSED			0x33
-#define btuphr              0x01
-#define watt                0x00
-#define IPMI_DELL_POWER_CAP 0xEA
-#define percent             0x03 
-
-/* Not on all Dell servers. If there, use it.*/
-typedef struct _tag_ipmi_dell_lcd_caps
-{
-       uint8_t parm_rev;                                       /* 0x11 for IPMI 2.0 */
-        uint8_t char_set;                                       /* always 1 for printable ASCII 0x20-0x7E */
-   uint8_t number_lines;                           /* 0-4, 1 for 9G. 10G tbd */
-   uint8_t max_chars[4];                           /* 62 for triathlon, 0 if not present (glacier) */
-                                                                             /* [0] is max chars for line 1 */
-}IPMI_DELL_LCD_CAPS;
-
-#define IPMI_DELL_LCD_STRING_LENGTH_MAX 62      /* Valid for 9G. Glacier ??. */
-#define IPMI_DELL_LCD_STRING1_SIZE      14
-#define IPMI_DELL_LCD_STRINGN_SIZE      16
-
-/* vFlash subcommands */
-#define IPMI_GET_EXT_SD_CARD_INFO 0xA4
-
-
-typedef struct _tag_ipmi_dell_lcd_string
-{
-     uint8_t parm_rev;                       /* 0x11 for IPMI 2.0 */
-     uint8_t data_block_selector;            /* 16-byte data block number to access, 0 based.*/
-     union 
-     {
-          struct 
-          {
-                uint8_t encoding : 4;                     /* 0 is printable ASCII 7-bit */
-                uint8_t length;                           /* 0 to max chars from lcd caps */
-                uint8_t data[IPMI_DELL_LCD_STRING1_SIZE]; /* not zero terminated.  */
-          }selector_0_string;
-          uint8_t selector_n_data[IPMI_DELL_LCD_STRINGN_SIZE];
-     }lcd_string;
-} __attribute__ ((packed)) IPMI_DELL_LCD_STRING;
-
-/* Only found on servers with more than 1 line. Use if available. */
-typedef struct _tag_ipmi_dell_lcd_stringex
-{
-      uint8_t parm_rev;                       /* 0x11 for IPMI 2.0 */
-      uint8_t line_number;                    /* LCD line number 1 to 4 */
-      uint8_t data_block_selector;            /* 16-byte data block number to access, 0 based.*/
-      union 
-      {
-           struct  
-           {
-                uint8_t encoding : 4;                     /* 0 is printable ASCII 7-bit */
-                uint8_t length;                           /* 0 to max chars from lcd caps */
-                uint8_t data[IPMI_DELL_LCD_STRING1_SIZE]; /* not zero terminated.  */
-           } selector_0_string;
-           uint8_t selector_n_data[IPMI_DELL_LCD_STRINGN_SIZE];
-   } lcd_string;
-} __attribute__ ((packed)) IPMI_DELL_LCD_STRINGEX;
-
-
-typedef struct _lcd_status
-{
-      char parametersel;
-      char vKVM_status;
-      char lock_status;
-      char Resv1;
-      char Resv;
-} __attribute__ ((packed)) LCD_STATUS;
-
-typedef struct _lcd_mode
-{
-    uint8_t parametersel;
-    uint32_t lcdmode;
-    uint16_t lcdquallifier;
-    uint32_t capabilites;
-    uint8_t error_display;
-    uint8_t Resv;
-} __attribute__ ((packed)) LCD_MODE;
-
-#define PARAM_REV_OFFSET                    (uint8_t)(0x1)
-#define VIRTUAL_MAC_OFFSET                  (uint8_t)(0x1)
-
-#define LOM_MACTYPE_ETHERNET 0
-#define LOM_MACTYPE_ISCSI 1
-#define LOM_MACTYPE_RESERVED 3
-
-#define LOM_ETHERNET_ENABLED 0
-#define LOM_ETHERNET_DISABLED 1
-#define LOM_ETHERNET_PLAYINGDEAD 2
-#define LOM_ETHERNET_RESERVED 3
-
-#define LOM_ACTIVE 1
-#define LOM_INACTIVE 0
-
-#define MACADDRESSLENGH 6
-#define MAX_LOM 8
-
-
-#define EMB_NIC_MAC_ADDRESS_11G     (uint8_t)(0xDA)
-#define EMB_NIC_MAC_ADDRESS_9G_10G  (uint8_t)(0xCB)
-
-#define IMC_IDRAC_10G               (uint8_t) (0x08) 
-#define IMC_CMC                     (uint8_t) (0x09)
-#define IMC_IDRAC_11G_MONOLITHIC    (uint8_t) (0x0A)
-#define IMC_IDRAC_11G_MODULAR       (uint8_t) (0x0B)
-#define IMC_UNUSED                  (uint8_t) (0x0C)
-#define IMC_MASER_LITE_BMC          (uint8_t) (0x0D)
-#define IMC_MASER_LITE_NU 			(uint8_t) (0x0E)
-#define IMC_IDRAC_12G_MONOLITHIC 	(uint8_t) (0x10)
-#define IMC_IDRAC_12G_MODULAR 		(uint8_t) (0x11)
-
-#define IMC_IDRAC_13G_MONOLITHIC 	(uint8_t) (0x20)
-#define IMC_IDRAC_13G_MODULAR 		(uint8_t) (0x21)
-#define IMC_IDRAC_13G_DCS			(uint8_t) (0x22)
-
-
-typedef struct
-{
-     unsigned int BladSlotNumber : 4;
-     unsigned int MacType : 2;
-     unsigned int EthernetStatus : 2;
-     unsigned int NICNumber : 5;
-     unsigned int Reserved : 3;
-     uint8_t MacAddressByte[MACADDRESSLENGH];
-} LOMMacAddressType;
-
-
-typedef struct
-{
-     LOMMacAddressType LOMMacAddress [MAX_LOM];
-} EmbeddedNICMacAddressType;
-
-typedef struct
-{
-     uint8_t MacAddressByte[MACADDRESSLENGH];
-} MacAddressType;
-
-typedef struct
-{
-   MacAddressType MacAddress [MAX_LOM];
-} EmbeddedNICMacAddressType_10G;
-
-
-
-#define TRANSPORT_NETFN             (uint8_t)(0xc)
-#define GET_LAN_PARAM_CMD           (uint8_t)(0x02)
-#define MAC_ADDR_PARAM              (uint8_t)(0x05)
-#define LAN_CHANNEL_NUMBER          (uint8_t)(0x01)
-
-#define IDRAC_NIC_NUMBER            (uint8_t)(0x8)
-
-#define TOTAL_N0_NICS_INDEX         (uint8_t)(0x1)
-
-
-// 12g supported 
-#define SET_NIC_SELECTION_12G_CMD       (uint8_t)(0x28)
-#define GET_NIC_SELECTION_12G_CMD       (uint8_t)(0x29)
-
-// 11g supported 
-#define SET_NIC_SELECTION_CMD       (uint8_t)(0x24)
-#define GET_NIC_SELECTION_CMD       (uint8_t)(0x25)
-#define GET_ACTIVE_NIC_CMD          (uint8_t)(0xc1)
-#define POWER_EFFICENCY_CMD     		(uint8_t)(0xc0)
-#define SERVER_POWER_CONSUMPTION_CMD   	(uint8_t)(0x8F)
-
-#define POWER_SUPPLY_INFO           (uint8_t)(0xb0)
-#define IPMI_ENTITY_ID_POWER_SUPPLY (uint8_t)(0x0a)
-#define SENSOR_STATE_STR_SIZE       (uint8_t)(64)
-#define SENSOR_NAME_STR_SIZE        (uint8_t)(64)
-
-#define GET_PWRMGMT_INFO_CMD	    (uint8_t)(0x9C)
-#define CLEAR_PWRMGMT_INFO_CMD	    (uint8_t)(0x9D)
-#define GET_PWR_HEADROOM_CMD	    (uint8_t)(0xBB)
-#define GET_PWR_CONSUMPTION_CMD	    (uint8_t)(0xB3)
-#define	GET_FRONT_PANEL_INFO_CMD		(uint8_t)0xb5
-
-
-typedef struct _ipmi_power_monitor
-{
-    uint32_t        cumStartTime;
-    uint32_t        cumReading;
-    uint32_t        maxPeakStartTime;
-    uint32_t        ampPeakTime;
-    uint16_t        ampReading;
-    uint32_t        wattPeakTime;
-    uint16_t        wattReading;
-} __attribute__ ((packed)) IPMI_POWER_MONITOR;
-
-
-#define MAX_POWER_FW_VERSION 8
-
-typedef struct _ipmi_power_supply_infoo
-{
-	/*No param_rev it is not a System Information Command */
-	uint16_t ratedWatts;
-	uint16_t ratedAmps;
-	uint16_t ratedVolts;
-	uint32_t vendorid;
-    uint8_t FrimwareVersion[MAX_POWER_FW_VERSION];
-	uint8_t  Powersupplytype;
-	uint16_t ratedDCWatts;
-	uint16_t Resv;	
-                          
-} __attribute__ ((packed)) IPMI_POWER_SUPPLY_INFO;
-
-
-typedef struct ipmi_power_consumption_data
-{
-    uint16_t actualpowerconsumption;
-    uint16_t powerthreshold;
-    uint16_t warningthreshold;
-    uint8_t throttlestate;
-    uint16_t maxpowerconsumption;
-    uint16_t throttlepowerconsumption;
-    uint16_t Resv;
-} __attribute__ ((packed)) IPMI_POWER_CONSUMPTION_DATA;
-
-
-typedef struct ipmi_inst_power_consumption_data
-{
-    uint16_t instanpowerconsumption;
-    uint16_t instanApms;
-    uint16_t resv1;
-    uint8_t resv;
-} __attribute__ ((packed)) IPMI_INST_POWER_CONSUMPTION_DATA;
-
-typedef struct _ipmi_avgpower_consump_histroy
-{
-    uint8_t parameterselector;  
-    uint16_t lastminutepower;
-    uint16_t lasthourpower;
-    uint16_t lastdaypower;
-    uint16_t lastweakpower;  
-                          
-} __attribute__ ((packed)) IPMI_AVGPOWER_CONSUMP_HISTORY;
-
-typedef struct _ipmi_power_consump_histroy
-{
-    uint8_t parameterselector;   
-    uint16_t lastminutepower;
-    uint16_t lasthourpower;
-    uint16_t lastdaypower;
-    uint16_t lastweakpower; 
-    uint32_t lastminutepowertime;
-    uint32_t lasthourpowertime;
-    uint32_t lastdaypowertime;
-    uint32_t lastweekpowertime;
-} __attribute__ ((packed)) IPMI_POWER_CONSUMP_HISTORY;
-
-
-typedef struct _ipmi_delloem_power_cap
-{     
-    uint8_t parameterselector;      
-    uint16_t PowerCap;
-    uint8_t unit;
-    uint16_t MaximumPowerConsmp;
-    uint16_t MinimumPowerConsmp;
-    uint16_t totalnumpowersupp;
-    uint16_t AvailablePower ;
-    uint16_t SystemThrottling;
-    uint16_t Resv;
-} __attribute__ ((packed)) IPMI_POWER_CAP;       
-
-typedef struct _power_headroom
-{ 
-    uint16_t instheadroom;
-    uint16_t peakheadroom;
-} __attribute__ ((packed)) POWER_HEADROOM;
-
-struct vFlashstr {
-	uint8_t val;
-	const char * str;
-};
-typedef struct ipmi_vFlash_extended_info
-{
-	uint8_t  vflashcompcode;
-	uint8_t  sdcardstatus;
-	uint32_t sdcardsize;
-	uint32_t sdcardavailsize;
-	uint8_t  bootpartion;
-	uint8_t  Resv;
-} __attribute__ ((packed)) IPMI_DELL_SDCARD_INFO;
-
-
-typedef struct _SensorReadingType
-{
-    uint8_t sensorReading;
-    uint8_t sensorFlags;
-    uint16_t sensorState;
-}SensorReadingType;
-uint16_t compareinputwattage(IPMI_POWER_SUPPLY_INFO* powersupplyinfo, uint16_t inputwattage);
-int ipmi_delloem_main(struct ipmi_intf * intf, int argc, char ** argv);
-
-#endif /*IPMI_DELLOEM_H*/
diff --git a/include/ipmitool/ipmi_ekanalyzer.h b/include/ipmitool/ipmi_ekanalyzer.h
deleted file mode 100644
index 7c43220..0000000
--- a/include/ipmitool/ipmi_ekanalyzer.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2007 Kontron Canada, Inc.  All Rights Reserved.
- *
- * Base on code from
- * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-#ifndef IPMI_EKANALYZER_H
-#define IPMI_EKANALYZER_H
-
-#include <inttypes.h>
-#include <ipmitool/ipmi.h>
-#include <ipmitool/ipmi_fru.h>
-
-#define RTM_FRU_FILE             0x00
-#define A1_AMC_FRU_FILE          0x01
-#define A2_AMC_FRU_FILE          0x02
-#define A3_AMC_FRU_FILE          0x03
-#define A4_AMC_FRU_FILE          0x04
-#define B1_AMC_FRU_FILE          0x05
-#define B2_AMC_FRU_FILE          0x06
-#define B3_AMC_FRU_FILE          0x07
-#define B4_AMC_FRU_FILE          0x08
-#define ON_CARRIER_FRU_FILE      0x09
-#define CONFIG_FILE              0x0A
-#define SHELF_MANAGER_FRU_FILE   0x0B
-
-#define MIN_ARGUMENT             0x02
-#define RTM_IPMB_L               0x90
-
-#define MAX_FILE_NUMBER          8
-/* this voltag is specified in AMC.0 specification Table 3-10 */
-#define AMC_VOLTAGE                  12 /*volts*/
-
-#define SIZE_OF_GUID             16
-#define FRU_RADIAL_IPMB0_LINK_MAPPING 0x15
-
-int ipmi_ekanalyzer_main(struct ipmi_intf *, int, char **);
-
-#endif /* IPMI_EKANALYZER_H */
diff --git a/include/ipmitool/ipmi_fwum.h b/include/ipmitool/ipmi_fwum.h
deleted file mode 100644
index c19a582..0000000
--- a/include/ipmitool/ipmi_fwum.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- * 
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-#ifndef IPMI_KFWUM_H
-# define IPMI_KFWUM_H
-
-#include <inttypes.h>
-#include <ipmitool/ipmi.h>
-
-/* KFWUM Version */
-# define VER_MAJOR        1
-# define VER_MINOR        3
-/* Minimum size (IPMB/IOL/old protocol) */
-# define KFWUM_SMALL_BUFFER     32
-/* Maximum size on KCS interface */
-# define KFWUM_BIG_BUFFER       32
-# define MAX_BUFFER_SIZE          1024*16
-
-/* 3 address + 1 size + 1 checksum + 1 command */
-# define KFWUM_OLD_CMD_OVERHEAD 6
-/* 1 sequence + 1 size + 1 checksum + 1 command */
-# define KFWUM_NEW_CMD_OVERHEAD 4
-# define KFWUM_PAGE_SIZE        256
-
-# define FWUM_SAVE_FIRMWARE_NO_RESPONSE_LIMIT 6
-# define FWUM_MAX_UPLOAD_RETRY 6
-
-# define TRACE_LOG_CHUNK_COUNT 7
-# define TRACE_LOG_CHUNK_SIZE  7
-# define TRACE_LOG_ATT_COUNT   3
-
-# define IN_FIRMWARE_INFO_OFFSET_LOCATION           0x5a0
-# define IN_FIRMWARE_INFO_SIZE                      20
-# define IN_FIRMWARE_INFO_OFFSET_FILE_SIZE          0
-# define IN_FIRMWARE_INFO_OFFSET_CHECKSUM           4
-# define IN_FIRMWARE_INFO_OFFSET_BOARD_ID           6
-# define IN_FIRMWARE_INFO_OFFSET_DEVICE_ID          8
-# define IN_FIRMWARE_INFO_OFFSET_TABLE_VERSION      9
-# define IN_FIRMWARE_INFO_OFFSET_IMPLEMENT_REV      10
-# define IN_FIRMWARE_INFO_OFFSET_VER_MAJOROR      11
-# define IN_FIRMWARE_INFO_OFFSET_VER_MINORSUB     12
-# define IN_FIRMWARE_INFO_OFFSET_SDR_REV            13
-# define IN_FIRMWARE_INFO_OFFSET_IANA0              14
-# define IN_FIRMWARE_INFO_OFFSET_IANA1              15
-# define IN_FIRMWARE_INFO_OFFSET_IANA2              16
-
-# define KWUM_GET_BYTE_AT_OFFSET(pBuffer,os)            pBuffer[os]
-
-int ipmi_fwum_main(struct ipmi_intf *, int, char **);
-
-typedef enum eKFWUM_BoardList
-{
-	KFWUM_BOARD_KONTRON_UNKNOWN = 0,
-	KFWUM_BOARD_KONTRON_5002 = 5002,
-} tKFWUM_BoardList;
-
-typedef struct sKFWUM_BoardInfo
-{
-	tKFWUM_BoardList boardId;
-	IPMI_OEM  iana;
-} tKFWUM_BoardInfo;
-
-typedef enum eKFWUM_DownloadType
-{
-	KFWUM_DOWNLOAD_TYPE_ADDRESS = 0,
-	KFWUM_DOWNLOAD_TYPE_SEQUENCE,
-} tKFWUM_DownloadType;
-
-typedef enum eKFWUM_DownloadBuffferType
-{
-	KFWUM_SMALL_BUFFER_TYPE = 0,
-	KFUMW_BIG_BUFFER_TYPE
-} tKFWUM_DownloadBuffferType;
-
-typedef struct sKFWUM_InFirmwareInfo
-{
-	unsigned long   fileSize;
-	unsigned short  checksum;
-	unsigned short  sumToRemoveFromChecksum;
-	/* Since the checksum is added in the bin
-	 * after the checksum is calculated, we
-	 * need to remove the each byte value.  This
-	 * byte will contain the addition of both bytes
-	 */
-	tKFWUM_BoardList boardId;
-	unsigned char   deviceId;
-	unsigned char   tableVers;
-	unsigned char   implRev;
-	unsigned char   versMajor;
-	unsigned char   versMinor;
-	unsigned char   versSubMinor;
-	unsigned char   sdrRev;
-	IPMI_OEM iana;
-} tKFWUM_InFirmwareInfo;
-
-typedef struct sKFWUM_SaveFirmwareInfo
-{
-	tKFWUM_DownloadType downloadType;
-	unsigned char       bufferSize;
-	unsigned char       overheadSize;
-} tKFWUM_SaveFirmwareInfo;
-
-/* COMMANDS */
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumGetInfoResp {
-	unsigned char protocolRevision;
-	unsigned char controllerDeviceId;
-	struct {
-		unsigned char mode:1;
-		unsigned char seqAdd:1;
-		unsigned char res : 6;
-	} byte;
-	unsigned char firmRev1;
-	unsigned char firmRev2;
-	unsigned char numBank;
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumGetStatusResp {
-	unsigned char bankState;
-	unsigned char firmLengthLSB;
-	unsigned char firmLengthMid;
-	unsigned char firmLengthMSB;
-	unsigned char firmRev1;
-	unsigned char firmRev2;
-	unsigned char firmRev3;
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumManualRollbackReq {
-	unsigned char type;
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumStartFirmwareDownloadReq {
-	unsigned char lengthLSB;
-	unsigned char lengthMid;
-	unsigned char lengthMSB;
-	unsigned char paddingLSB;
-	unsigned char paddingMSB;
-	unsigned char useSequence;
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumStartFirmwareDownloadResp {
-	unsigned char bank;
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumSaveFirmwareAddressReq
-{
-	unsigned char addressLSB;
-	unsigned char addressMid;
-	unsigned char addressMSB;
-	unsigned char numBytes;
-	unsigned char txBuf[KFWUM_SMALL_BUFFER-KFWUM_OLD_CMD_OVERHEAD];
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumSaveFirmwareSequenceReq
-{
-	unsigned char sequenceNumber;
-	unsigned char txBuf[KFWUM_BIG_BUFFER];
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(1)
-# endif
-struct KfwumFinishFirmwareDownloadReq {
-	unsigned char versionMaj;
-	unsigned char versionMinSub;
-	unsigned char versionSdr;
-	unsigned char reserved;
-} ATTRIBUTE_PACKING;
-# ifdef HAVE_PRAGMA_PACK
-#  pragma pack(0)
-# endif
-
-#endif /* IPMI_KFWUM_H */
diff --git a/include/ipmitool/ipmi_sunoem.h b/include/ipmitool/ipmi_sunoem.h
deleted file mode 100644
index 78afbf2..0000000
--- a/include/ipmitool/ipmi_sunoem.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- * 
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- * 
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- * 
- * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-#ifndef IPMI_SUNOEM_H
-#define IPMI_SUNOEM_H
-
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
-#include <ipmitool/ipmi.h>
-#include <ipmitool/ipmi_sdr.h>
-
-#define IPMI_NETFN_SUNOEM				0x2e
-
-#define IPMI_SUNOEM_SET_SSH_KEY				0x01
-#define IPMI_SUNOEM_DEL_SSH_KEY				0x02
-#define IPMI_SUNOEM_GET_HEALTH_STATUS			0x10
-#define IPMI_SUNOEM_CLI					0x19
-#define IPMI_SUNOEM_SET_FAN_SPEED			0x20
-#define IPMI_SUNOEM_LED_GET				0x21
-#define IPMI_SUNOEM_LED_SET				0x22
-#define IPMI_SUNOEM_ECHO				0x23
-#define IPMI_SUNOEM_VERSION				0x24
-#define IPMI_SUNOEM_NACNAME				0x29
-#define IPMI_SUNOEM_GETVAL				0x2A
-#define IPMI_SUNOEM_SETVAL				0x2C
-#define IPMI_SUNOEM_SENSOR_SET				0x3A
-#define IPMI_SUNOEM_SET_FAN_MODE			0x41
-#define IPMI_SUNOEM_CORE_TUNNEL                         0x44
-
-/*
- * Error codes of sunoem functions
- */
-typedef enum {
-	SUNOEM_EC_SUCCESS            = 0,
-	SUNOEM_EC_INVALID_ARG        = 1,
-	SUNOEM_EC_BMC_NOT_RESPONDING = 2,
-	SUNOEM_EC_BMC_CCODE_NONZERO  = 3
-} sunoem_ec_t;
-
-int ipmi_sunoem_main(struct ipmi_intf *, int, char **);
-
-#endif /*IPMI_SUNOEM_H*/
-
diff --git a/include/ipmitool/ipmi_vita.h b/include/ipmitool/ipmi_vita.h
deleted file mode 100644
index 71d471a..0000000
--- a/include/ipmitool/ipmi_vita.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) Pigeon Point Systems. All right reserved
- */
-
-#ifndef _IPMI_VITA_H_
-#define _IPMI_VITA_H_
-
-/* VITA 46.11 commands */
-#define VITA_GET_VSO_CAPABILITIES_CMD		0x00
-#define VITA_FRU_CONTROL_CMD			0x04
-#define VITA_GET_FRU_LED_PROPERTIES_CMD		0x05
-#define VITA_GET_LED_COLOR_CAPABILITIES_CMD	0x06
-#define VITA_SET_FRU_LED_STATE_CMD		0x07
-#define VITA_GET_FRU_LED_STATE_CMD		0x08
-#define VITA_SET_FRU_STATE_POLICY_BITS_CMD	0x0A
-#define VITA_GET_FRU_STATE_POLICY_BITS_CMD	0x0B
-#define VITA_SET_FRU_ACTIVATION_CMD		0x0C
-#define VITA_GET_FRU_ADDRESS_INFO_CMD		0x40
-
-/* VITA 46.11 site types */
-#define VITA_FRONT_VPX_MODULE		0x00
-#define VITA_POWER_ENTRY		0x01
-#define VITA_CHASSIS_FRU		0x02
-#define VITA_DEDICATED_CHMC		0x03
-#define VITA_FAN_TRAY			0x04
-#define VITA_FAN_TRAY_FILTER		0x05
-#define VITA_ALARM_PANEL		0x06
-#define VITA_XMC			0x07
-#define VITA_VPX_RTM			0x09
-#define VITA_FRONT_VME_MODULE		0x0A
-#define VITA_FRONT_VXS_MODULE		0x0B
-#define VITA_POWER_SUPPLY		0x0C
-#define VITA_FRONT_VITA62_MODULE	0x0D
-#define VITA_71_MODULE			0x0E
-#define VITA_FMC			0x0F
-
-
-#define GROUP_EXT_VITA		0x03
-
-extern uint8_t
-vita_discover(struct ipmi_intf *intf);
-
-extern uint8_t
-ipmi_vita_ipmb_address(struct ipmi_intf *intf);
-
-extern int
-ipmi_vita_main(struct ipmi_intf * intf, int argc, char ** argv);
-
-#endif /* _IPMI_VITA_H_ */
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 2a316db..76d8bd6 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -36,10 +36,10 @@ libipmitool_la_SOURCES	= helper.c ipmi_sdr.c ipmi_sel.c ipmi_sol.c ipmi_pef.c \
 				  ipmi_lanp.c ipmi_fru.c ipmi_chassis.c ipmi_mc.c log.c            \
 				  dimm_spd.c ipmi_sensor.c ipmi_channel.c ipmi_event.c             \
 				  ipmi_session.c ipmi_strings.c ipmi_user.c ipmi_raw.c             \
-				  ipmi_oem.c ipmi_isol.c ipmi_sunoem.c ipmi_fwum.c ipmi_picmg.c    \
-				  ipmi_main.c ipmi_tsol.c ipmi_firewall.c ipmi_kontronoem.c        \
-				  ipmi_hpmfwupg.c ipmi_sdradd.c ipmi_ekanalyzer.c ipmi_gendev.c    \
-				  ipmi_ime.c ipmi_delloem.c ipmi_dcmi.c hpm2.c ipmi_vita.c \
+				  ipmi_oem.c ipmi_isol.c ipmi_picmg.c    						   \
+				  ipmi_main.c ipmi_tsol.c ipmi_firewall.c         				   \
+				  ipmi_hpmfwupg.c ipmi_sdradd.c ipmi_gendev.c    				   \
+				  ipmi_ime.c ipmi_dcmi.c hpm2.c 								   \
 				  ../src/plugins/lan/md5.c ../src/plugins/lan/md5.h
 
 libipmitool_la_LDFLAGS		= -export-dynamic
diff --git a/lib/ipmi_delloem.c b/lib/ipmi_delloem.c
deleted file mode 100644
index 2214c99..0000000
--- a/lib/ipmi_delloem.c
+++ /dev/null
@@ -1,4271 +0,0 @@
-/*
- * Copyright (c) 2008, Dell Inc
- * All rights reserved.
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- * - Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * - Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- * - Neither the name of Dell Inc nor the names of its contributors
- * may be used to endorse or promote products derived from this software 
- * without specific prior written permission.
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-/*
- * Thursday Oct 7 17:30:12 2009
- * <deepaganesh_paulraj@dell.com>
- *
- * This code implements a dell OEM proprietary commands.
- * This Code is edited and Implemented the License feature for Delloem
- * Author Harsha S <Harsha_S1@dell.com>
- */
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <errno.h>
-#include <unistd.h>
-#include <signal.h>
-#include <ctype.h>
-#include <limits.h>
-#include <time.h>
-
-#include <ipmitool/ipmi.h>
-#include <ipmitool/ipmi_intf.h>
-#include <ipmitool/helper.h>
-#include <ipmitool/log.h>
-#include <ipmitool/ipmi_sel.h>
-#include <ipmitool/ipmi_delloem.h>
-#include <ipmitool/ipmi_fru.h>
-#include <ipmitool/ipmi_sdr.h>
-#include <ipmitool/ipmi_mc.h>
-#include <ipmitool/ipmi_sensor.h>
-#include <ipmitool/ipmi_sel.h>
-#include <ipmitool/bswap.h>
-#include <ipmitool/ipmi_sdr.h>
-#include <ipmitool/ipmi_entity.h>
-#include <ipmitool/ipmi_fru.h>
-#include <ipmitool/ipmi_sensor.h>
-
-#define DELL_OEM_NETFN	(uint8_t)(0x30)
-#define GET_IDRAC_VIRTUAL_MAC	(uint8_t)(0xC9)
-/* 11g Support Macros */
-#define INVALID	(-1)
-#define SHARED	0
-#define SHARED_WITH_FAILOVER_LOM2	1
-#define DEDICATED	2
-#define SHARED_WITH_FAILOVER_ALL_LOMS	3
-/* 11g Support Macros */
-#define SHARED 				0
-#define SHARED_WITH_FAILOVER_LOM2 	1
-#define DEDICATED 			2
-#define SHARED_WITH_FAILOVER_ALL_LOMS 	3
-/* 12g Support Strings for nic selection */
-#define	INVAILD_FAILOVER_MODE		-2
-#define	INVAILD_FAILOVER_MODE_SETTINGS	-3
-#define	INVAILD_SHARED_MODE		-4
-
-#define	INVAILD_FAILOVER_MODE_STRING "ERROR: Cannot set shared with failover lom same as current shared lom."
-#define	INVAILD_FAILOVER_MODE_SET "ERROR: Cannot set shared with failover loms when NIC is set to dedicated Mode."
-#define	INVAILD_SHARED_MODE_SET_STRING "ERROR: Cannot set shared Mode for Blades."
-
-char AciveLOM_String [6] [10] = {
-	"None",
-	"LOM1",
-	"LOM2",
-	"LOM3",
-	"LOM4",
-	"dedicated"
-};
-/* 11g Support Strings for nic selection */
-char NIC_Selection_Mode_String [4] [50] = {
-	"shared",
-	"shared with failover lom2",
-	"dedicated",
-	"shared with Failover all loms"
-};
-
-char NIC_Selection_Mode_String_12g[] [50] = {
-	"dedicated",
-	"shared with lom1",
-	"shared with lom2",
-	"shared with lom3",
-	"shared with lom4",
-	"shared with failover lom1",
-	"shared with failover lom2",
-	"shared with failover lom3",
-	"shared with failover lom4",
-	"shared with failover all loms"
-};
-
-const struct vFlashstr vFlash_completion_code_vals[] = {
-	{0x00, "SUCCESS"},
-	{0x01, "NO_SD_CARD"},
-	{0x63, "UNKNOWN_ERROR"},
-	{0x00, NULL}
-};
-
-static int current_arg =0;
-uint8_t iDRAC_FLAG=0;
-
-/*
- * new flags for
- * 11G || 12G || 13G  -> _ALL
- * 12G || 13G -> _12_13
- *
- */
-uint8_t iDRAC_FLAG_ALL=0;
-uint8_t iDRAC_FLAG_12_13=0;
-
-LCD_MODE lcd_mode;
-static uint8_t LcdSupported=0;
-static uint8_t SetLEDSupported=0;
-
-volatile uint8_t IMC_Type = IMC_IDRAC_10G;
-
-POWER_HEADROOM powerheadroom;
-
-uint8_t PowercapSetable_flag=0;
-uint8_t PowercapstatusFlag=0;
-
-static void usage(void);
-/* LCD Function prototypes */
-static int ipmi_delloem_lcd_main(struct ipmi_intf *intf, int argc,
-		char **argv);
-int ipmi_lcd_get_platform_model_name(struct ipmi_intf *intf, char *lcdstring,
-		uint8_t max_length, uint8_t field_type);
-static int ipmi_idracvalidator_command(struct ipmi_intf *intf);
-static int ipmi_lcd_get_configure_command_wh(struct ipmi_intf *intf);
-static int ipmi_lcd_get_configure_command(struct ipmi_intf *intf,
-		uint8_t *command);
-static int ipmi_lcd_set_configure_command(struct ipmi_intf *intf, int command);
-static int ipmi_lcd_set_configure_command_wh(struct ipmi_intf *intf, uint32_t  mode,
-		uint16_t lcdquallifier,uint8_t errordisp);
-static int ipmi_lcd_get_single_line_text(struct ipmi_intf *intf,
-		char *lcdstring, uint8_t max_length);
-static int ipmi_lcd_get_info_wh(struct ipmi_intf *intf);
-static int ipmi_lcd_get_info(struct ipmi_intf *intf);
-static int ipmi_lcd_get_status_val(struct ipmi_intf *intf,
-		LCD_STATUS *lcdstatus);
-static int IsLCDSupported();
-static void CheckLCDSupport(struct ipmi_intf *intf);
-static void ipmi_lcd_status_print(LCD_STATUS lcdstatus);
-static int ipmi_lcd_get_status(struct ipmi_intf *intf);
-static int ipmi_lcd_set_kvm(struct ipmi_intf *intf, char status);
-static int ipmi_lcd_set_lock(struct ipmi_intf *intf,  char lock);
-static int ipmi_lcd_set_single_line_text(struct ipmi_intf *intf, char *text);
-static int ipmi_lcd_set_text(struct ipmi_intf *intf, char *text,
-		int line_number);
-static int ipmi_lcd_configure_wh(struct ipmi_intf *intf, uint32_t mode,
-		uint16_t lcdquallifier, uint8_t errordisp, int8_t line_number, char *text);
-static int ipmi_lcd_configure(struct ipmi_intf *intf, int command,
-		int8_t line_number, char *text);
-static void ipmi_lcd_usage(void);
-/* MAC Function prototypes */
-static int ipmi_delloem_mac_main(struct ipmi_intf *intf, int argc, char **argv);
-static void InitEmbeddedNICMacAddressValues();
-static int ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf *intf,
-		uint8_t NicNum);
-static int ipmi_macinfo_drac_idrac_mac(struct ipmi_intf *intf,uint8_t NicNum);
-static int ipmi_macinfo_10g(struct ipmi_intf *intf, uint8_t NicNum);
-static int ipmi_macinfo_11g(struct ipmi_intf *intf, uint8_t NicNum);
-static int ipmi_macinfo(struct ipmi_intf *intf, uint8_t NicNum);
-static void ipmi_mac_usage(void);
-/* LAN Function prototypes */
-static int ipmi_delloem_lan_main(struct ipmi_intf *intf, int argc, char **argv);
-static int IsLANSupported();
-static int get_nic_selection_mode(int current_arg, char **argv);
-static int ipmi_lan_set_nic_selection(struct ipmi_intf *intf,
-		uint8_t nic_selection);
-static int ipmi_lan_get_nic_selection(struct ipmi_intf *intf);
-static int ipmi_lan_get_active_nic(struct ipmi_intf *intf);
-static void ipmi_lan_usage(void);
-static int ipmi_lan_set_nic_selection_12g(struct ipmi_intf *intf,
-		uint8_t *nic_selection);
-/* Power monitor Function prototypes */
-static int ipmi_delloem_powermonitor_main(struct ipmi_intf *intf, int argc,
-		char **argv);
-static void ipmi_time_to_str(time_t rawTime, char *strTime);
-static int ipmi_get_sensor_reading(struct ipmi_intf *intf,
-		unsigned char sensorNumber, SensorReadingType *pSensorReadingData);
-static int ipmi_get_power_capstatus_command(struct ipmi_intf *intf);
-static int ipmi_set_power_capstatus_command(struct ipmi_intf *intf,
-		uint8_t val);
-static int ipmi_powermgmt(struct ipmi_intf *intf);
-static int ipmi_powermgmt_clear(struct ipmi_intf *intf, uint8_t clearValue);
-static uint64_t watt_to_btuphr_conversion(uint32_t powerinwatt);
-static uint32_t btuphr_to_watt_conversion(uint64_t powerinbtuphr);
-static int ipmi_get_power_headroom_command(struct ipmi_intf *intf, uint8_t unit);
-static int ipmi_get_power_consumption_data(struct ipmi_intf *intf, uint8_t unit);
-static int ipmi_get_instan_power_consmpt_data(struct ipmi_intf *intf,
-		IPMI_INST_POWER_CONSUMPTION_DATA *instpowerconsumptiondata);
-static void ipmi_print_get_instan_power_Amps_data(
-		IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata);
-static int ipmi_print_get_power_consmpt_data(struct ipmi_intf *intf,
-		uint8_t  unit);
-static int ipmi_get_avgpower_consmpt_history(struct ipmi_intf *intf,
-		IPMI_AVGPOWER_CONSUMP_HISTORY *pavgpower);
-static int ipmi_get_peakpower_consmpt_history(struct ipmi_intf *intf,
-		IPMI_POWER_CONSUMP_HISTORY *pstPeakpower);
-static int ipmi_get_minpower_consmpt_history(struct ipmi_intf *intf,
-		IPMI_POWER_CONSUMP_HISTORY *pstMinpower);
-static int ipmi_print_power_consmpt_history(struct ipmi_intf *intf, int unit);
-static int ipmi_get_power_cap(struct ipmi_intf *intf,
-		IPMI_POWER_CAP *ipmipowercap);
-static int ipmi_print_power_cap(struct ipmi_intf *intf, uint8_t unit);
-static int ipmi_set_power_cap(struct ipmi_intf *intf, int unit, int val);
-static void ipmi_powermonitor_usage(void);
-/* vFlash Function prototypes */
-static int ipmi_delloem_vFlash_main(struct ipmi_intf *intf, int argc,
-		char **argv);
-const char *get_vFlash_compcode_str(uint8_t vflashcompcode,
-		const struct vFlashstr *vs);
-static int ipmi_get_sd_card_info(struct ipmi_intf *intf);
-static int ipmi_delloem_vFlash_process(struct ipmi_intf *intf, int current_arg,
-		char **argv);
-static void ipmi_vFlash_usage(void);
-/* LED Function prototypes */
-static int ipmi_getsesmask(int, char **argv);
-static void CheckSetLEDSupport(struct ipmi_intf *intf);
-static int IsSetLEDSupported(void);
-static void ipmi_setled_usage(void);
-static int ipmi_delloem_setled_main(struct ipmi_intf *intf, int argc,
-		char **argv);
-static int ipmi_setled_state(struct ipmi_intf *intf, int bayId, int slotId,
-		int state);
-static int ipmi_getdrivemap(struct ipmi_intf *intf, int b, int d, int f,
-		int *bayId, int *slotId);
-
-/* Function Name:       ipmi_delloem_main
- *
- * Description:         This function processes the delloem command
- * Input:               intf    - ipmi interface
- *                       argc    - no of arguments
- *                       argv    - argument string array
- * Output:
- *
- * Return:              return code     0 - success
- *                                      -1 - failure
- */
-int
-ipmi_delloem_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int rc = 0;
-	current_arg = 0;
-	if (argc == 0 || strncmp(argv[0], "help\0", 5) == 0) {
-		usage();
-		return 0;
-	}
-	if (0 ==strncmp(argv[current_arg], "lcd\0", 4)) {
-		rc = ipmi_delloem_lcd_main(intf,argc,argv);
-	} else if (strncmp(argv[current_arg], "mac\0", 4) == 0) {
-		/* mac address*/
-		rc = ipmi_delloem_mac_main(intf,argc,argv);
-	} else if (strncmp(argv[current_arg], "lan\0", 4) == 0) {
-		/* lan address*/
-		rc = ipmi_delloem_lan_main(intf,argc,argv);
-	} else if (strncmp(argv[current_arg], "setled\0", 7) == 0) {
-		/* SetLED support */
-		rc = ipmi_delloem_setled_main(intf,argc,argv);
-	} else if (strncmp(argv[current_arg], "powermonitor\0", 13) == 0) {
-		/*Powermanagement report processing*/
-		rc = ipmi_delloem_powermonitor_main(intf,argc,argv);
-	} else if (strncmp(argv[current_arg], "vFlash\0", 7) == 0) {
-		/* vFlash Support */
-		rc = ipmi_delloem_vFlash_main(intf,argc,argv);
-	} else {
-		usage();
-		return -1;
-	}
-	return rc;
-}
-/*
- * Function Name:     usage
- *
- * Description:       This function prints help message for delloem command
- * Input:
- * Output:
- *
- * Return:
- *
- */
-static void
-usage(void)
-{
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"usage: delloem <command> [option...]");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"commands:");
-	lprintf(LOG_NOTICE,
-"    lcd");
-	lprintf(LOG_NOTICE,
-"    mac");
-	lprintf(LOG_NOTICE,
-"    lan");
-	lprintf(LOG_NOTICE,
-"    setled");
-	lprintf(LOG_NOTICE,
-"    powermonitor");
-	lprintf(LOG_NOTICE,
-"    vFlash");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"For help on individual commands type:");
-	lprintf(LOG_NOTICE,
-"delloem <command> help");
-}
-/*
- * Function Name:       ipmi_delloem_lcd_main
- *
- * Description:         This function processes the delloem lcd command
- * Input:               intf    - ipmi interface
- *                       argc    - no of arguments
- *                       argv    - argument string array
- * Output:
- *
- * Return:              return code     0 - success
- *                         -1 - failure
- *
- */
-static int
-ipmi_delloem_lcd_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int rc = 0;
-	current_arg++;
-	if (argc < current_arg) {
-		usage();
-		return -1;
-	}
-	/* ipmitool delloem lcd info*/
-	if (argc == 1 || strcmp(argv[current_arg], "help") == 0) {
-		ipmi_lcd_usage();
-		return 0;
-	}
-	CheckLCDSupport(intf);
-	ipmi_idracvalidator_command(intf);
-	if (!IsLCDSupported()) {
-		lprintf(LOG_ERR, "lcd is not supported on this system.");
-		return -1;
-	} else if (strncmp(argv[current_arg], "info\0", 5) == 0) {
-		if (iDRAC_FLAG_ALL) {
-			rc = ipmi_lcd_get_info_wh(intf);
-		} else {
-			rc = ipmi_lcd_get_info(intf);
-		}
-	} else if (strncmp(argv[current_arg], "status\0", 7) == 0) {
-		rc = ipmi_lcd_get_status(intf);
-	} else if (strncmp(argv[current_arg], "set\0", 4) == 0) {
-		/* ipmitool delloem lcd set*/
-		uint8_t line_number = 0;
-		current_arg++;
-		if (argc <= current_arg) {
-			ipmi_lcd_usage();
-			return -1;
-		}
-		if (strncmp(argv[current_arg], "line\0", 5) == 0) {
-			current_arg++;
-			if (argc <= current_arg) {
-				usage();
-				return -1;
-			}
-			if (str2uchar(argv[current_arg], &line_number) != 0) {
-				lprintf(LOG_ERR,
-						"Argument '%s' is either not a number or out of range.",
-						argv[current_arg]);
-				return (-1);
-			}
-			current_arg++;
-			if (argc <= current_arg) {
-				usage();
-				return -1;
-			}
-		}
-		if ((strncmp(argv[current_arg], "mode\0", 5) == 0)
-				&& (iDRAC_FLAG_ALL)) {
-			current_arg++;
-			if (argc <= current_arg) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (argv[current_arg] == NULL) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (strncmp(argv[current_arg], "none\0", 5) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_CONFIG_NONE, 0xFF,
-						0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "modelname\0", 10) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_CONFIG_DEFAULT, 0xFF,
-						0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "userdefined\0", 12) == 0) {
-				current_arg++;
-				if (argc <= current_arg) {
-					ipmi_lcd_usage();
-					return -1;
-				}
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_CONFIG_USER_DEFINED,
-						0xFF, 0XFF, line_number, argv[current_arg]);
-			} else if (strncmp(argv[current_arg], "ipv4address\0", 12) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_iDRAC_IPV4ADRESS,
-						0xFF, 0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "macaddress\0", 11) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_IDRAC_MAC_ADDRESS,
-							0xFF, 0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "systemname\0", 11) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_OS_SYSTEM_NAME, 0xFF,
-						0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "servicetag\0", 11) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_SERVICE_TAG, 0xFF,
-						0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "ipv6address\0", 12) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_iDRAC_IPV6ADRESS,
-						0xFF, 0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "ambienttemp\0", 12) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_AMBEINT_TEMP, 0xFF,
-						0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "systemwatt\0", 11) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_SYSTEM_WATTS, 0xFF,
-						0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "assettag\0", 9) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, IPMI_DELL_LCD_ASSET_TAG, 0xFF,
-						0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "help\0", 5) == 0) {
-				ipmi_lcd_usage();
-			} else {
-				lprintf(LOG_ERR, "Invalid DellOEM command: %s",
-						argv[current_arg]);
-				ipmi_lcd_usage();
-			}
-		} else if ((strncmp(argv[current_arg], "lcdqualifier\0", 13) == 0)
-				&& (iDRAC_FLAG_ALL)) {
-			current_arg++;
-			if (argc <= current_arg) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (argv[current_arg] == NULL) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (strncmp(argv[current_arg], "watt\0", 5) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, 0xFF, 0x00, 0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "btuphr\0",7) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, 0xFF, 0x01, 0XFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "celsius\0", 8) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, 0xFF, 0x02, 0xFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "fahrenheit", 11) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, 0xFF, 0x03, 0xFF, 0, NULL);
-			} else if (strncmp(argv[current_arg], "help\0", 5) == 0) {
-				ipmi_lcd_usage();
-			} else {
-				lprintf(LOG_ERR, "Invalid DellOEM command: %s",
-						argv[current_arg]);
-				ipmi_lcd_usage();
-			}
-		} else if ((strncmp(argv[current_arg], "errordisplay\0", 13) == 0)
-				&& (iDRAC_FLAG_ALL)) {
-			current_arg++;
-			if (argc <= current_arg) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (argv[current_arg] == NULL) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (strncmp(argv[current_arg], "sel\0", 4) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, 0xFF, 0xFF,
-						IPMI_DELL_LCD_ERROR_DISP_SEL, 0, NULL);
-			} else if (strncmp(argv[current_arg], "simple\0", 7) == 0) {
-				rc = ipmi_lcd_configure_wh(intf, 0xFF, 0xFF,
-						IPMI_DELL_LCD_ERROR_DISP_VERBOSE, 0, NULL);
-			} else if (strncmp(argv[current_arg], "help\0", 5) == 0) {
-				ipmi_lcd_usage();
-			} else {
-				lprintf(LOG_ERR, "Invalid DellOEM command: %s",
-						argv[current_arg]);
-				ipmi_lcd_usage();
-			}
-		} else if ((strncmp(argv[current_arg], "none\0", 5) == 0)
-				&& (iDRAC_FLAG==0)) {
-			rc = ipmi_lcd_configure(intf, IPMI_DELL_LCD_CONFIG_NONE, 0, NULL);
-		} else if ((strncmp(argv[current_arg], "default\0", 8) == 0)
-				&& (iDRAC_FLAG==0)) {
-			rc = ipmi_lcd_configure(intf, IPMI_DELL_LCD_CONFIG_DEFAULT, 0, NULL);
-		} else if ((strncmp(argv[current_arg], "custom\0", 7) == 0)
-				&& (iDRAC_FLAG==0)) {
-			current_arg++;
-			if (argc <= current_arg) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			rc = ipmi_lcd_configure(intf, IPMI_DELL_LCD_CONFIG_USER_DEFINED,
-					line_number, argv[current_arg]);
-		} else if (strncmp(argv[current_arg], "vkvm\0", 5) == 0) {
-			current_arg++;
-			if (argc <= current_arg) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (strncmp(argv[current_arg], "active\0", 7) == 0) {
-				rc = ipmi_lcd_set_kvm(intf, 1);
-			} else if (strncmp(argv[current_arg], "inactive\0", 9) == 0) {
-				rc = ipmi_lcd_set_kvm(intf, 0);
-			} else if (strncmp(argv[current_arg], "help\0", 5) == 0) {
-				ipmi_lcd_usage();
-			} else {
-				lprintf(LOG_ERR, "Invalid DellOEM command: %s",
-						argv[current_arg]);
-				ipmi_lcd_usage();
-			}
-		} else if (strncmp(argv[current_arg], "frontpanelaccess\0", 17) == 0) {
-			current_arg++;
-			if (argc <= current_arg) {
-				ipmi_lcd_usage();
-				return -1;
-			}
-			if (strncmp(argv[current_arg], "viewandmodify\0", 14) == 0) {
-				rc = ipmi_lcd_set_lock(intf, 0);
-			} else if (strncmp(argv[current_arg], "viewonly\0", 9)==0) {
-				rc =  ipmi_lcd_set_lock(intf, 1);
-			} else if (strncmp(argv[current_arg], "disabled\0", 9)==0) {
-				rc =  ipmi_lcd_set_lock(intf, 2);
-			} else if (strncmp(argv[current_arg], "help\0", 5) == 0) {
-				ipmi_lcd_usage();
-			} else {
-				lprintf(LOG_ERR, "Invalid DellOEM command: %s",
-						argv[current_arg]);
-				ipmi_lcd_usage();
-			}
-		} else if( (strncmp(argv[current_arg], "help\0", 5) == 0)
-				&& (iDRAC_FLAG==0)) {
-			ipmi_lcd_usage();
-		} else {
-			lprintf(LOG_ERR, "Invalid DellOEM command: %s",
-					argv[current_arg]);
-			ipmi_lcd_usage();
-			return -1;
-		}
-	} else {
-		lprintf(LOG_ERR, "Invalid DellOEM command: %s",
-				argv[current_arg]);
-		ipmi_lcd_usage();
-		return -1;
-	}
-	return rc;
-}
-/* ipmi_lcd_get_platform_model_name - This function retrieves the platform model
- * name, or any other parameter which stores data in the same format
- *
- * @intf:        pointer to interface
- * @lcdstring:   hostname/platform model string(output)
- * @max_length:  length of the platform model string
- * @field_type:  either hostname/platform model
- *
- * returns: 0 => success, other value means error
- */
-int
-ipmi_lcd_get_platform_model_name(struct ipmi_intf * intf, char* lcdstring,
-		uint8_t max_length, uint8_t field_type)
-{
-	int bytes_copied = 0;
-	int ii = 0;
-	int lcdstring_len = 0;
-	int rc = 0;
-	IPMI_DELL_LCD_STRING lcdstringblock;
-
-	for (ii = 0; ii < 4; ii++) {
-		int bytes_to_copy;
-		rc = ipmi_mc_getsysinfo(intf, field_type, ii, 0, sizeof(lcdstringblock),
-				&lcdstringblock);
-		if (rc < 0) {
-			lprintf(LOG_ERR, "Error getting platform model name");
-			break;
-		} else if (rc > 0) {
-			lprintf(LOG_ERR, "Error getting platform model name: %s",
-					val2str(rc, completion_code_vals));
-			break;
-		}
-		/* first block is different - 14 bytes*/
-		if (ii == 0) {
-			lcdstring_len = lcdstringblock.lcd_string.selector_0_string.length;
-			lcdstring_len = MIN(lcdstring_len,max_length);
-			bytes_to_copy = MIN(lcdstring_len, IPMI_DELL_LCD_STRING1_SIZE);
-			memcpy(lcdstring, lcdstringblock.lcd_string.selector_0_string.data,
-					bytes_to_copy);
-		} else {
-			int string_offset;
-			bytes_to_copy = MIN(lcdstring_len - bytes_copied,
-					IPMI_DELL_LCD_STRINGN_SIZE);
-			if (bytes_to_copy < 1) {
-				break;
-			}
-			string_offset = IPMI_DELL_LCD_STRING1_SIZE + IPMI_DELL_LCD_STRINGN_SIZE
-				* (ii-1);
-			memcpy(lcdstring + string_offset,
-					lcdstringblock.lcd_string.selector_n_data, bytes_to_copy);
-		}
-		bytes_copied += bytes_to_copy;
-		if (bytes_copied >= lcdstring_len) {
-			break;
-		}
-	}
-	return rc;
-}
-/*
- * Function Name:    ipmi_idracvalidator_command
- *
- * Description:      This function returns the iDRAC6 type
- * Input:            intf            - ipmi interface
- * Output:
- *
- * Return:           iDRAC6 type     1 - whoville
- *                                   0 - others
- */
-static int
-ipmi_idracvalidator_command(struct ipmi_intf * intf)
-{
-	int rc;
-	uint8_t data[11];
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_IDRAC_VALIDATOR, 2, 0, sizeof(data),
-			data);
-	if (rc < 0) {
-		/*lprintf(LOG_ERR, " Error getting IMC type"); */
-		return -1;
-	} else if (rc > 0) {
-		/*lprintf(LOG_ERR, " Error getting IMC type: %s",
-		val2str(rsp->ccode, completion_code_vals));  */
-		return -1;
-	}
-	/*
-	 * Set the new flags to 0
-	 */
-	iDRAC_FLAG_ALL = 0;
-	iDRAC_FLAG_12_13 = 0;
-	/* Support the 11G Monolithic, modular, Maisy and Coaster */
-	if ((IMC_IDRAC_11G_MONOLITHIC == data[10])
-			|| (IMC_IDRAC_11G_MODULAR == data[10])
-			|| (IMC_MASER_LITE_BMC == data[10])
-			|| (IMC_MASER_LITE_NU == data[10])) {
-		iDRAC_FLAG=IDRAC_11G;
-		iDRAC_FLAG_ALL = 1;
-	} else if((IMC_IDRAC_12G_MONOLITHIC == data[10])
-			|| (IMC_IDRAC_12G_MODULAR == data[10])) {
-		iDRAC_FLAG = IDRAC_12G;
-		iDRAC_FLAG_ALL = 1;
-		iDRAC_FLAG_12_13 = 1;
-	} else if ((IMC_IDRAC_13G_MONOLITHIC == data[10])
-			|| (IMC_IDRAC_13G_MODULAR == data[10])
-			|| (IMC_IDRAC_13G_DCS == data[10])) {
-		iDRAC_FLAG=IDRAC_13G;
-		iDRAC_FLAG_ALL = 1;
-		iDRAC_FLAG_12_13 = 1;
-	} else {
-		iDRAC_FLAG = 0;
-		iDRAC_FLAG_ALL = 0;
-		iDRAC_FLAG_12_13 = 0;
-	}
-	IMC_Type = data[10];
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_get_configure_command_wh
- *
- * Description:      This function returns current lcd configuration for Dell OEM LCD command
- * Input:            intf            - ipmi interface
- * Global:           lcd_mode - lcd mode setting
- * Output:
- *
- * Return:           returns the current lcd configuration
- *                   0 = User defined
- *                   1 = Default
- *                   2 = None
- */
-static int
-ipmi_lcd_get_configure_command_wh(struct ipmi_intf * intf)
-{
-	int rc;
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_CONFIG_SELECTOR, 0, 0,
-			sizeof(lcd_mode), &lcd_mode);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting LCD configuration");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)){
-		lprintf(LOG_ERR, "Error getting LCD configuration: "
-				"Command not supported on this system.");
-	} else if (rc > 0) {
-		lprintf(LOG_ERR, "Error getting LCD configuration: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_get_configure_command
- *
- * Description:   This function returns current lcd configuration for Dell OEM
- * LCD command
- * Input:         intf            - ipmi interface
- * Output:        command         - user defined / default / none / ipv4 / mac address /
- *                 system name / service tag / ipv6 / temp / system watt / asset tag
- *
- * Return:
- */
-static int
-ipmi_lcd_get_configure_command(struct ipmi_intf * intf, uint8_t *command)
-{
-	uint8_t data[4];
-	int rc;
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_CONFIG_SELECTOR, 0, 0,
-			sizeof(data), data);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting LCD configuration");
-		return -1;
-	} else if ((rc == 0xc1)||(rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting LCD configuration: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rc > 0) {
-		lprintf(LOG_ERR, "Error getting LCD configuration: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	/* rsp->data[0] is the rev */
-	*command = data[1];
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_set_configure_command
- *
- * Description:      This function updates current lcd configuration
- * Input:            intf            - ipmi interface
- *                   command         - user defined / default / none / ipv4 / mac address /
- *                        system name / service tag / ipv6 / temp / system watt / asset tag
- * Output:
- * Return:
- */
-static int
-ipmi_lcd_set_configure_command(struct ipmi_intf * intf, int command)
-{
-	#define LSCC_DATA_LEN 2
-	uint8_t data[2];
-	int rc;
-	data[0] = IPMI_DELL_LCD_CONFIG_SELECTOR;
-	data[1] = command;                      /* command - custom, default, none */
-	rc = ipmi_mc_setsysinfo(intf, 2, data);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error setting LCD configuration");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error setting LCD configuration: "
-				"Command not supported on this system.");
-	} else if (rc > 0) {
-		lprintf(LOG_ERR, "Error setting LCD configuration: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_set_configure_command
- *
- * Description:      This function updates current lcd configuration
- * Input:            intf            - ipmi interface
- *                   mode            - user defined / default / none
- *                   lcdquallifier   - lcd quallifier id
- *                   errordisp       - error number
- * Output:
- * Return:
- */
-static int
-ipmi_lcd_set_configure_command_wh(struct ipmi_intf * intf, uint32_t  mode,
-		uint16_t lcdquallifier, uint8_t errordisp)
-{
-	#define LSCC_DATA_LEN 2
-	uint8_t data[13];
-	int rc;
-	ipmi_lcd_get_configure_command_wh(intf);
-	data[0] = IPMI_DELL_LCD_CONFIG_SELECTOR;
-	if (mode != 0xFF) {
-		data[1] = mode & 0xFF; /* command - custom, default, none*/
-		data[2] = (mode & 0xFF00) >> 8;
-		data[3] = (mode & 0xFF0000) >> 16;
-		data[4] = (mode & 0xFF000000) >> 24;
-	} else {
-		data[1] = (lcd_mode.lcdmode) & 0xFF; /* command - custom, default, none*/
-		data[2] = ((lcd_mode.lcdmode) & 0xFF00) >> 8;
-		data[3] = ((lcd_mode.lcdmode) & 0xFF0000) >> 16;
-		data[4] = ((lcd_mode.lcdmode) & 0xFF000000) >> 24;
-	}
-	if (lcdquallifier != 0xFF) {
-		if(lcdquallifier == 0x01) {
-			data[5] = (lcd_mode.lcdquallifier) | 0x01; /* command - custom, default, none*/
-		} else  if (lcdquallifier == 0x00) {
-			data[5] = (lcd_mode.lcdquallifier) & 0xFE; /* command - custom, default, none*/
-		} else if (lcdquallifier == 0x03) {
-			data[5] = (lcd_mode.lcdquallifier) | 0x02; /* command - custom, default, none*/
-		} else if (lcdquallifier == 0x02) {
-			data[5] = (lcd_mode.lcdquallifier) & 0xFD;
-		}
-	} else {
-		data[5] = lcd_mode.lcdquallifier;
-	}
-	if (errordisp != 0xFF) {
-		data[11] = errordisp;
-	} else {
-		data[11] = lcd_mode.error_display;
-	}
-	rc = ipmi_mc_setsysinfo(intf, 13, data);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error setting LCD configuration");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error setting LCD configuration: "
-				"Command not supported on this system.");
-	} else if (rc > 0) {
-		lprintf(LOG_ERR, "Error setting LCD configuration: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_get_single_line_text
- *
- * Description:    This function updates current lcd configuration
- * Input:          intf            - ipmi interface
- *                 lcdstring       - new string to be updated
- *                 max_length      - length of the string
- * Output:
- * Return:
- */
-static int
-ipmi_lcd_get_single_line_text(struct ipmi_intf * intf, char* lcdstring,
-		uint8_t max_length)
-{
-	IPMI_DELL_LCD_STRING lcdstringblock;
-	int lcdstring_len = 0;
-	int bytes_copied = 0;
-	int ii, rc;
-	for (ii = 0; ii < 4; ii++) {
-		int bytes_to_copy;
-		rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_STRING_SELECTOR, ii, 0,
-				sizeof(lcdstringblock), &lcdstringblock);
-		if (rc < 0) {
-			lprintf(LOG_ERR, "Error getting text data");
-			return -1;
-		} else if (rc > 0) {
-			lprintf(LOG_ERR, "Error getting text data: %s",
-					val2str(rc, completion_code_vals));
-			return -1;
-		}
-		/* first block is different - 14 bytes*/
-		if (0 == ii) {
-			lcdstring_len = lcdstringblock.lcd_string.selector_0_string.length;
-			if (lcdstring_len < 1 || lcdstring_len > max_length) {
-				break;
-			}
-			bytes_to_copy = MIN(lcdstring_len, IPMI_DELL_LCD_STRING1_SIZE);
-			memcpy(lcdstring, lcdstringblock.lcd_string.selector_0_string.data,
-					bytes_to_copy);
-		} else {
-			int string_offset;
-			bytes_to_copy = MIN(lcdstring_len - bytes_copied,
-					IPMI_DELL_LCD_STRINGN_SIZE);
-			if (bytes_to_copy < 1) {
-				break;
-			}
-			string_offset = IPMI_DELL_LCD_STRING1_SIZE + IPMI_DELL_LCD_STRINGN_SIZE
-				* (ii-1);
-			memcpy(lcdstring+string_offset,
-					lcdstringblock.lcd_string.selector_n_data, bytes_to_copy);
-		}
-		bytes_copied += bytes_to_copy;
-		if (bytes_copied >= lcdstring_len) {
-			break;
-		}
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_get_info_wh
- *
- * Description:     This function prints current lcd configuration for whoville platform
- * Input:           intf            - ipmi interface
- * Output:
- * Return:
- */
-static int
-ipmi_lcd_get_info_wh(struct ipmi_intf * intf)
-{
-	IPMI_DELL_LCD_CAPS lcd_caps;
-	char lcdstring[IPMI_DELL_LCD_STRING_LENGTH_MAX+1] = {0};
-	int rc;
-	printf("LCD info\n");
-	if (ipmi_lcd_get_configure_command_wh(intf) != 0) {
-		return -1;
-	}
-	if (lcd_mode.lcdmode== IPMI_DELL_LCD_CONFIG_DEFAULT) {
-		char text[IPMI_DELL_LCD_STRING_LENGTH_MAX+1] = {0};
-		if (ipmi_lcd_get_platform_model_name(intf, text,
-					IPMI_DELL_LCD_STRING_LENGTH_MAX,
-					IPMI_DELL_PLATFORM_MODEL_NAME_SELECTOR) != 0) {
-			return (-1);
-		}
-		printf("    Setting:Model name\n");
-		printf("    Line 1:  %s\n", text);
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_CONFIG_NONE) {
-		printf("    Setting:   none\n");
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_CONFIG_USER_DEFINED) {
-		printf("    Setting: User defined\n");
-		rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_GET_CAPS_SELECTOR, 0, 0,
-				sizeof(lcd_caps), &lcd_caps);
-		if (rc < 0) {
-			lprintf(LOG_ERR, "Error getting LCD capabilities.");
-			return -1;
-		} else if ((rc == 0xc1) || (rc == 0xcb)) {
-			lprintf(LOG_ERR, "Error getting LCD capabilities: "
-					"Command not supported on this system.");
-		} else if (rc > 0) {
-			lprintf(LOG_ERR, "Error getting LCD capabilities: %s",
-					val2str(rc, completion_code_vals));
-			return -1;
-		}
-		if (lcd_caps.number_lines > 0) {
-			memset(lcdstring, 0, IPMI_DELL_LCD_STRING_LENGTH_MAX + 1);
-			rc = ipmi_lcd_get_single_line_text(intf, lcdstring,
-					lcd_caps.max_chars[0]);
-			printf("    Text:    %s\n", lcdstring);
-		} else {
-			printf("    No lines to show\n");
-		}
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_iDRAC_IPV4ADRESS) {
-		printf("    Setting:   IPV4 Address\n");
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_IDRAC_MAC_ADDRESS) {
-		printf("    Setting:   MAC Address\n");
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_OS_SYSTEM_NAME) {
-		printf("    Setting:   OS System Name\n");
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_SERVICE_TAG) {
-		printf("    Setting:   System Tag\n");
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_iDRAC_IPV6ADRESS) {
-		printf("    Setting:  IPV6 Address\n");
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_ASSET_TAG) {
-		printf("    Setting:  Asset Tag\n");
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_AMBEINT_TEMP) {
-		printf("    Setting:  Ambient Temp\n");
-		if (lcd_mode.lcdquallifier & 0x02) {
-			printf("    Unit:  F\n");
-		} else {
-			printf("    Unit:  C\n");
-		}
-	} else if (lcd_mode.lcdmode == IPMI_DELL_LCD_SYSTEM_WATTS) {
-		printf("    Setting:  System Watts\n");
-		if (lcd_mode.lcdquallifier & 0x01) {
-			printf("    Unit:  BTU/hr\n");
-		} else {
-			printf("    Unit:  Watt\n");
-		}
-	}
-	if (lcd_mode.error_display == IPMI_DELL_LCD_ERROR_DISP_SEL) {
-		printf("    Error Display:  SEL\n");
-	} else if (lcd_mode.error_display == IPMI_DELL_LCD_ERROR_DISP_VERBOSE) {
-		printf("    Error Display:  Simple\n");
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_get_info
- *
- * Description:      This function prints current lcd configuration for platform other than whoville
- * Input:            intf            - ipmi interface
- * Output:
- * Return:
- */
-static int
-ipmi_lcd_get_info(struct ipmi_intf * intf)
-{
-	IPMI_DELL_LCD_CAPS lcd_caps;
-	uint8_t command = 0;
-	char lcdstring[IPMI_DELL_LCD_STRING_LENGTH_MAX+1] = {0};
-	int rc;
-
-	printf("LCD info\n");
-
-	if (ipmi_lcd_get_configure_command(intf, &command) != 0) {
-		return -1;
-	}
-	if (command == IPMI_DELL_LCD_CONFIG_DEFAULT) {
-		memset(lcdstring,0,IPMI_DELL_LCD_STRING_LENGTH_MAX+1);
-		if (ipmi_lcd_get_platform_model_name(intf, lcdstring,
-					IPMI_DELL_LCD_STRING_LENGTH_MAX,
-					IPMI_DELL_PLATFORM_MODEL_NAME_SELECTOR) != 0) {
-			return (-1);
-		}
-		printf("    Setting: default\n");
-		printf("    Line 1:  %s\n", lcdstring);
-	} else if (command == IPMI_DELL_LCD_CONFIG_NONE) {
-		printf("    Setting:   none\n");
-	} else if (command == IPMI_DELL_LCD_CONFIG_USER_DEFINED) {
-		printf("    Setting: custom\n");
-		rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_GET_CAPS_SELECTOR, 0, 0,
-				sizeof(lcd_caps), &lcd_caps);
-		if (rc < 0) {
-			lprintf(LOG_ERR, "Error getting LCD capabilities.");
-			return -1;
-		} else if ((rc == 0xc1) || (rc == 0xcb)) {
-			lprintf(LOG_ERR, "Error getting LCD capabilities: "
-					"Command not supported on this system.");
-		} else if (rc > 0) {
-			lprintf(LOG_ERR, "Error getting LCD capabilities: %s",
-					val2str(rc, completion_code_vals));
-			return -1;
-		}
-		if (lcd_caps.number_lines > 0) {
-			memset(lcdstring, 0, IPMI_DELL_LCD_STRING_LENGTH_MAX + 1);
-			rc = ipmi_lcd_get_single_line_text(intf, lcdstring,
-					lcd_caps.max_chars[0]);
-			printf("    Text:    %s\n", lcdstring);
-		} else {
-			printf("    No lines to show\n");
-		}
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_lcd_get_status_val
- *
- * Description:      This function gets current lcd configuration
- * Input:            intf            - ipmi interface
- * Output:           lcdstatus       - KVM Status & Lock Status
- * Return:
- */
-static int
-ipmi_lcd_get_status_val(struct ipmi_intf * intf, LCD_STATUS* lcdstatus)
-{
-	int rc;
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_STATUS_SELECTOR, 0, 0,
-			sizeof(*lcdstatus), lcdstatus);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting LCD Status");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting LCD status: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rc > 0) {
-		lprintf(LOG_ERR, "Error getting LCD Status: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    IsLCDSupported
- *
- * Description:   This function returns whether lcd supported or not
- * Input:
- * Output:
- * Return:
- */
-static int
-IsLCDSupported()
-{
-	return LcdSupported;
-}
-/*
- * Function Name:         CheckLCDSupport
- *
- * Description:  This function checks whether lcd supported or not
- * Input:        intf            - ipmi interface
- * Output:
- * Return:
- */
-static void
-CheckLCDSupport(struct ipmi_intf * intf)
-{
-	int rc;
-	LcdSupported = 0;
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_STATUS_SELECTOR, 0, 0, 0, NULL);
-	if (rc == 0) {
-		LcdSupported = 1;
-	}
-}
-/*
- * Function Name:     ipmi_lcd_status_print
- *
- * Description:    This function prints current lcd configuration KVM Status & Lock Status
- * Input:          lcdstatus - KVM Status & Lock Status
- * Output:
- * Return:
- */
-static void
-ipmi_lcd_status_print(LCD_STATUS lcdstatus)
-{
-	switch (lcdstatus.vKVM_status) {
-		case 0x00:
-			printf("LCD KVM Status :Inactive\n");
-			break;
-		case 0x01:
-			printf("LCD KVM Status :Active\n");
-			break;
-		default:
-			printf("LCD KVM Status :Invalid Status\n");
-			break;
-	}
-	switch (lcdstatus.lock_status) {
-		case 0x00:
-			printf("LCD lock Status :View and modify\n");
-			break;
-		case 0x01:
-			printf("LCD lock Status :View only\n");
-			break;
-		case 0x02:
-			printf("LCD lock Status :disabled\n");
-			break;
-		default:
-			printf("LCD lock Status :Invalid\n");
-			break;
-	}
-}
-/*
- * Function Name:     ipmi_lcd_get_status
- *
- * Description:      This function gets current lcd KVM active status & lcd access mode
- * Input:            intf            - ipmi interface
- * Output:
- * Return:           -1 on error
- *                   0 if successful
- */
-static int
-ipmi_lcd_get_status(struct ipmi_intf * intf)
-{
-	int rc=0;
-	LCD_STATUS  lcdstatus;
-	rc =ipmi_lcd_get_status_val( intf, &lcdstatus);
-	if (rc < 0) {
-		return -1;
-	}
-	ipmi_lcd_status_print(lcdstatus);
-	return rc;
-}
-/*
- * Function Name:     ipmi_lcd_set_kvm
- *
- * Description:       This function sets lcd KVM active status
- * Input:             intf            - ipmi interface
- *                    status  - Inactive / Active
- * Output:
- * Return:            -1 on error
- *                    0 if successful
- */
-static int
-ipmi_lcd_set_kvm(struct ipmi_intf * intf, char status)
-{
-	#define LSCC_DATA_LEN 2
-	LCD_STATUS lcdstatus;
-	int rc=0;
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint8_t data[5];
-	rc = ipmi_lcd_get_status_val(intf,&lcdstatus);
-	if (rc < 0) {
-		return -1;
-	}
-	req.msg.netfn = IPMI_NETFN_APP;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_SET_SYS_INFO;
-	req.msg.data_len = 5;
-	req.msg.data = data;
-	data[0] = IPMI_DELL_LCD_STATUS_SELECTOR;
-	data[1] = status; /* active- incative*/
-	data[2] = lcdstatus.lock_status; /* full-veiw-locked */
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error setting LCD status");
-		rc= -1;
-	} else if ((rsp->ccode == 0xc1) || (rsp->ccode == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting LCD status: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error setting LCD status: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		rc= -1;
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_lcd_set_lock
- *
- * Description:     This function sets lcd access mode
- * Input:           intf            - ipmi interface
- *                  lock    - View and modify / View only / Diabled
- * Output:
- * Return:          -1 on error
- *                  0 if successful
- */
-static int
-ipmi_lcd_set_lock(struct ipmi_intf * intf,  char lock)
-{
-	#define LSCC_DATA_LEN 2
-	LCD_STATUS lcdstatus;
-	int rc =0;
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint8_t data[5];
-	rc = ipmi_lcd_get_status_val(intf,&lcdstatus);
-	if (rc < 0) {
-		return -1;
-	}
-	req.msg.netfn = IPMI_NETFN_APP;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_SET_SYS_INFO;
-	req.msg.data_len = 5;
-	req.msg.data = data;
-	data[0] = IPMI_DELL_LCD_STATUS_SELECTOR;
-	data[1] = lcdstatus.vKVM_status; /* active- incative */
-	data[2] = lock; /* full- veiw-locked */
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error setting LCD status");
-		rc = -1;
-	} else if ((rsp->ccode == 0xc1) || (rsp->ccode == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting LCD status: "
-				"Command not supported on this system.");
-		rc = -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error setting LCD status: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		rc= -1;
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_lcd_set_single_line_text
- *
- * Description:    This function sets lcd line text
- * Input:          intf            - ipmi interface
- *                 text    - lcd string
- * Output:
- * Return:         -1 on error
- *                 0 if successful
- */
-static int
-ipmi_lcd_set_single_line_text(struct ipmi_intf * intf, char * text)
-{
-	uint8_t data[18];
-	int bytes_to_store = strlen(text);
-	int bytes_stored = 0;
-	int ii;
-	int rc = 0;
-	if (bytes_to_store > IPMI_DELL_LCD_STRING_LENGTH_MAX) {
-		lprintf(LOG_ERR, "Out of range Max limit is 62 characters");
-		return (-1);
-	} else {
-		bytes_to_store = MIN(bytes_to_store, IPMI_DELL_LCD_STRING_LENGTH_MAX);
-		for (ii = 0; ii < 4; ii++) {
-			/*first block, 2 bytes parms and 14 bytes data*/
-			if (0 == ii) {
-				int size_of_copy = MIN((bytes_to_store - bytes_stored),
-						IPMI_DELL_LCD_STRING1_SIZE);
-				if (size_of_copy < 0) {
-					/* allow 0 string length*/
-					break;
-				}
-				data[0] = IPMI_DELL_LCD_STRING_SELECTOR;
-				data[1] = ii; /* block number to use (0)*/
-				data[2] = 0; /*string encoding*/
-				data[3] = bytes_to_store; /* total string length*/
-				memcpy(data + 4, text+bytes_stored, size_of_copy);
-				bytes_stored += size_of_copy;
-			} else {
-				int size_of_copy = MIN((bytes_to_store - bytes_stored),
-						IPMI_DELL_LCD_STRINGN_SIZE);
-				if (size_of_copy <= 0) {
-					break;
-				}
-				data[0] = IPMI_DELL_LCD_STRING_SELECTOR;
-				data[1] = ii; /* block number to use (1,2,3)*/
-				memcpy(data + 2, text+bytes_stored, size_of_copy);
-				bytes_stored += size_of_copy;
-			}
-			rc = ipmi_mc_setsysinfo(intf, 18, data);
-			if (rc < 0) {
-				lprintf(LOG_ERR, "Error setting text data");
-				rc = -1;
-			} else if (rc > 0) {
-				lprintf(LOG_ERR, "Error setting text data: %s",
-						val2str(rc, completion_code_vals));
-				rc = -1;
-			}
-		}
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_lcd_set_text
- *
- * Description:     This function sets lcd line text
- * Input:           intf            - ipmi interface
- *                  text    - lcd string
- *                  line_number- line number
- * Output:
- * Return:          -1 on error
- *                  0 if successful
- */
-static int
-ipmi_lcd_set_text(struct ipmi_intf * intf, char * text, int line_number)
-{
-	int rc = 0;
-	IPMI_DELL_LCD_CAPS lcd_caps;
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_LCD_GET_CAPS_SELECTOR, 0, 0,
-			sizeof(lcd_caps), &lcd_caps);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting LCD capabilities");
-		return -1;
-	} else if (rc > 0) {
-		lprintf(LOG_ERR, "Error getting LCD capabilities: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	if (lcd_caps.number_lines > 0) {
-		rc = ipmi_lcd_set_single_line_text(intf, text);
-	} else {
-		lprintf(LOG_ERR, "LCD does not have any lines that can be set");
-		rc = -1;
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_lcd_configure_wh
- *
- * Description:     This function updates the current lcd configuration
- * Input:           intf            - ipmi interface
- *                  lcdquallifier- lcd quallifier
- *                  errordisp       - error number
- *                  line_number-line number
- *                  text            - lcd string
- * Output:
- * Return:          -1 on error
- *                  0 if successful
- */
-static int
-ipmi_lcd_configure_wh(struct ipmi_intf * intf, uint32_t  mode,
-		uint16_t lcdquallifier, uint8_t errordisp, int8_t line_number, char * text)
-{
-	int rc = 0;
-	if (IPMI_DELL_LCD_CONFIG_USER_DEFINED == mode) {
-		/* Any error was reported earlier. */
-		rc = ipmi_lcd_set_text(intf, text, line_number);
-	}
-	if (rc == 0) {
-		rc = ipmi_lcd_set_configure_command_wh(intf, mode ,lcdquallifier,errordisp);
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_lcd_configure
- *
- * Description:     This function updates the current lcd configuration
- * Input:           intf            - ipmi interface
- *                  command- lcd command
- *                  line_number-line number
- *                  text            - lcd string
- * Output:
- * Return:          -1 on error
- *                  0 if successful
- */
-static int
-ipmi_lcd_configure(struct ipmi_intf * intf, int command,
-		int8_t line_number, char * text)
-{
-	int rc = 0;
-	if (IPMI_DELL_LCD_CONFIG_USER_DEFINED == command) {
-		rc = ipmi_lcd_set_text(intf, text, line_number);
-	}
-	if (rc == 0) {
-		rc = ipmi_lcd_set_configure_command(intf, command);
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_lcd_usage
- *
- * Description:   This function prints help message for lcd command
- * Input:
- * Output:
- *
- * Return:
- */
-static void
-ipmi_lcd_usage(void)
-{
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"Generic DELL HW:");
-	lprintf(LOG_NOTICE,
-"   lcd set {none}|{default}|{custom <text>}");
-	lprintf(LOG_NOTICE,
-"      Set LCD text displayed during non-fault conditions");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"iDRAC 11g or iDRAC 12g or  iDRAC 13g :");
-	lprintf(LOG_NOTICE,
-"   lcd set {mode}|{lcdqualifier}|{errordisplay}");
-	lprintf(LOG_NOTICE,
-"      Allows you to set the LCD mode and user-defined string.");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lcd set mode {none}|{modelname}|{ipv4address}|{macaddress}|");
-	lprintf(LOG_NOTICE,
-"   {systemname}|{servicetag}|{ipv6address}|{ambienttemp}");
-	lprintf(LOG_NOTICE,
-"   {systemwatt }|{assettag}|{userdefined}<text>");
-	lprintf(LOG_NOTICE,
-"	   Allows you to set the LCD display mode to any of the preceding");
-	lprintf(LOG_NOTICE,
-"      parameters");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lcd set lcdqualifier {watt}|{btuphr}|{celsius}|{fahrenheit}");
-	lprintf(LOG_NOTICE,
-"      Allows you to set the unit for the system ambient temperature mode.");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lcd set errordisplay {sel}|{simple}");
-	lprintf(LOG_NOTICE,
-"      Allows you to set the error display.");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lcd info");
-	lprintf(LOG_NOTICE,
-"      Show LCD text that is displayed during non-fault conditions");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lcd set vkvm{active}|{inactive}");
-	lprintf(LOG_NOTICE,
-"      Set vKVM active and inactive, message will be displayed on lcd");
-	lprintf(LOG_NOTICE,
-"      when vKVM is active and vKVM session is in progress");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lcd set frontpanelaccess {viewandmodify}|{viewonly}|{disabled}");
-	lprintf(LOG_NOTICE,
-"      Set LCD mode to view and modify, view only or disabled ");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lcd status");
-	lprintf(LOG_NOTICE,
-"      Show LCD Status for vKVM display<active|inactive>");
-	lprintf(LOG_NOTICE,
-"      and Front Panel access mode {viewandmodify}|{viewonly}|{disabled}");
-	lprintf(LOG_NOTICE,
-"");
-}
-/*
- * Function Name:       ipmi_delloem_mac_main
- *
- * Description:         This function processes the delloem mac command
- * Input:               intf    - ipmi interface
- *                       argc    - no of arguments
- *                       argv    - argument string array
- * Output:
- *
- * Return:              return code     0 - success
- *                         -1 - failure
- */
-static int
-ipmi_delloem_mac_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int rc = 0;
-	int currIdInt = -1;
-	current_arg++;
-	if (argc > 1 && strcmp(argv[current_arg], "help") == 0) {
-		ipmi_mac_usage();
-		return 0;
-	}
-	ipmi_idracvalidator_command(intf);
-	if (argc == 1) {
-		rc = ipmi_macinfo(intf, 0xff);
-	} else if (strncmp(argv[current_arg], "list\0", 5) == 0) {
-		rc = ipmi_macinfo(intf, 0xff);
-	} else if (strncmp(argv[current_arg], "get\0", 4) == 0) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			ipmi_mac_usage();
-			return -1;
-		}
-		if (str2int(argv[current_arg],&currIdInt) != 0) {
-			lprintf(LOG_ERR,
-					"Invalid NIC number. The NIC number should be between 0-8");
-			return -1;
-		}
-		if ((currIdInt > 8) || (currIdInt < 0)) {
-			lprintf(LOG_ERR,
-					"Invalid NIC number. The NIC number should be between 0-8");
-			return -1;
-		}
-		rc = ipmi_macinfo(intf, currIdInt);
-	} else {
-		ipmi_mac_usage();
-	}
-	return rc;
-}
-
-EmbeddedNICMacAddressType EmbeddedNICMacAddress;
-
-EmbeddedNICMacAddressType_10G EmbeddedNICMacAddress_10G;
-
-static void
-InitEmbeddedNICMacAddressValues()
-{
-	uint8_t i;
-	uint8_t j;
-	for (i = 0; i < MAX_LOM; i++) {
-		EmbeddedNICMacAddress.LOMMacAddress[i].BladSlotNumber = 0;
-		EmbeddedNICMacAddress.LOMMacAddress[i].MacType = LOM_MACTYPE_RESERVED;
-		EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus =
-			LOM_ETHERNET_RESERVED;
-		EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber = 0;
-		EmbeddedNICMacAddress.LOMMacAddress[i].Reserved = 0;
-		for (j = 0; j < MACADDRESSLENGH; j++) {
-			EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j] = 0;
-			EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j] = 0;
-		}
-	}
-}
-
-uint8_t UseVirtualMacAddress = 0;
-static int
-ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf* intf,uint8_t NicNum)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t msg_data[30];
-	uint8_t VirtualMacAddress [MACADDRESSLENGH];
-	uint8_t input_length=0;
-	uint8_t j;
-	uint8_t i;
-	if (NicNum != 0xff && NicNum != IDRAC_NIC_NUMBER) {
-		return 0;
-	}
-	UseVirtualMacAddress = 0;
-	input_length = 0;
-	msg_data[input_length++] = 1; /*Get*/
-
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_IDRAC_VIRTUAL_MAC;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		return -1;
-	}
-	if (rsp->ccode > 0) {
-		return -1;
-	}
-	if ((IMC_IDRAC_12G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_12G_MONOLITHIC== IMC_Type)
-			|| (IMC_IDRAC_13G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_13G_MONOLITHIC== IMC_Type)) {
-		/* Get the Chasiss Assigned MAC Addresss for 12g Only */
-		memcpy(VirtualMacAddress, ((rsp->data) + 1), MACADDRESSLENGH);
-		for (i = 0; i < MACADDRESSLENGH; i++) {
-			if (VirtualMacAddress[i] != 0) {
-				UseVirtualMacAddress = 1;
-			}
-		}
-		/* Get the Server Assigned MAC Addresss for 12g Only */
-		if (!UseVirtualMacAddress) {
-			memcpy(VirtualMacAddress, ((rsp->data) + 1 + MACADDRESSLENGH),
-					MACADDRESSLENGH);
-			for (i = 0; i < MACADDRESSLENGH; i++) {
-				if (VirtualMacAddress[i] != 0) {
-					UseVirtualMacAddress = 1;
-				}
-			}
-		}
-	} else {
-		memcpy(VirtualMacAddress, ((rsp->data) + VIRTUAL_MAC_OFFSET),
-				MACADDRESSLENGH);
-		for (i = 0; i < MACADDRESSLENGH; i++) {
-			if (VirtualMacAddress[i] != 0) {
-				UseVirtualMacAddress = 1;
-			}
-		}
-	}
-	if (UseVirtualMacAddress == 0) {
-		return -1;
-	}
-	if (IMC_IDRAC_10G == IMC_Type) {
-		printf("\nDRAC MAC Address ");
-	} else if ((IMC_IDRAC_11G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_11G_MONOLITHIC== IMC_Type)) {
-		printf("\niDRAC6 MAC Address ");
-	} else if ((IMC_IDRAC_12G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_12G_MONOLITHIC== IMC_Type)) {
-		printf("\niDRAC7 MAC Address ");
-	} else if ((IMC_IDRAC_13G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_13G_MONOLITHIC== IMC_Type)) {
-			printf ("\niDRAC8 MAC Address ");
-	} else if ((IMC_MASER_LITE_BMC== IMC_Type)
-			|| (IMC_MASER_LITE_NU== IMC_Type)) {
-		printf("\nBMC MAC Address ");
-	} else {
-		printf("\niDRAC6 MAC Address ");
-	}
-
-	for (j = 0; j < 5; j++) {
-		printf("%02x:", VirtualMacAddress[j]);
-	}
-	printf("%02x", VirtualMacAddress[j]);
-	printf("\n");
-	return 0;
-}
-/*
- * Function Name:    ipmi_macinfo_drac_idrac_mac
- *
- * Description:      This function retrieves the mac address of DRAC or iDRAC
- * Input:            NicNum
- * Output:
- * Return:
- */
-static int
-ipmi_macinfo_drac_idrac_mac(struct ipmi_intf* intf,uint8_t NicNum)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t msg_data[30];
-	uint8_t input_length=0;
-	uint8_t iDRAC6MacAddressByte[MACADDRESSLENGH];
-	uint8_t j;
-	ipmi_macinfo_drac_idrac_virtual_mac(intf,NicNum);
-	if ((NicNum != 0xff && NicNum != IDRAC_NIC_NUMBER)
-			|| UseVirtualMacAddress != 0) {
-		return 0;
-	}
-	input_length = 0;
-	msg_data[input_length++] = LAN_CHANNEL_NUMBER;
-	msg_data[input_length++] = MAC_ADDR_PARAM;
-	msg_data[input_length++] = 0x00;
-	msg_data[input_length++] = 0x00;
-
-	req.msg.netfn = TRANSPORT_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_LAN_PARAM_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting MAC Address");
-		return -1;
-	}
-	if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting MAC Address (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	memcpy(iDRAC6MacAddressByte, ((rsp->data) + PARAM_REV_OFFSET),
-			MACADDRESSLENGH);
-
-	if (IMC_IDRAC_10G == IMC_Type) {
-		printf("\nDRAC MAC Address ");
-	} else if ((IMC_IDRAC_11G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_11G_MONOLITHIC== IMC_Type)) {
-		printf("\niDRAC6 MAC Address ");
-	} else if ((IMC_IDRAC_12G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_12G_MONOLITHIC== IMC_Type)) {
-		printf("\niDRAC7 MAC Address ");
-	} else if ((IMC_IDRAC_13G_MODULAR == IMC_Type)
-			|| (IMC_IDRAC_13G_MONOLITHIC== IMC_Type)) {
-			printf ("\niDRAC8 MAC Address ");
-	} else if ((IMC_MASER_LITE_BMC== IMC_Type)
-			|| (IMC_MASER_LITE_NU== IMC_Type)) {
-		printf("\n\rBMC MAC Address ");
-	} else {
-		printf("\niDRAC6 MAC Address ");
-	}
-
-	for (j = 0; j < 5; j++) {
-		printf("%02x:", iDRAC6MacAddressByte[j]);
-	}
-	printf("%02x", iDRAC6MacAddressByte[j]);
-	printf("\n");
-	return 0;
-}
-/*
- * Function Name:    ipmi_macinfo_10g
- *
- * Description:      This function retrieves the mac address of LOMs
- * Input:            intf      - ipmi interface
- *                   NicNum    - NIC number
- * Output:
- * Return:
- */
-static int
-ipmi_macinfo_10g(struct ipmi_intf* intf, uint8_t NicNum)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t msg_data[30];
-	uint8_t input_length=0;
-	uint8_t j;
-	uint8_t i;
-	uint8_t Total_No_NICs = 0;
-	InitEmbeddedNICMacAddressValues();
-	memset(msg_data, 0, sizeof(msg_data));
-	input_length = 0;
-	msg_data[input_length++] = 0x00; /* Get Parameter Command */
-	msg_data[input_length++] = EMB_NIC_MAC_ADDRESS_9G_10G; /* OEM Param */
-	msg_data[input_length++] = 0x00;
-	msg_data[input_length++] = 0x00;
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_APP;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_GET_SYS_INFO;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting MAC Address");
-		return -1;
-	}
-	if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting MAC Address (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	Total_No_NICs = (uint8_t)rsp->data[0 + PARAM_REV_OFFSET]; /* Byte 1: Total Number of Embedded NICs */
-	if (IDRAC_NIC_NUMBER != NicNum) {
-		if (0xff == NicNum) {
-			printf("\nSystem LOMs");
-		}
-		printf("\nNIC Number\tMAC Address\n");
-		memcpy(&EmbeddedNICMacAddress_10G,
-				((rsp->data) + PARAM_REV_OFFSET+TOTAL_N0_NICS_INDEX),
-				Total_No_NICs* MACADDRESSLENGH);
-		/*Read the LOM type and Mac Addresses */
-		for (i = 0; i < Total_No_NICs; i++) {
-			if ((0xff == NicNum) || (i == NicNum)) {
-				printf("\n%d",i);
-				printf("\t\t");
-				for (j = 0 ; j < 5; j++) {
-					printf("%02x:",
-							EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
-				}
-				printf("%02x",
-						EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
-			}
-		}
-		printf("\n");
-	}
-	ipmi_macinfo_drac_idrac_mac(intf,NicNum);
-	return 0;
-}
-/*
- * Function Name:      ipmi_macinfo_11g
- *
- * Description:        This function retrieves the mac address of LOMs
- * Input:              intf - ipmi interface
- * Output:
- * Return:
- */
-static int
-ipmi_macinfo_11g(struct ipmi_intf* intf, uint8_t NicNum)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t input_length = 0;
-	uint8_t i;
-	uint8_t j;
-	uint8_t len;
-	uint8_t loop_count;
-	uint8_t maxlen;
-	uint8_t msg_data[30];
-	uint8_t offset;
-	offset = 0;
-	len = 8; /*eigher 8 or 16 */
-	maxlen = 64;
-	loop_count = maxlen / len;
-	InitEmbeddedNICMacAddressValues();
-	memset(msg_data, 0, sizeof(msg_data));
-	input_length = 0;
-	msg_data[input_length++] = 0x00; /* Get Parameter Command */
-	msg_data[input_length++] = EMB_NIC_MAC_ADDRESS_11G; /* OEM Param */
-	msg_data[input_length++] = 0x00;
-	msg_data[input_length++] = 0x00;
-	msg_data[input_length++] = 0x00;
-	msg_data[input_length++] = 0x00;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_APP;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_GET_SYS_INFO;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting MAC Address");
-		return -1;
-	}
-	if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting MAC Address (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	len = 8; /*eigher 8 or 16 */
-	maxlen = (uint8_t)rsp->data[0 + PARAM_REV_OFFSET];
-	loop_count = maxlen / len;
-	if (IDRAC_NIC_NUMBER != NicNum) {
-		if (0xff == NicNum) {
-			printf("\nSystem LOMs");
-		}
-		printf("\nNIC Number\tMAC Address\t\tStatus\n");
-		/*Read the LOM type and Mac Addresses */
-		offset=0;
-		for (i = 0; i < loop_count; i++, offset = offset + len) {
-			input_length = 4;
-			msg_data[input_length++] = offset;
-			msg_data[input_length++] = len;
-
-			req.msg.netfn = IPMI_NETFN_APP;
-			req.msg.lun = 0;
-			req.msg.cmd = IPMI_GET_SYS_INFO;
-			req.msg.data = msg_data;
-			req.msg.data_len = input_length;
-
-			rsp = intf->sendrecv(intf, &req);
-			if (rsp == NULL) {
-				lprintf(LOG_ERR, "Error in getting MAC Address");
-				return -1;
-			}
-			if (rsp->ccode > 0) {
-				lprintf(LOG_ERR, "Error in getting MAC Address (%s)",
-						val2str(rsp->ccode, completion_code_vals));
-				return -1;
-			}
-			memcpy(&(EmbeddedNICMacAddress.LOMMacAddress[i]),
-					((rsp->data)+PARAM_REV_OFFSET), len);
-			if (LOM_MACTYPE_ETHERNET == EmbeddedNICMacAddress.LOMMacAddress[i].MacType) {
-				if ((0xff==NicNum)
-						|| (NicNum == EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber)) {
-					printf("\n%d",EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber);
-					printf("\t\t");
-					for (j = 0; j < 5; j++) {
-						printf("%02x:",
-								EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
-					}
-					printf("%02x",
-							EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
-
-					if (LOM_ETHERNET_ENABLED
-							== EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus) {
-						printf("\tEnabled");
-					} else {
-						printf("\tDisabled");
-					}
-				}
-			}
-		}
-		printf("\n");
-	}
-	ipmi_macinfo_drac_idrac_mac(intf,NicNum);
-	return 0;
-}
-/*
- * Function Name:      ipmi_macinfo
- *
- * Description:     This function retrieves the mac address of LOMs
- * Input:           intf   - ipmi interface
- * Output:
- * Return:
- */
-static int
-ipmi_macinfo(struct ipmi_intf* intf, uint8_t NicNum)
-{
-	if (IMC_IDRAC_10G == IMC_Type) {
-		return ipmi_macinfo_10g(intf,NicNum);
-	} else if ((IMC_IDRAC_11G_MODULAR == IMC_Type
-				|| IMC_IDRAC_11G_MONOLITHIC == IMC_Type)
-			|| (IMC_IDRAC_12G_MODULAR == IMC_Type
-				|| IMC_IDRAC_12G_MONOLITHIC == IMC_Type)
-			|| (IMC_IDRAC_13G_MODULAR == IMC_Type
-				|| IMC_IDRAC_13G_MONOLITHIC == IMC_Type)
-			|| (IMC_MASER_LITE_NU == IMC_Type || IMC_MASER_LITE_BMC== IMC_Type)) {
-		return ipmi_macinfo_11g(intf,NicNum);
-	} else {
-		lprintf(LOG_ERR, "Error in getting MAC Address : Not supported platform");
-		return (-1);
-	}
-}
-/*
- * Function Name:     ipmi_mac_usage
- *
- * Description:   This function prints help message for mac command
- * Input:
- * Output:
- *
- * Return:
- */
-static void
-ipmi_mac_usage(void)
-{
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   mac list");
-	lprintf(LOG_NOTICE,
-"      Lists the MAC address of LOMs");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   mac get <NIC number>");
-	lprintf(LOG_NOTICE,
-"      Shows the MAC address of specified LOM. 0-7 System LOM, 8- DRAC/iDRAC.");
-	lprintf(LOG_NOTICE,
-"");
-}
-/*
- * Function Name:       ipmi_delloem_lan_main
- *
- * Description:         This function processes the delloem lan command
- * Input:               intf    - ipmi interface
- *                      argc    - no of arguments
- *                      argv    - argument string array
- * Output:
- *
- * Return:              return code     0 - success
- *                         -1 - failure
- */
-static int
-ipmi_delloem_lan_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int rc = 0;
-	int nic_selection = 0;
-	char nic_set[2] = {0};
-	current_arg++;
-	if (argv[current_arg] == NULL || strcmp(argv[current_arg], "help") == 0) {
-		ipmi_lan_usage();
-		return 0;
-	}
-	ipmi_idracvalidator_command(intf);
-	if (!IsLANSupported()) {
-		lprintf(LOG_ERR, "lan is not supported on this system.");
-		return -1;
-	} else if (strncmp(argv[current_arg], "set\0", 4) == 0) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			ipmi_lan_usage();
-			return -1;
-		}
-		if (iDRAC_FLAG_12_13)  {
-			nic_selection = get_nic_selection_mode_12g(intf, current_arg, argv,
-					nic_set);
-			if (INVALID == nic_selection) {
-				ipmi_lan_usage();
-				return -1;
-			} else if (INVAILD_FAILOVER_MODE == nic_selection) {
-				lprintf(LOG_ERR, INVAILD_FAILOVER_MODE_STRING);
-				return (-1);
-			} else if (INVAILD_FAILOVER_MODE_SETTINGS == nic_selection) {
-				lprintf(LOG_ERR, INVAILD_FAILOVER_MODE_SET);
-				return (-1);
-			} else if (INVAILD_SHARED_MODE == nic_selection) {
-				lprintf(LOG_ERR, INVAILD_SHARED_MODE_SET_STRING);
-				return (-1);
-			}
-			rc = ipmi_lan_set_nic_selection_12g(intf,nic_set);
-		} else {
-			nic_selection = get_nic_selection_mode(current_arg, argv);
-			if (INVALID == nic_selection) {
-				ipmi_lan_usage();
-				return -1;
-			}
-			if (IMC_IDRAC_11G_MODULAR == IMC_Type) {
-				lprintf(LOG_ERR, INVAILD_SHARED_MODE_SET_STRING);
-				return (-1);
-			}
-			rc = ipmi_lan_set_nic_selection(intf,nic_selection);
-		}
-		return 0;
-	} else if (strncmp(argv[current_arg], "get\0", 4) == 0) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			rc = ipmi_lan_get_nic_selection(intf);
-			return rc;
-		} else if (strncmp(argv[current_arg], "active\0", 7) == 0) {
-			rc = ipmi_lan_get_active_nic(intf);
-			return rc;
-		} else {
-			ipmi_lan_usage();
-		}
-	} else {
-		ipmi_lan_usage();
-		return -1;
-	}
-	return rc;
-}
-
-static int
-IsLANSupported()
-{
-	if (IMC_IDRAC_11G_MODULAR == IMC_Type) {
-		return 0;
-	}
-	return 1;
-}
-
-int
-get_nic_selection_mode_12g(struct ipmi_intf* intf,int current_arg,
-		char ** argv, char *nic_set)
-{
-	/* First get the current settings. */
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	int failover = 0;
-	uint8_t input_length = 0;
-	uint8_t msg_data[30];
-
-	input_length = 0;
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_NIC_SELECTION_12G_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting nic selection");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting nic selection (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	nic_set[0] = rsp->data[0];
-	nic_set[1] = rsp->data[1];
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "dedicated\0", 10) == 0) {
-		nic_set[0] = 1;
-		nic_set[1] = 0;
-		return 0;
-	}
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "shared\0", 7) == 0) {
-		/* placeholder */
-	} else {
-		return INVALID;
-	}
-
-	current_arg++;
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "with\0", 5) == 0) {
-		/* placeholder */
-	} else {
-		return INVALID;
-	}
-
-	current_arg++;
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "failover\0", 9) == 0) {
-		failover = 1;
-	}
-	if (failover) {
-		current_arg++;
-	}
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "lom1\0", 5) == 0) {
-		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) || (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
-			return INVAILD_SHARED_MODE;
-		}
-		if (failover) {
-			if (nic_set[0] == 2) {
-				return INVAILD_FAILOVER_MODE;
-			} else if (nic_set[0] == 1) {
-				return INVAILD_FAILOVER_MODE_SETTINGS;
-			}
-			nic_set[1] = 2;
-		} else {
-			nic_set[0] = 2;
-			if (nic_set[1] == 2) {
-				nic_set[1] = 0;
-			}
-		}
-		return 0;
-	} else if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "lom2\0", 5) == 0) {
-		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) || (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
-			return INVAILD_SHARED_MODE;
-		}
-		if (failover) {
-			if (nic_set[0] == 3) {
-				return INVAILD_FAILOVER_MODE;
-			} else if(nic_set[0] == 1) {
-				return INVAILD_FAILOVER_MODE_SETTINGS;
-			}
-			nic_set[1] = 3;
-		} else {
-			nic_set[0] = 3;
-			if (nic_set[1] == 3) {
-				nic_set[1] = 0;
-			}
-		}
-		return 0;
-	} else if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "lom3\0", 5) == 0) {
-		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) || (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
-			return INVAILD_SHARED_MODE;
-		}
-		if (failover) {
-			if (nic_set[0] == 4) {
-				return INVAILD_FAILOVER_MODE;
-			} else if(nic_set[0] == 1) {
-				return INVAILD_FAILOVER_MODE_SETTINGS;
-			}
-			nic_set[1] = 4;
-		} else {
-			nic_set[0] = 4;
-			if (nic_set[1] == 4) {
-				nic_set[1] = 0;
-			}
-		}
-		return 0;
-	} else if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "lom4\0", 5) == 0) {
-		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) || (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
-			return INVAILD_SHARED_MODE;
-		}
-		if (failover) {
-			if (nic_set[0] == 5) {
-				return INVAILD_FAILOVER_MODE;
-			} else if(nic_set[0] == 1) {
-				return INVAILD_FAILOVER_MODE_SETTINGS;
-			}
-			nic_set[1] = 5;
-		} else {
-			nic_set[0] = 5;
-			if (nic_set[1] == 5) {
-				nic_set[1] = 0;
-			}
-		}
-		return 0;
-	} else if (failover && argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "none\0", 5) == 0) {
-		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type) ) {
-			return INVAILD_SHARED_MODE;
-		}
-		if (failover) {
-			if (nic_set[0] == 1) {
-				return INVAILD_FAILOVER_MODE_SETTINGS;
-			}
-			nic_set[1] = 0;
-		}
-		return 0;
-	} else if (failover && argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "all\0", 4) == 0) {
-		/* placeholder */
-	} else {
-		return INVALID;
-	}
-
-	current_arg++;
-	if (failover && argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "loms\0", 5) == 0) {
-		if ((IMC_IDRAC_12G_MODULAR == IMC_Type) ||  (IMC_IDRAC_13G_MODULAR == IMC_Type)) {
-			return INVAILD_SHARED_MODE;
-		}
-		if (nic_set[0] == 1) {
-			return INVAILD_FAILOVER_MODE_SETTINGS;
-		}
-		nic_set[1] = 6;
-		return 0;
-	}
-	return INVALID;
-}
-
-static int
-get_nic_selection_mode(int current_arg, char ** argv)
-{
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "dedicated\0", 10) == 0) {
-		return DEDICATED;
-	}
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "shared\0", 7) == 0) {
-		if (argv[current_arg+1] == NULL) {
-			return SHARED;
-		}
-	}
-
-	current_arg++;
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "with\0", 5) == 0) {
-		/* place holder */
-	} else {
-		return INVALID;
-	}
-
-	current_arg++;
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "failover\0", 9) == 0) {
-		/* place holder */
-	} else {
-		return INVALID;
-	}
-
-	current_arg++;
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "lom2\0", 5) == 0) {
-		return SHARED_WITH_FAILOVER_LOM2;
-	} else if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "all\0", 4) == 0) {
-		/* place holder */
-	} else {
-		return INVALID;
-	}
-
-	current_arg++;
-	if (argv[current_arg] != NULL
-			&& strncmp(argv[current_arg], "loms\0", 5) == 0) {
-		return SHARED_WITH_FAILOVER_ALL_LOMS;
-	}
-	return INVALID;
-}
-
-static int
-ipmi_lan_set_nic_selection_12g(struct ipmi_intf * intf, uint8_t * nic_selection)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t input_length = 0;
-	uint8_t msg_data[30];
-
-	input_length = 0;
-	msg_data[input_length++] = nic_selection[0];
-	msg_data[input_length++] = nic_selection[1];
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = SET_NIC_SELECTION_12G_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in setting nic selection");
-		return -1;
-	} else if( (nic_selection[0] == 1)
-			&& (( iDRAC_FLAG_12_13 )
-			&& (rsp->ccode == LICENSE_NOT_SUPPORTED))) {
-		/* Check license only for setting the dedicated nic. */
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in setting nic selection (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	printf("configured successfully");
-	return 0;
-}
-
-static int
-ipmi_lan_set_nic_selection(struct ipmi_intf * intf, uint8_t nic_selection)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t input_length = 0;
-	uint8_t msg_data[30];
-
-	input_length = 0;
-	msg_data[input_length++] = nic_selection;
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = SET_NIC_SELECTION_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in setting nic selection");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in setting nic selection (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	printf("configured successfully");
-	return 0;
-}
-
-static int
-ipmi_lan_get_nic_selection(struct ipmi_intf * intf)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t input_length=0;
-	uint8_t msg_data[30];
-	uint8_t nic_selection=-1;
-	uint8_t nic_selection_failover = 0;
-
-	input_length = 0;
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	if( iDRAC_FLAG_12_13 ) {
-		req.msg.cmd = GET_NIC_SELECTION_12G_CMD;
-	} else {
-		req.msg.cmd = GET_NIC_SELECTION_CMD;
-	}
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting nic selection");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting nic selection (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	nic_selection = rsp->data[0];
-	if( iDRAC_FLAG_12_13 ) {
-		nic_selection_failover = rsp->data[1];
-		if ((nic_selection < 6) && (nic_selection > 0)
-				&& (nic_selection_failover < 7)) {
-			if(nic_selection == 1) {
-				printf("%s\n",NIC_Selection_Mode_String_12g[nic_selection-1]);
-			} else if(nic_selection) {
-				printf("Shared LOM   :  %s\n",
-						NIC_Selection_Mode_String_12g[nic_selection-1]);
-				if(nic_selection_failover  == 0) {
-					printf("Failover LOM :  None\n");
-				} else if(nic_selection_failover >= 2 && nic_selection_failover <= 6) {
-					printf("Failover LOM :  %s\n",
-							NIC_Selection_Mode_String_12g[nic_selection_failover + 3]);
-				}
-			}
-		} else {
-			lprintf(LOG_ERR, "Error Outof bond Value received (%d) (%d)",
-					nic_selection,nic_selection_failover);
-			return -1;
-		}
-	} else {
-		printf("%s\n",NIC_Selection_Mode_String[nic_selection]);
-	}
-	return 0;
-}
-
-static int
-ipmi_lan_get_active_nic(struct ipmi_intf * intf)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t active_nic=0;
-	uint8_t current_lom =0;
-	uint8_t input_length=0;
-	uint8_t msg_data[30];
-
-	input_length = 0;
-	msg_data[input_length++] = 0; /* Get Status */
-	msg_data[input_length++] = 0; /* Reserved */
-	msg_data[input_length++] = 0; /* Reserved */
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_ACTIVE_NIC_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting Active LOM Status");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting Active LOM Status (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	current_lom = rsp->data[0];
-	input_length = 0;
-	msg_data[input_length++] = 1; /* Get Link status */
-	msg_data[input_length++] = 0; /* Reserved */
-	msg_data[input_length++] = 0; /* Reserved */
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_ACTIVE_NIC_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting Active LOM Status");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting Active LOM Status (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	active_nic = rsp->data[1];
-	if (current_lom < 6 && active_nic) {
-		printf("\n%s\n", AciveLOM_String[current_lom]);
-	} else {
-		printf("\n%s\n", AciveLOM_String[0]);
-	}
-	return 0;
-}
-
-static void
-ipmi_lan_usage(void)
-{
-	/* TODO:
-	 *  - rewrite
-	 *  - review
-	 *  - make it fit into 80 chars per line
-	 *  - this ``shared with Failover None).'' seems like a typo
-	 */
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lan set <Mode>");
-	lprintf(LOG_NOTICE,
-"      sets the NIC Selection Mode :");
-	lprintf(LOG_NOTICE,
-"          on iDRAC12g OR iDRAC13g  :");
-	lprintf(LOG_NOTICE,
-"              dedicated, shared with lom1, shared with lom2,shared with lom3,shared");
-	lprintf(LOG_NOTICE,
-"              with lom4,shared with failover lom1,shared with failover lom2,shared");
-	lprintf(LOG_NOTICE,
-"              with failover lom3,shared with failover lom4,shared with Failover all");
-	lprintf(LOG_NOTICE,
-"              loms, shared with Failover None).");
-	lprintf(LOG_NOTICE,
-"          on other systems :");
-	lprintf(LOG_NOTICE,
-"              dedicated, shared, shared with failover lom2,");
-	lprintf(LOG_NOTICE,
-"              shared with Failover all loms.");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lan get ");
-	lprintf(LOG_NOTICE,
-"          on iDRAC12g or iDRAC13g  :");
-	lprintf(LOG_NOTICE,
-"              returns the current NIC Selection Mode (dedicated, shared with lom1, shared");
-	lprintf(LOG_NOTICE,
-"              with lom2, shared with lom3, shared with lom4,shared with failover lom1,");
-	lprintf(LOG_NOTICE,
-"              shared with failover lom2,shared with failover lom3,shared with failover");
-	lprintf(LOG_NOTICE,
-"              lom4,shared with Failover all loms,shared with Failover None).");
-	lprintf(LOG_NOTICE,
-"          on other systems :");
-	lprintf(LOG_NOTICE,
-"              dedicated, shared, shared with failover,");
-	lprintf(LOG_NOTICE,
-"              lom2, shared with Failover all loms.");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   lan get active");
-	lprintf(LOG_NOTICE,
-"      returns the current active NIC (dedicated, LOM1, LOM2, LOM3, LOM4).");
-	lprintf(LOG_NOTICE,
-"");
-}
-/*
- * Function Name:       ipmi_delloem_powermonitor_main
- *
- * Description:         This function processes the delloem powermonitor command
- * Input:               intf    - ipmi interface
- *                       argc    - no of arguments
- *                      argv    - argument string array
- * Output:
- *
- * Return:              return code     0 - success
- *                         -1 - failure
- */
-static int
-ipmi_delloem_powermonitor_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int rc = 0;
-	current_arg++;
-	if (argc > 1 && strcmp(argv[current_arg], "help") == 0) {
-		ipmi_powermonitor_usage();
-		return 0;
-	}
-	ipmi_idracvalidator_command(intf);
-	if (argc == 1) {
-		rc = ipmi_powermgmt(intf);
-	} else if (strncmp(argv[current_arg], "status\0", 7) == 0) {
-		rc = ipmi_powermgmt(intf);
-	} else if (strncmp(argv[current_arg], "clear\0", 6) == 0) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			ipmi_powermonitor_usage();
-			return -1;
-		} else if (strncmp(argv[current_arg], "peakpower\0", 10) == 0) {
-			rc = ipmi_powermgmt_clear(intf, 1);
-		} else if (strncmp(argv[current_arg], "cumulativepower\0", 16) == 0) {
-			rc = ipmi_powermgmt_clear(intf, 0);
-		} else {
-			ipmi_powermonitor_usage();
-			return -1;
-		}
-	} else if (strncmp(argv[current_arg], "powerconsumption\0", 17) == 0) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			rc = ipmi_print_get_power_consmpt_data(intf,watt);
-		} else if (strncmp(argv[current_arg], "watt\0", 5) == 0) {
-			rc = ipmi_print_get_power_consmpt_data(intf, watt);
-		} else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0) {
-			rc = ipmi_print_get_power_consmpt_data(intf, btuphr);
-		} else {
-			ipmi_powermonitor_usage();
-			return -1;
-		}
-	} else if (strncmp(argv[current_arg], "powerconsumptionhistory\0", 23) == 0) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			rc = ipmi_print_power_consmpt_history(intf,watt);
-		} else if (strncmp(argv[current_arg], "watt\0", 5) == 0) {
-			rc = ipmi_print_power_consmpt_history(intf, watt);
-		} else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0) {
-			rc = ipmi_print_power_consmpt_history(intf, btuphr);
-		} else {
-			ipmi_powermonitor_usage();
-			return -1;
-		}
-	} else if (strncmp(argv[current_arg], "getpowerbudget\0", 15) == 0) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			rc=ipmi_print_power_cap(intf,watt);
-		} else if (strncmp(argv[current_arg], "watt\0", 5) == 0) {
-			rc = ipmi_print_power_cap(intf, watt);
-		} else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0) {
-			rc = ipmi_print_power_cap(intf, btuphr);
-		} else {
-			ipmi_powermonitor_usage();
-			return -1;
-		}
-	} else if (strncmp(argv[current_arg], "setpowerbudget\0", 15) == 0) {
-		int val;
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			ipmi_powermonitor_usage();
-			return -1;
-		}
-		if (strchr(argv[current_arg], '.')) {
-			lprintf(LOG_ERR,
-					"Cap value in Watts, Btu/hr or percent should be whole number");
-			return -1;
-		}
-		if (str2int(argv[current_arg], &val) != 0) {
-			lprintf(LOG_ERR, "Given capacity value '%s' is invalid.",
-					argv[current_arg]);
-			return (-1);
-		}
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			ipmi_powermonitor_usage();
-		} else if (strncmp(argv[current_arg], "watt\0", 5) == 0) {
-			rc = ipmi_set_power_cap(intf,watt,val);
-		} else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0) {
-			rc = ipmi_set_power_cap(intf, btuphr,val);
-		} else if (strncmp(argv[current_arg], "percent\0", 8) == 0) {
-			rc = ipmi_set_power_cap(intf,percent,val);
-		} else {
-			ipmi_powermonitor_usage();
-			return -1;
-		}
-	} else if (strncmp(argv[current_arg], "enablepowercap\0", 15) == 0) {
-		ipmi_set_power_capstatus_command(intf,1);
-	} else if (strncmp(argv[current_arg], "disablepowercap\0", 16) == 0) {
-		ipmi_set_power_capstatus_command(intf,0);
-	} else {
-		ipmi_powermonitor_usage();
-		return -1;
-	}
-	return rc;
-}
-/*
- * Function Name:     ipmi_time_to_str
- *
- * Description:       This function converts ipmi time format into gmtime format
- * Input:             rawTime  - ipmi time format
- * Output:            strTime  - gmtime format
- *
- * Return:
- */
-static void
-ipmi_time_to_str(time_t rawTime, char * strTime)
-{
-	struct tm *tm;
-	char *temp;
-	tm = gmtime(&rawTime);
-	temp = asctime(tm);
-	strcpy(strTime,temp);
-}
-/*
- * Function Name:      ipmi_get_sensor_reading
- *
- * Description:        This function retrieves a raw sensor reading
- * Input:              sensorOwner       - sensor owner id
- *                     sensorNumber      - sensor id
- *                     intf              - ipmi interface
- * Output:             sensorReadingData - ipmi response structure
- * Return:             1 on error
- *                     0 if successful
- */
-static int
-ipmi_get_sensor_reading(struct ipmi_intf *intf, unsigned char sensorNumber,
-		SensorReadingType* pSensorReadingData)
-{
-	struct ipmi_rq req;
-	struct ipmi_rs * rsp;
-	int rc = 0;
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_SE;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_SENSOR_READING;
-	req.msg.data = &sensorNumber;
-	req.msg.data_len = 1;
-	if (pSensorReadingData == NULL) {
-		return -1;
-	}
-	memset(pSensorReadingData, 0, sizeof(SensorReadingType));
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		return 1;
-	} else if (rsp->ccode > 0) {
-		return 1;
-	}
-	memcpy(pSensorReadingData, rsp->data, sizeof(SensorReadingType));
-	/* if there is an error transmitting ipmi command, return error */
-	if (rsp->ccode != 0) {
-		rc = 1;
-	}
-	/* if sensor messages are disabled, return error*/
-	if ((!(rsp->data[1]& 0xC0)) || ((rsp->data[1] & 0x20))) {
-		rc =1;
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_get_power_capstatus_command
- *
- * Description:     This function gets the power cap status
- * Input:           intf                 - ipmi interface
- * Global:          PowercapSetable_flag - power cap status
- * Output:
- *
- * Return:
- */
-static int
-ipmi_get_power_capstatus_command(struct ipmi_intf * intf)
-{
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint8_t data[2];
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_DELL_POWER_CAP_STATUS;
-	req.msg.data_len = 2;
-	req.msg.data = data;
-	data[0] = 01;
-	data[1] = 0xFF;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error getting powercap status");
-		return -1;
-	} else if (( iDRAC_FLAG_12_13 ) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1; /* Return Error as unlicensed */
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error getting powercap statusr: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	if (rsp->data[0] & 0x02) {
-		PowercapSetable_flag=1;
-	}
-	if (rsp->data[0] & 0x01) {
-		PowercapstatusFlag=1;
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_set_power_capstatus_command
- *
- * Description:      This function sets the power cap status
- * Input:            intf     - ipmi interface
- *                   val      - power cap status
- * Output:
- *
- * Return:
- */
-static int
-ipmi_set_power_capstatus_command(struct ipmi_intf * intf, uint8_t val)
-{
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint8_t data[2];
-	if (ipmi_get_power_capstatus_command(intf) < 0) {
-		return -1;
-	}
-	if (PowercapSetable_flag != 1) {
-		lprintf(LOG_ERR, "Can not set powercap on this system");
-		return -1;
-	}
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_DELL_POWER_CAP_STATUS;
-	req.msg.data_len = 2;
-	req.msg.data = data;
-	data[0] = 00;
-	data[1] = val;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error setting powercap status");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1; /* return unlicensed Error code */
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error setting powercap statusr: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_powermgmt
- *
- * Description:      This function print the powermonitor details
- * Input:            intf     - ipmi interface
- * Output:
- *
- * Return:
- */
-static int
-ipmi_powermgmt(struct ipmi_intf * intf)
-{
-	time_t now;
-	struct tm* tm;
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t msg_data[2];
-	uint32_t cumStartTimeConv;
-	uint32_t cumReadingConv;
-	uint32_t maxPeakStartTimeConv;
-	uint32_t ampPeakTimeConv;
-	uint16_t ampReadingConv;
-	uint32_t wattPeakTimeConv;
-	uint32_t wattReadingConv;
-	uint32_t bmctimeconv;
-	uint32_t * bmctimeconvval;
-
-	IPMI_POWER_MONITOR * pwrMonitorInfo;
-
-	char cumStartTime[26];
-	char maxPeakStartTime[26];
-	char ampPeakTime[26];
-	char wattPeakTime[26];
-	char bmctime[26];
-
-	int ampReading;
-	int ampReadingRemainder;
-	int remainder;
-	int wattReading;
-
-	now = time(0);
-	tm = gmtime(&now);
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_STORAGE;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_CMD_GET_SEL_TIME;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error getting BMC time info.");
-		return -1;
-	}
-	if (rsp->ccode != 0) {
-		lprintf(LOG_ERR,
-				"Error getting power management information, return code %x",
-				rsp->ccode);
-		return -1;
-	}
-	bmctimeconvval=(uint32_t*)rsp->data;
-# if WORDS_BIGENDIAN
-	bmctimeconv=BSWAP_32(*bmctimeconvval);
-# else
-	bmctimeconv=*bmctimeconvval;
-# endif
-
-	/* get powermanagement info*/
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0x0;
-	req.msg.cmd = GET_PWRMGMT_INFO_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 2;
-
-	memset(msg_data, 0, 2);
-	msg_data[0] = 0x07;
-	msg_data[1] = 0x01;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error getting power management information.");
-		return -1;
-	}
-
-	if ((iDRAC_FLAG_12_13) && (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting power management information: "
-				"Command not supported on this system.");
-		return -1;
-	}else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR,
-				"Error getting power management information, return code %x",
-				rsp->ccode);
-		return -1;
-	}
-
-	pwrMonitorInfo = (IPMI_POWER_MONITOR*)rsp->data;
-# if WORDS_BIGENDIAN
-	cumStartTimeConv = BSWAP_32(pwrMonitorInfo->cumStartTime);
-	cumReadingConv = BSWAP_32(pwrMonitorInfo->cumReading);
-	maxPeakStartTimeConv = BSWAP_32(pwrMonitorInfo->maxPeakStartTime);
-	ampPeakTimeConv = BSWAP_32(pwrMonitorInfo->ampPeakTime);
-	ampReadingConv = BSWAP_16(pwrMonitorInfo->ampReading);
-	wattPeakTimeConv = BSWAP_32(pwrMonitorInfo->wattPeakTime);
-	wattReadingConv = BSWAP_16(pwrMonitorInfo->wattReading);
-# else
-	cumStartTimeConv = pwrMonitorInfo->cumStartTime;
-	cumReadingConv = pwrMonitorInfo->cumReading;
-	maxPeakStartTimeConv = pwrMonitorInfo->maxPeakStartTime;
-	ampPeakTimeConv = pwrMonitorInfo->ampPeakTime;
-	ampReadingConv = pwrMonitorInfo->ampReading;
-	wattPeakTimeConv = pwrMonitorInfo->wattPeakTime;
-	wattReadingConv = pwrMonitorInfo->wattReading;
-# endif
-
-	ipmi_time_to_str(cumStartTimeConv, cumStartTime);
-	ipmi_time_to_str(maxPeakStartTimeConv, maxPeakStartTime);
-	ipmi_time_to_str(ampPeakTimeConv, ampPeakTime);
-	ipmi_time_to_str(wattPeakTimeConv, wattPeakTime);
-	ipmi_time_to_str(bmctimeconv, bmctime);
-	now = time(0);
-
-	remainder = (cumReadingConv % 1000);
-	cumReadingConv = cumReadingConv / 1000;
-	remainder = (remainder + 50) / 100;
-
-	ampReading = ampReadingConv;
-	ampReadingRemainder = ampReading%10;
-	ampReading = ampReading/10;
-
-	wattReading = wattReadingConv;
-
-	printf("Power Tracking Statistics\n");
-	printf("Statistic      : Cumulative Energy Consumption\n");
-	printf("Start Time     : %s", cumStartTime);
-	printf("Finish Time    : %s", bmctime);
-	printf("Reading        : %d.%d kWh\n\n", cumReadingConv, remainder);
-
-	printf("Statistic      : System Peak Power\n");
-	printf("Start Time     : %s", maxPeakStartTime);
-	printf("Peak Time      : %s", wattPeakTime);
-	printf("Peak Reading   : %d W\n\n", wattReading);
-
-	printf("Statistic      : System Peak Amperage\n");
-	printf("Start Time     : %s", maxPeakStartTime);
-	printf("Peak Time      : %s", ampPeakTime);
-	printf("Peak Reading   : %d.%d A\n", ampReading, ampReadingRemainder);
-	return 0;
-}
-/*
- * Function Name:    ipmi_powermgmt_clear
- *
- * Description:     This function clears peakpower / cumulativepower value
- * Input:           intf           - ipmi interface
- *                  clearValue     - peakpower / cumulativepower
- * Output:
- *
- * Return:
- */
-static int
-ipmi_powermgmt_clear(struct ipmi_intf * intf, uint8_t clearValue)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t clearType = 1;
-	uint8_t msg_data[3];
-	if (clearValue) {
-		clearType = 2;
-	}
-	/* clear powermanagement info*/
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = CLEAR_PWRMGMT_INFO_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 3;
-	memset(msg_data, 0, 3);
-	msg_data[0] = 0x07;
-	msg_data[1] = 0x01;
-	msg_data[2] = clearType;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error clearing power values.");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13)
-			&& (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if (rsp->ccode == 0xc1) {
-		lprintf(LOG_ERR,
-				"Error clearing power values, command not supported on this system.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Error clearing power values: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    watt_to_btuphr_conversion
- *
- * Description:      This function converts the power value in watt to btuphr
- * Input:            powerinwatt     - power in watt
- *
- * Output:           power in btuphr
- *
- * Return:
- */
-static uint64_t
-watt_to_btuphr_conversion(uint32_t powerinwatt)
-{
-	uint64_t powerinbtuphr;
-	powerinbtuphr=(3.413 * powerinwatt);
-	return(powerinbtuphr);
-}
-/*
- * Function Name:    btuphr_to_watt_conversion
- *
- * Description:      This function converts the power value in  btuphr to watt
- * Input:            powerinbtuphr   - power in btuphr
- *
- * Output:           power in watt
- *
- * Return:
- */
-static uint32_t
-btuphr_to_watt_conversion(uint64_t powerinbtuphr)
-{
-	uint32_t powerinwatt;
-	/*returning the floor value*/
-	powerinwatt= (powerinbtuphr / 3.413);
-	return (powerinwatt);
-}
-/*
- * Function Name:        ipmi_get_power_headroom_command
- *
- * Description:          This function prints the Power consumption information
- * Input:                intf    - ipmi interface
- *                       unit    - watt / btuphr
- * Output:
- *
- * Return:
- */
-static int
-ipmi_get_power_headroom_command(struct ipmi_intf * intf,uint8_t unit)
-{
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint64_t peakpowerheadroombtuphr;
-	uint64_t instantpowerhearoom;
-
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_PWR_HEADROOM_CMD;
-	req.msg.data_len = 0;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error getting power headroom status");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13)
-			&& (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if ((rsp->ccode == 0xc1) || (rsp->ccode == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting power headroom status: "
-				"Command not supported on this system ");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error getting power headroom status: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	if (verbose > 1) {
-		/* need to look into */
-		printf("power headroom  Data               : %x %x %x %x ", rsp->data[0],
-				rsp->data[1], rsp->data[2], rsp->data[3]);
-	}
-	powerheadroom= *(( POWER_HEADROOM *)rsp->data);
-# if WORDS_BIGENDIAN
-	powerheadroom.instheadroom = BSWAP_16(powerheadroom.instheadroom);
-	powerheadroom.peakheadroom = BSWAP_16(powerheadroom.peakheadroom);
-# endif
-	printf("Headroom\n");
-	printf("Statistic                     Reading\n");
-	if (unit == btuphr) {
-		peakpowerheadroombtuphr = watt_to_btuphr_conversion(powerheadroom.peakheadroom);
-		instantpowerhearoom = watt_to_btuphr_conversion(powerheadroom.instheadroom);
-		printf("System Instantaneous Headroom : %lld BTU/hr\n",
-				instantpowerhearoom);
-		printf("System Peak Headroom          : %lld BTU/hr\n",
-				peakpowerheadroombtuphr);
-	} else {
-		printf("System Instantaneous Headroom : %d W\n",
-				powerheadroom.instheadroom);
-		printf("System Peak Headroom          : %d W\n",
-				powerheadroom.peakheadroom);
-	}
-	return 0;
-}
-/*
- * Function Name:       ipmi_get_power_consumption_data
- *
- * Description:         This function updates the instant Power consumption information
- * Input:               intf - ipmi interface
- * Output:              power consumption current reading
- *                      Assumption value will be in Watt.
- *
- * Return:
- */
-static int
-ipmi_get_power_consumption_data(struct ipmi_intf * intf,uint8_t unit)
-{
-	SensorReadingType sensorReadingData;
-
-	struct ipmi_rs * rsp=NULL;
-	struct sdr_record_list *sdr;
-	int readingbtuphr = 0;
-	int warning_threshbtuphr = 0;
-	int failure_threshbtuphr = 0;
-	int status = 0;
-	int sensor_number = 0;
-	sdr = ipmi_sdr_find_sdr_byid(intf, "System Level");
-	if (sdr == NULL) {
-		lprintf(LOG_ERR,
-				"Error : Can not access the System Level sensor data");
-		return -1;
-	}
-	sensor_number = sdr->record.common->keys.sensor_num;
-	ipmi_get_sensor_reading(intf,sensor_number,&sensorReadingData);
-	rsp = ipmi_sdr_get_sensor_thresholds(intf,
-			sdr->record.common->keys.sensor_num,
-			sdr->record.common->keys.owner_id,
-			sdr->record.common->keys.lun,
-			sdr->record.common->keys.channel);
-	if (rsp == NULL || rsp->ccode != 0) {
-		lprintf(LOG_ERR,
-				"Error : Can not access the System Level sensor data");
-		return -1;
-	}
-	readingbtuphr = sdr_convert_sensor_reading(sdr->record.full,
-			sensorReadingData.sensorReading);
-	warning_threshbtuphr = sdr_convert_sensor_reading(sdr->record.full,
-			rsp->data[4]);
-	failure_threshbtuphr = sdr_convert_sensor_reading(sdr->record.full,
-			rsp->data[5]);
-
-	printf("System Board System Level\n");
-	if (unit == btuphr) {
-		readingbtuphr = watt_to_btuphr_conversion(readingbtuphr);
-		warning_threshbtuphr = watt_to_btuphr_conversion(warning_threshbtuphr);
-		failure_threshbtuphr = watt_to_btuphr_conversion( failure_threshbtuphr);
-
-		printf("Reading                        : %d BTU/hr\n", readingbtuphr);
-		printf("Warning threshold      : %d BTU/hr\n", warning_threshbtuphr);
-		printf("Failure threshold      : %d BTU/hr\n", failure_threshbtuphr);
-	} else {
-		printf("Reading                        : %d W \n",readingbtuphr);
-		printf("Warning threshold      : %d W \n",(warning_threshbtuphr));
-		printf("Failure threshold      : %d W \n",(failure_threshbtuphr));
-	}
-	return status;
-}
-/*
- * Function Name:      ipmi_get_instan_power_consmpt_data
- *
- * Description:        This function updates the instant Power consumption information
- * Input:              intf - ipmi interface
- * Output:             instpowerconsumptiondata - instant Power consumption information
- *
- * Return:
- */
-static int
-ipmi_get_instan_power_consmpt_data(struct ipmi_intf * intf,
-		IPMI_INST_POWER_CONSUMPTION_DATA * instpowerconsumptiondata)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req={0};
-	uint8_t msg_data[2];
-	/*get instantaneous power consumption command*/
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = GET_PWR_CONSUMPTION_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 2;
-	memset(msg_data, 0, 2);
-	msg_data[0] = 0x0A;
-	msg_data[1] = 0x00;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error getting instantaneous power consumption data .");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13)
-			&& (rsp->ccode == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if ((rsp->ccode == 0xc1) || (rsp->ccode == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting instantaneous power consumption data: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Error getting instantaneous power consumption data: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	*instpowerconsumptiondata = *((IPMI_INST_POWER_CONSUMPTION_DATA *)(rsp->data));
-#if WORDS_BIGENDIAN
-	instpowerconsumptiondata->instanpowerconsumption = BSWAP_16(instpowerconsumptiondata->instanpowerconsumption);
-	instpowerconsumptiondata->instanApms = BSWAP_16(instpowerconsumptiondata->instanApms);
-	instpowerconsumptiondata->resv1 = BSWAP_16(instpowerconsumptiondata->resv1);
-#endif
-	return 0;
-}
-/*
- * Function Name:      ipmi_print_get_instan_power_Amps_data
- *
- * Description:        This function prints the instant Power consumption information
- * Input:              instpowerconsumptiondata - instant Power consumption information
- * Output:
- *
- * Return:
- */
-static void
-ipmi_print_get_instan_power_Amps_data(IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata)
-{
-	uint16_t intampsval=0;
-	uint16_t decimalampsval=0;
-	if (instpowerconsumptiondata.instanApms > 0) {
-		decimalampsval = (instpowerconsumptiondata.instanApms % 10);
-		intampsval = instpowerconsumptiondata.instanApms / 10;
-	}
-	printf("\nAmperage value: %d.%d A \n", intampsval, decimalampsval);
-}
-/*
- * Function Name:     ipmi_print_get_power_consmpt_data
- *
- * Description:       This function prints the Power consumption information
- * Input:             intf            - ipmi interface
- *                    unit            - watt / btuphr
- * Output:
- *
- * Return:
- */
-static int
-ipmi_print_get_power_consmpt_data(struct ipmi_intf * intf, uint8_t unit)
-{
-	int rc = 0;
-	IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata = {0,0,0,0};
-	printf("\nPower consumption information\n");
-	rc = ipmi_get_power_consumption_data(intf, unit);
-	if (rc == (-1)) {
-		return rc;
-	}
-	rc = ipmi_get_instan_power_consmpt_data(intf, &instpowerconsumptiondata);
-	if (rc == (-1)) {
-		return rc;
-	}
-	ipmi_print_get_instan_power_Amps_data(instpowerconsumptiondata);
-	rc = ipmi_get_power_headroom_command(intf, unit);
-	if (rc == (-1)) {
-		return rc;
-	}
-	return rc;
-}
-/*
- * Function Name:   ipmi_get_avgpower_consmpt_history
- *
- * Description:     This function updates the average power consumption information
- * Input:           intf            - ipmi interface
- * Output:          pavgpower- average power consumption information
- *
- * Return:
- */
-static int
-ipmi_get_avgpower_consmpt_history(struct ipmi_intf * intf,
-		IPMI_AVGPOWER_CONSUMP_HISTORY * pavgpower)
-{
-	int rc;
-	uint8_t *rdata;
-	rc = ipmi_mc_getsysinfo(intf, 0xeb, 0, 0, sizeof(*pavgpower), pavgpower);
-	if (rc < 0) {
-		lprintf(LOG_ERR,
-				"Error getting average power consumption history data.");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13) &&  (rc == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting average power consumption history data: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rc != 0) {
-		lprintf(LOG_ERR,
-				"Error getting average power consumption history data: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	if (verbose > 1) {
-		rdata = (void *)pavgpower;
-		printf("Average power consumption history data"
-				"       :%x %x %x %x %x %x %x %x\n\n",
-				rdata[0], rdata[1], rdata[2], rdata[3],
-				rdata[4], rdata[5], rdata[6], rdata[7]);
-	}
-# if WORDS_BIGENDIAN
-	pavgpower->lastminutepower = BSWAP_16(pavgpower->lastminutepower);
-	pavgpower->lasthourpower = BSWAP_16(pavgpower->lasthourpower);
-	pavgpower->lastdaypower = BSWAP_16(pavgpower->lastdaypower);
-	pavgpower->lastweakpower = BSWAP_16(pavgpower->lastweakpower);
-# endif
-	return 0;
-}
-/*
- * Function Name:    ipmi_get_peakpower_consmpt_history
- *
- * Description:      This function updates the peak power consumption information
- * Input:            intf            - ipmi interface
- * Output:           pavgpower- peak power consumption information
- *
- * Return:
- */
-static int
-ipmi_get_peakpower_consmpt_history(struct ipmi_intf * intf,
-		IPMI_POWER_CONSUMP_HISTORY * pstPeakpower)
-{
-	uint8_t *rdata;
-	int rc;
-	rc = ipmi_mc_getsysinfo(intf, 0xec, 0, 0, sizeof(*pstPeakpower),
-			pstPeakpower);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting  peak power consumption history data.");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13) && (rc == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting peak power consumption history data: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rc != 0) {
-		lprintf(LOG_ERR, "Error getting peak power consumption history data: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	if (verbose > 1) {
-		rdata = (void *)pstPeakpower;
-		printf("Peak power consmhistory  Data               : "
-				"%x %x %x %x %x %x %x %x %x %x\n   "
-				"%x %x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
-				rdata[0], rdata[1], rdata[2], rdata[3],
-				rdata[4], rdata[5], rdata[6], rdata[7],
-				rdata[8], rdata[9], rdata[10], rdata[11],
-				rdata[12], rdata[13], rdata[14], rdata[15],
-				rdata[16], rdata[17], rdata[18], rdata[19],
-				rdata[20], rdata[21], rdata[22], rdata[23]);
-	}
-# if WORDS_BIGENDIAN
-	pstPeakpower->lastminutepower = BSWAP_16(pstPeakpower->lastminutepower);
-	pstPeakpower->lasthourpower = BSWAP_16(pstPeakpower->lasthourpower);
-	pstPeakpower->lastdaypower = BSWAP_16(pstPeakpower->lastdaypower);
-	pstPeakpower->lastweakpower = BSWAP_16(pstPeakpower->lastweakpower);
-	pstPeakpower->lastminutepowertime = BSWAP_32(pstPeakpower->lastminutepowertime);
-	pstPeakpower->lasthourpowertime = BSWAP_32(pstPeakpower->lasthourpowertime);
-	pstPeakpower->lastdaypowertime = BSWAP_32(pstPeakpower->lastdaypowertime);
-	pstPeakpower->lastweekpowertime = BSWAP_32(pstPeakpower->lastweekpowertime);
-#endif
-	return 0;
-}
-/*
- * Function Name:    ipmi_get_minpower_consmpt_history
- *
- * Description:      This function updates the peak power consumption information
- * Input:            intf            - ipmi interface
- * Output:           pavgpower- peak power consumption information
- *
- * Return:
- */
-static int
-ipmi_get_minpower_consmpt_history(struct ipmi_intf * intf,
-		IPMI_POWER_CONSUMP_HISTORY * pstMinpower)
-{
-	uint8_t *rdata;
-	int rc;
-	rc = ipmi_mc_getsysinfo(intf, 0xed, 0, 0, sizeof(*pstMinpower),
-			pstMinpower);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting  peak power consumption history data .");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13) &&  (rc == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting peak power consumption history data: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rc != 0) {
-		lprintf(LOG_ERR, "Error getting peak power consumption history data: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	if (verbose > 1) {
-		rdata = (void *)pstMinpower;
-		printf("Peak power consmhistory  Data               : "
-				"%x %x %x %x %x %x %x %x %x %x\n   "
-				"%x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
-				rdata[0], rdata[1], rdata[2], rdata[3],
-				rdata[4], rdata[5], rdata[6], rdata[7],
-				rdata[8], rdata[9], rdata[10], rdata[11],
-				rdata[12], rdata[13], rdata[14], rdata[15],
-				rdata[16], rdata[17], rdata[18], rdata[19],
-				rdata[20], rdata[21], rdata[22], rdata[23]);
-	}
-# if WORDS_BIGENDIAN
-	pstMinpower->lastminutepower = BSWAP_16(pstMinpower->lastminutepower);
-	pstMinpower->lasthourpower = BSWAP_16(pstMinpower->lasthourpower);
-	pstMinpower->lastdaypower = BSWAP_16(pstMinpower->lastdaypower);
-	pstMinpower->lastweakpower = BSWAP_16(pstMinpower->lastweakpower);
-	pstMinpower->lastminutepowertime = BSWAP_32(pstMinpower->lastminutepowertime);
-	pstMinpower->lasthourpowertime = BSWAP_32(pstMinpower->lasthourpowertime);
-	pstMinpower->lastdaypowertime = BSWAP_32(pstMinpower->lastdaypowertime);
-	pstMinpower->lastweekpowertime = BSWAP_32(pstMinpower->lastweekpowertime);
-# endif
-	return 0;
-}
-/*
- * Function Name:    ipmi_print_power_consmpt_history
- *
- * Description:      This function print the average and peak power consumption information
- * Input:            intf      - ipmi interface
- *                   unit      - watt / btuphr
- * Output:
- *
- * Return:
- */
-static int
-ipmi_print_power_consmpt_history(struct ipmi_intf * intf, int unit)
-{
-	char timestr[30];
-	uint32_t lastminutepeakpower;
-	uint32_t lasthourpeakpower;
-	uint32_t lastdaypeakpower;
-	uint32_t lastweekpeakpower;
-	uint64_t tempbtuphrconv;
-	int rc = 0;
-
-	IPMI_AVGPOWER_CONSUMP_HISTORY avgpower;
-	IPMI_POWER_CONSUMP_HISTORY stMinpower;
-	IPMI_POWER_CONSUMP_HISTORY stPeakpower;
-
-	rc = ipmi_get_avgpower_consmpt_history(intf, &avgpower);
-	if (rc == (-1)) {
-		return rc;
-	}
-
-	rc = ipmi_get_peakpower_consmpt_history(intf, &stPeakpower);
-	if (rc == (-1)) {
-		return rc;
-	}
-
-	rc = ipmi_get_minpower_consmpt_history(intf, &stMinpower);
-	if (rc == (-1)) {
-		return rc;
-	}
-	if (rc != 0) {
-		return rc;
-	}
-	printf("Power Consumption History\n\n");
-	/* The fields are alligned manually changing the spaces will alter
-	 * the alignment*/
-	printf("Statistic                   Last Minute     Last Hour     "
-			"Last Day     Last Week\n\n");
-	if (unit == btuphr) {
-		printf("Average Power Consumption  ");
-		tempbtuphrconv = watt_to_btuphr_conversion(avgpower.lastminutepower);
-		printf("%4lld BTU/hr     ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(avgpower.lasthourpower);
-		printf("%4lld BTU/hr   ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(avgpower.lastdaypower);
-		printf("%4lld BTU/hr  ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(avgpower.lastweakpower);
-		printf("%4lld BTU/hr\n", tempbtuphrconv);
-
-		printf("Max Power Consumption      ");
-		tempbtuphrconv = watt_to_btuphr_conversion(stPeakpower.lastminutepower);
-		printf("%4lld BTU/hr     ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(stPeakpower.lasthourpower);
-		printf("%4lld BTU/hr   ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(stPeakpower.lastdaypower);
-		printf("%4lld BTU/hr  ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(stPeakpower.lastweakpower);
-		printf("%4lld BTU/hr\n", tempbtuphrconv);
-
-		printf("Min Power Consumption      ");
-		tempbtuphrconv = watt_to_btuphr_conversion(stMinpower.lastminutepower);
-		printf("%4lld BTU/hr     ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(stMinpower.lasthourpower);
-		printf("%4lld BTU/hr   ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(stMinpower.lastdaypower);
-		printf("%4lld BTU/hr  ", tempbtuphrconv);
-		tempbtuphrconv = watt_to_btuphr_conversion(stMinpower.lastweakpower);
-		printf("%4lld BTU/hr\n\n", tempbtuphrconv);
-	} else {
-		printf("Average Power Consumption  ");
-		tempbtuphrconv = (avgpower.lastminutepower);
-		printf("%4lld W          ", tempbtuphrconv);
-		tempbtuphrconv = (avgpower.lasthourpower);
-		printf("%4lld W        ", tempbtuphrconv);
-		tempbtuphrconv = (avgpower.lastdaypower);
-		printf("%4lld W       ", tempbtuphrconv);
-		tempbtuphrconv=(avgpower.lastweakpower);
-		printf("%4lld W   \n", tempbtuphrconv);
-
-		printf("Max Power Consumption      ");
-		tempbtuphrconv = (stPeakpower.lastminutepower);
-		printf("%4lld W          ", tempbtuphrconv);
-		tempbtuphrconv = (stPeakpower.lasthourpower);
-		printf("%4lld W        ", tempbtuphrconv);
-		tempbtuphrconv = (stPeakpower.lastdaypower);
-		printf("%4lld W       ", tempbtuphrconv);
-		tempbtuphrconv = (stPeakpower.lastweakpower);
-		printf("%4lld W   \n", tempbtuphrconv);
-
-		printf("Min Power Consumption      ");
-		tempbtuphrconv = (stMinpower.lastminutepower);
-		printf("%4lld W          ", tempbtuphrconv);
-		tempbtuphrconv = (stMinpower.lasthourpower);
-		printf("%4lld W        ", tempbtuphrconv);
-		tempbtuphrconv = (stMinpower.lastdaypower);
-		printf("%4lld W       ", tempbtuphrconv);
-		tempbtuphrconv = (stMinpower.lastweakpower);
-		printf("%4lld W   \n\n", tempbtuphrconv);
-	}
-
-	lastminutepeakpower = stPeakpower.lastminutepowertime;
-	lasthourpeakpower = stPeakpower.lasthourpowertime;
-	lastdaypeakpower = stPeakpower.lastdaypowertime;
-	lastweekpeakpower = stPeakpower.lastweekpowertime;
-
-	printf("Max Power Time\n");
-	ipmi_time_to_str(lastminutepeakpower, timestr);
-	printf("Last Minute     : %s",timestr);
-	ipmi_time_to_str(lasthourpeakpower, timestr);
-	printf("Last Hour       : %s",timestr);
-	ipmi_time_to_str(lastdaypeakpower, timestr);
-	printf("Last Day        : %s",timestr);
-	ipmi_time_to_str(lastweekpeakpower, timestr);
-	printf("Last Week       : %s",timestr);
-
-	lastminutepeakpower=stMinpower.lastminutepowertime;
-	lasthourpeakpower=stMinpower.lasthourpowertime;
-	lastdaypeakpower=stMinpower.lastdaypowertime;
-	lastweekpeakpower=stMinpower.lastweekpowertime;
-
-	printf("Min Power Time\n");
-	ipmi_time_to_str(lastminutepeakpower, timestr);
-	printf("Last Minute     : %s", timestr);
-	ipmi_time_to_str(lasthourpeakpower, timestr);
-	printf("Last Hour       : %s", timestr);
-	ipmi_time_to_str(lastdaypeakpower, timestr);
-	printf("Last Day        : %s", timestr);
-	ipmi_time_to_str(lastweekpeakpower, timestr);
-	printf("Last Week       : %s", timestr);
-	return rc;
-}
-/*
- * Function Name:    ipmi_get_power_cap
- *
- * Description:      This function updates the power cap information
- * Input:            intf         - ipmi interface
- * Output:           ipmipowercap - power cap information
- *
- * Return:
- */
-static int
-ipmi_get_power_cap(struct ipmi_intf * intf, IPMI_POWER_CAP * ipmipowercap)
-{
-	uint8_t *rdata;
-	int rc;
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_POWER_CAP, 0, 0,
-			sizeof(*ipmipowercap), ipmipowercap);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting power cap.");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13) && (rc == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if ((rc == 0xc1) || (rc == 0xcb)) {
-		lprintf(LOG_ERR, "Error getting power cap: "
-				"Command not supported on this system.");
-		return -1;
-	} else if (rc != 0) {
-		lprintf(LOG_ERR, "Error getting power cap: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	if (verbose > 1) {
-		rdata = (void*)ipmipowercap;
-		printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
-				rdata[1], rdata[2], rdata[3],
-				rdata[4], rdata[5], rdata[6], rdata[7],
-				rdata[8], rdata[9], rdata[10],rdata[11]);
-	}
-# if WORDS_BIGENDIAN
-	ipmipowercap->PowerCap = BSWAP_16(ipmipowercap->PowerCap);
-	ipmipowercap->MaximumPowerConsmp = BSWAP_16(ipmipowercap->MaximumPowerConsmp);
-	ipmipowercap->MinimumPowerConsmp = BSWAP_16(ipmipowercap->MinimumPowerConsmp);
-	ipmipowercap->totalnumpowersupp = BSWAP_16(ipmipowercap->totalnumpowersupp);
-	ipmipowercap->AvailablePower = BSWAP_16(ipmipowercap->AvailablePower);
-	ipmipowercap->SystemThrottling = BSWAP_16(ipmipowercap->SystemThrottling);
-	ipmipowercap->Resv = BSWAP_16(ipmipowercap->Resv);
-# endif
-	return 0;
-}
-/*
- * Function Name:    ipmi_print_power_cap
- *
- * Description:      This function print the power cap information
- * Input:            intf            - ipmi interface
- *                   unit            - watt / btuphr
- * Output:
- * Return:
- */
-static int
-ipmi_print_power_cap(struct ipmi_intf * intf,uint8_t unit)
-{
-	uint64_t tempbtuphrconv;
-	int rc;
-	IPMI_POWER_CAP ipmipowercap;
-	memset(&ipmipowercap, 0, sizeof(ipmipowercap));
-	rc = ipmi_get_power_cap(intf, &ipmipowercap);
-	if (rc == 0) {
-		if (unit == btuphr) {
-			tempbtuphrconv = watt_to_btuphr_conversion(ipmipowercap.MaximumPowerConsmp);
-			printf("Maximum power: %lld  BTU/hr\n", tempbtuphrconv);
-			tempbtuphrconv = watt_to_btuphr_conversion(ipmipowercap.MinimumPowerConsmp);
-			printf("Minimum power: %lld  BTU/hr\n", tempbtuphrconv);
-			tempbtuphrconv = watt_to_btuphr_conversion(ipmipowercap.PowerCap);
-			printf("Power cap    : %lld  BTU/hr\n", tempbtuphrconv);
-		} else {
-			printf("Maximum power: %d Watt\n", ipmipowercap.MaximumPowerConsmp);
-			printf("Minimum power: %d Watt\n", ipmipowercap.MinimumPowerConsmp);
-			printf("Power cap    : %d Watt\n", ipmipowercap.PowerCap);
-		}
-	}
-	return rc;
-}
-/*
- * Function Name:     ipmi_set_power_cap
- *
- * Description:       This function updates the power cap information
- * Input:             intf            - ipmi interface
- *                    unit            - watt / btuphr
- *                    val             - new power cap value
- * Output:
- * Return:
- */
-static int
-ipmi_set_power_cap(struct ipmi_intf * intf, int unit, int val)
-{
-	int rc;
-	uint8_t data[13], *rdata;
-	uint16_t powercapval;
-	uint64_t maxpowerbtuphr;
-	uint64_t maxpowerbtuphr1;
-	uint64_t minpowerbtuphr;
-	IPMI_POWER_CAP ipmipowercap;
-
-	if (ipmi_get_power_capstatus_command(intf) < 0) {
-		return -1; /* Adding the failed condition check */
-	}
-	if (PowercapSetable_flag != 1) {
-		lprintf(LOG_ERR, "Can not set powercap on this system");
-		return -1;
-	} else if (PowercapstatusFlag != 1) {
-		lprintf(LOG_ERR, "Power cap set feature is not enabled");
-		return -1;
-	}
-	rc = ipmi_mc_getsysinfo(intf, IPMI_DELL_POWER_CAP, 0, 0,
-			sizeof(ipmipowercap), &ipmipowercap);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error getting power cap.");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13) && (rc == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if (rc == 0xc1) {
-		lprintf(LOG_ERR, "Error getting power cap, command not supported on "
-				"this system.");
-		return -1;
-	} else if (rc != 0) {
-		lprintf(LOG_ERR, "Error getting power cap: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	if (verbose > 1) {
-		rdata = (void *)&ipmipowercap;
-		printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x %x ",
-				rdata[1], rdata[2], rdata[3],
-				rdata[4], rdata[5], rdata[6], rdata[7],
-				rdata[8], rdata[9], rdata[10],rdata[11]);
-	}
-# if WORDS_BIGENDIAN
-	ipmipowercap.PowerCap = BSWAP_16(ipmipowercap.PowerCap);
-	ipmipowercap.MaximumPowerConsmp = BSWAP_16(ipmipowercap.MaximumPowerConsmp);
-	ipmipowercap.MinimumPowerConsmp = BSWAP_16(ipmipowercap.MinimumPowerConsmp);
-	ipmipowercap.AvailablePower = BSWAP_16(ipmipowercap.AvailablePower);
-	ipmipowercap.totalnumpowersupp = BSWAP_16(ipmipowercap.totalnumpowersupp);
-# endif
-	memset(data, 0, 13);
-	data[0] = IPMI_DELL_POWER_CAP;
-	powercapval = val;
-	data[1] = (powercapval & 0XFF);
-	data[2] = ((powercapval & 0XFF00) >> 8);
-	data[3] = unit;
-	data[4] = ((ipmipowercap.MaximumPowerConsmp & 0xFF));
-	data[5] = ((ipmipowercap.MaximumPowerConsmp & 0xFF00) >> 8);
-	data[6] = ((ipmipowercap.MinimumPowerConsmp & 0xFF));
-	data[7] = ((ipmipowercap.MinimumPowerConsmp & 0xFF00) >> 8);
-	data[8] = (ipmipowercap.totalnumpowersupp);
-	data[9] = ((ipmipowercap.AvailablePower & 0xFF));
-	data[10] = ((ipmipowercap.AvailablePower & 0xFF00) >> 8);
-	data[11] = (ipmipowercap.SystemThrottling);
-	data[12] = 0x00;
-
-	if (unit == btuphr) {
-		val = btuphr_to_watt_conversion(val);
-	} else if (unit == percent) {
-		if ((val < 0) || (val > 100)) {
-			lprintf(LOG_ERR, "Cap value is out of boundary conditon it "
-					"should be between 0  - 100");
-			return -1;
-		}
-		val = ((val*(ipmipowercap.MaximumPowerConsmp
-						- ipmipowercap.MinimumPowerConsmp)) / 100)
-						+ ipmipowercap.MinimumPowerConsmp;
-		lprintf(LOG_ERR, "Cap value in percentage is  %d ", val);
-		data[1] = (val & 0XFF);
-		data[2] = ((val & 0XFF00) >> 8);
-		data[3] = watt;
-	}
-	if (((val < ipmipowercap.MinimumPowerConsmp)
-				|| (val > ipmipowercap.MaximumPowerConsmp)) && (unit == watt)) {
-		lprintf(LOG_ERR,
-				"Cap value is out of boundary conditon it should be between %d  - %d",
-				ipmipowercap.MinimumPowerConsmp, ipmipowercap.MaximumPowerConsmp);
-		return -1;
-	} else if (((val < ipmipowercap.MinimumPowerConsmp)
-				|| (val > ipmipowercap.MaximumPowerConsmp)) && (unit == btuphr)) {
-		minpowerbtuphr = watt_to_btuphr_conversion(ipmipowercap.MinimumPowerConsmp);
-		maxpowerbtuphr = watt_to_btuphr_conversion(ipmipowercap.MaximumPowerConsmp);
-		maxpowerbtuphr1 = watt_to_btuphr_conversion(ipmipowercap.MaximumPowerConsmp);
-		lprintf(LOG_ERR,
-				"Cap value is out of boundary conditon it should be between %d",
-				minpowerbtuphr);
-		lprintf(LOG_ERR, " -%d", maxpowerbtuphr1);
-		return -1;
-	}
-	rc = ipmi_mc_setsysinfo(intf, 13, data);
-	if (rc < 0) {
-		lprintf(LOG_ERR, "Error setting power cap");
-		return -1;
-	} else if ((iDRAC_FLAG_12_13) && (rc == LICENSE_NOT_SUPPORTED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if (rc > 0) {
-		lprintf(LOG_ERR, "Error setting power cap: %s",
-				val2str(rc, completion_code_vals));
-		return -1;
-	}
-	if (verbose > 1) {
-		printf("CC for setpowercap :%d ", rc);
-	}
-	return 0;
-}
-/*
- * Function Name:   ipmi_powermonitor_usage
- *
- * Description:     This function prints help message for powermonitor command
- * Input:
- * Output:
- *
- * Return:
- */
-static void
-ipmi_powermonitor_usage(void)
-{
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor");
-	lprintf(LOG_NOTICE,
-"      Shows power tracking statistics ");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor clear cumulativepower");
-	lprintf(LOG_NOTICE,
-"      Reset cumulative power reading");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor clear peakpower");
-	lprintf(LOG_NOTICE,
-"      Reset peak power reading");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor powerconsumption");
-	lprintf(LOG_NOTICE,
-"      Displays power consumption in <watt|btuphr>");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor powerconsumptionhistory <watt|btuphr>");
-	lprintf(LOG_NOTICE,
-"      Displays power consumption history ");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor getpowerbudget");
-	lprintf(LOG_NOTICE,
-"      Displays power cap in <watt|btuphr>");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor setpowerbudget <val><watt|btuphr|percent>");
-	lprintf(LOG_NOTICE,
-"      Allows user to set the  power cap in <watt|BTU/hr|percentage>");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor enablepowercap ");
-	lprintf(LOG_NOTICE,
-"      To enable set power cap");
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   powermonitor disablepowercap ");
-	lprintf(LOG_NOTICE,
-"      To disable set power cap");
-	lprintf(LOG_NOTICE,
-"");
-}
-/*
- * Function Name:	   ipmi_delloem_vFlash_main
- *
- * Description:		   This function processes the delloem vFlash command
- * Input:			   intf    - ipmi interface
- *					   argc    - no of arguments
- *					   argv    - argument string array
- * Output:
- *
- * Return:			   return code	   0 - success
- *						  -1 - failure
- */
-static int
-ipmi_delloem_vFlash_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int rc = 0;
-	current_arg++;
-	rc = ipmi_delloem_vFlash_process(intf, current_arg, argv);
-	return rc;
-}
-/*
- * Function Name: 	get_vFlash_compcode_str
- *
- * Description: 	This function maps the vFlash completion code
- * 		to a string
- * Input : vFlash completion code and static array of codes vs strings
- * Output: -
- * Return: returns the mapped string
- */
-const char *
-get_vFlash_compcode_str(uint8_t vflashcompcode, const struct vFlashstr *vs)
-{
-	static char un_str[32];
-	int i;
-	for (i = 0; vs[i].str != NULL; i++) {
-		if (vs[i].val == vflashcompcode)
-			return vs[i].str;
-	}
-	memset(un_str, 0, 32);
-	snprintf(un_str, 32, "Unknown (0x%02X)", vflashcompcode);
-	return un_str;
-}
-/*
- * Function Name: 	ipmi_get_sd_card_info
- *
- * Description: This function prints the vFlash Extended SD card info
- * Input : ipmi interface
- * Output: prints the sd card extended info
- * Return: 0 - success -1 - failure
- */
-static int
-ipmi_get_sd_card_info(struct ipmi_intf * intf) {
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t msg_data[2];
-	uint8_t input_length=0;
-	uint8_t cardstatus=0x00;
-	IPMI_DELL_SDCARD_INFO * sdcardinfoblock;
-
-	input_length = 2;
-	msg_data[0] = msg_data[1] = 0x00;
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = IPMI_GET_EXT_SD_CARD_INFO;
-	req.msg.data = msg_data;
-	req.msg.data_len = input_length;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in getting SD Card Extended Information");
-		return -1;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Error in getting SD Card Extended Information (%s)",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-
-	sdcardinfoblock = (IPMI_DELL_SDCARD_INFO *) (void *) rsp->data;
-
-	if ((iDRAC_FLAG_12_13)
-			&& (sdcardinfoblock->vflashcompcode == VFL_NOT_LICENSED)) {
-		lprintf(LOG_ERR,
-				"FM001 : A required license is missing or expired");
-		return -1;
-	} else if (sdcardinfoblock->vflashcompcode != 0x00) {
-		lprintf(LOG_ERR, "Error in getting SD Card Extended Information (%s)",
-				get_vFlash_compcode_str(sdcardinfoblock->vflashcompcode,
-					vFlash_completion_code_vals));
-		return -1;
-	}
-
-	if (!(sdcardinfoblock->sdcardstatus & 0x04)) {
-		lprintf(LOG_ERR,
-				"vFlash SD card is unavailable, please insert the card of");
-		lprintf(LOG_ERR,
-				"size 256MB or greater");
-		return (-1);
-	}
-
-	printf("vFlash SD Card Properties\n");
-	printf("SD Card size       : %8dMB\n", sdcardinfoblock->sdcardsize);
-	printf("Available size     : %8dMB\n", sdcardinfoblock->sdcardavailsize);
-	printf("Initialized        : %10s\n",
-			(sdcardinfoblock->sdcardstatus & 0x80) ? "Yes" : "No");
-	printf("Licensed           : %10s\n",
-			(sdcardinfoblock->sdcardstatus & 0x40) ? "Yes" : "No");
-	printf("Attached           : %10s\n",
-			(sdcardinfoblock->sdcardstatus & 0x20) ? "Yes" : "No");
-	printf("Enabled            : %10s\n",
-			(sdcardinfoblock->sdcardstatus & 0x10) ? "Yes" : "No");
-	printf("Write Protected    : %10s\n",
-			(sdcardinfoblock->sdcardstatus & 0x08) ? "Yes" : "No");
-	cardstatus = sdcardinfoblock->sdcardstatus & 0x03;
-	printf("Health             : %10s\n",
-			((0x00 == cardstatus) ? "OK" : (
-				(cardstatus == 0x03) ? "Undefined" : (
-					(cardstatus == 0x02) ? "Critical" : "Warning"))));
-	printf("Bootable partition : %10d\n", sdcardinfoblock->bootpartion);
-	return 0;
-}
-/*
- * Function Name: 	ipmi_delloem_vFlash_process
- *
- * Description: 	This function processes the args for vFlash subcmd
- * Input : intf - ipmi interface, arg index, argv array
- * Output: prints help or error with help
- * Return: 0 - Success -1 - failure
- */
-static int
-ipmi_delloem_vFlash_process(struct ipmi_intf * intf, int current_arg, char ** argv)
-{
-	int rc;
-	if (strncmp(intf->name,"wmi\0",4) && strncmp(intf->name, "open\0",5)) {
-		lprintf(LOG_ERR,
-				"vFlash support is enabled only for wmi and open interface.");
-		lprintf(LOG_ERR, "Its not enabled for lan and lanplus interface.");
-		return -1;
-	}
-
-	if (argv[current_arg] == NULL || strcmp(argv[current_arg], "help") == 0) {
-		ipmi_vFlash_usage();
-		return 0;
-	}
-	ipmi_idracvalidator_command(intf);
-	if (!strncmp(argv[current_arg], "info\0", 5)) {
-		current_arg++;
-		if (argv[current_arg] == NULL) {
-			ipmi_vFlash_usage();
-			return -1;
-		} else if (strncmp(argv[current_arg], "Card\0", 5) == 0) {
-			current_arg++;
-			if (argv[current_arg] != NULL) {
-				ipmi_vFlash_usage();
-				return -1;
-			}
-			rc = ipmi_get_sd_card_info(intf);
-			return rc;
-		} else {
-			/* TBD: many sub commands are present */
-			ipmi_vFlash_usage();
-			return -1;
-		}
-	} else {
-		/* TBD other vFlash subcommands */
-		ipmi_vFlash_usage();
-		return -1;
-	}
-}
-/*
- * Function Name: 	ipmi_vFlash_usage
- *
- * Description: 	This function displays the usage for using vFlash
- * Input : void
- * Output: prints help
- * Return: void
- */
-static void
-ipmi_vFlash_usage(void)
-{
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   vFlash info Card");
-	lprintf(LOG_NOTICE,
-"      Shows Extended SD Card information");
-	lprintf(LOG_NOTICE,
-"");
-}
-/*
- * Function Name: ipmi_setled_usage
- *
- * Description:  This function prints help message for setled command
- * Input:
- * Output:
- *
- * Return:
- */
-static void
-ipmi_setled_usage(void)
-{
-	lprintf(LOG_NOTICE,
-"");
-	lprintf(LOG_NOTICE,
-"   setled <b:d.f> <state..>");
-	lprintf(LOG_NOTICE,
-"      Set backplane LED state");
-	lprintf(LOG_NOTICE,
-"      b:d.f = PCI Bus:Device.Function of drive (lspci format)");
-	lprintf(LOG_NOTICE,
-"      state = present|online|hotspare|identify|rebuilding|");
-	lprintf(LOG_NOTICE,
-"              fault|predict|critical|failed");
-	lprintf(LOG_NOTICE,
-"");
-}
-
-static int
-IsSetLEDSupported(void)
-{
-	return SetLEDSupported;
-}
-
-static void
-CheckSetLEDSupport(struct ipmi_intf * intf)
-{
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint8_t data[10];
-
-	SetLEDSupported = 0;
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = 0xD5; /* Storage */
-	req.msg.data_len = 10;
-	req.msg.data = data;
-
-	memset(data, 0, sizeof(data));
-	data[0] = 0x01; /* get */
-	data[1] = 0x00; /* subcmd:get firmware version */
-	data[2] = 0x08; /* length lsb */
-	data[3] = 0x00; /* length msb */
-	data[4] = 0x00; /* offset lsb */
-	data[5] = 0x00; /* offset msb */
-	data[6] = 0x00; /* bay id */
-	data[7] = 0x00;
-	data[8] = 0x00;
-	data[9] = 0x00;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL || rsp->ccode != 0) {
-		return;
-	}
-	SetLEDSupported = 1;
-}
-/*
- * Function Name:    ipmi_getdrivemap
- *
- * Description:      This function returns mapping of BDF to Bay:Slot
- * Input:            intf         - ipmi interface
- *		    bdf	 	 - PCI Address of drive
- *		    *bay	 - Returns bay ID
- *		    *slot	 - Returns slot ID
- * Output:
- *
- * Return:
- */
-static int
-ipmi_getdrivemap(struct ipmi_intf * intf, int b, int d, int f, int *bay,
-		int *slot)
-{
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint8_t data[8];
-	/* Get mapping of BDF to bay:slot */
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = 0xD5;
-	req.msg.data_len = 8;
-	req.msg.data = data;
-
-	memset(data, 0, sizeof(data));
-	data[0] = 0x01; /* get */
-	data[1] = 0x07; /* storage map */
-	data[2] = 0x06; /* length lsb */
-	data[3] = 0x00; /* length msb */
-	data[4] = 0x00; /* offset lsb */
-	data[5] = 0x00; /* offset msb */
-	data[6] = b; /* bus */
-	data[7] = (d << 3) + f; /* devfn */
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error issuing getdrivemap command.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Error issuing getdrivemap command: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	*bay = rsp->data[7];
-	*slot = rsp->data[8];
-	if (*bay == 0xFF || *slot == 0xFF) {
-		lprintf(LOG_ERR, "Error could not get drive bay:slot mapping");
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_setled_state
- *
- * Description:      This function updates the LED on the backplane
- * Input:            intf         - ipmi interface
- *		    bdf	 	 - PCI Address of drive
- *		    state	 - SES Flags state of drive
- * Output:
- *
- * Return:
- */
-static int
-ipmi_setled_state(struct ipmi_intf * intf, int bayId, int slotId, int state)
-{
-	struct ipmi_rs * rsp = NULL;
-	struct ipmi_rq req = {0};
-	uint8_t data[20];
-	/* Issue Drive Status Update to bay:slot */
-	req.msg.netfn = DELL_OEM_NETFN;
-	req.msg.lun = 0;
-	req.msg.cmd = 0xD5;
-	req.msg.data_len = 20;
-	req.msg.data = data;
-
-	memset(data, 0, sizeof(data));
-	data[0] = 0x00; /* set */
-	data[1] = 0x04; /* set drive status */
-	data[2] = 0x0e; /* length lsb */
-	data[3] = 0x00; /* length msb */
-	data[4] = 0x00; /* offset lsb */
-	data[5] = 0x00; /* offset msb */
-	data[6] = 0x0e; /* length lsb */
-	data[7] = 0x00; /* length msb */
-	data[8] = bayId; /* bayid */
-	data[9] = slotId; /* slotid */
-	data[10] = state & 0xff; /* state LSB */
-	data[11] = state >> 8; /* state MSB; */
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error issuing setled command.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Error issuing setled command: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	}
-	return 0;
-}
-/*
- * Function Name:    ipmi_getsesmask
- *
- * Description:      This function calculates bits in SES drive update
- * Return:           Mask set with bits for SES backplane update
- */
-static int
-ipmi_getsesmask(int argc, char **argv)
-{
-	int mask = 0;
-	while (current_arg < argc) {
-		if (!strcmp(argv[current_arg], "present"))
-			mask |= (1L << 0);
-		if (!strcmp(argv[current_arg], "online"))
-			mask |= (1L << 1);
-		if (!strcmp(argv[current_arg], "hotspare"))
-			mask |= (1L << 2);
-		if (!strcmp(argv[current_arg], "identify"))
-			mask |= (1L << 3);
-		if (!strcmp(argv[current_arg], "rebuilding"))
-			mask |= (1L << 4);
-		if (!strcmp(argv[current_arg], "fault"))
-			mask |= (1L << 5);
-		if (!strcmp(argv[current_arg], "predict"))
-			mask |= (1L << 6);
-		if (!strcmp(argv[current_arg], "critical"))
-			mask |= (1L << 9);
-		if (!strcmp(argv[current_arg], "failed"))
-			mask |= (1L << 10);
-		current_arg++;
-	}
-	return mask;
-}
-/*
- * Function Name:       ipmi_delloem_setled_main
- *
- * Description:         This function processes the delloem setled command
- * Input:               intf    - ipmi interface
- *                       argc    - no of arguments
- *                       argv    - argument string array
- * Output:
- *
- * Return:              return code     0 - success
- *                         -1 - failure
- */
-static int
-ipmi_delloem_setled_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int b,d,f, mask;
-	int bayId, slotId;
-	bayId = 0xFF;
-	slotId = 0xFF;
-	current_arg++;
-	if (argc < current_arg) {
-		usage();
-		return -1;
-	}
-	/* ipmitool delloem setled info*/
-	if (argc == 1 || strcmp(argv[current_arg], "help") == 0) {
-		ipmi_setled_usage();
-		return 0;
-	}
-	CheckSetLEDSupport(intf);
-	if (!IsSetLEDSupported()) {
-		lprintf(LOG_ERR, "'setled' is not supported on this system.");
-		return -1;
-	} else if (sscanf(argv[current_arg], "%*x:%x:%x.%x", &b,&d,&f) == 3) {
-		/* We have bus/dev/function of drive */
-		current_arg++;
-		ipmi_getdrivemap (intf, b, d, f, &bayId, &slotId);
-	} else if (sscanf(argv[current_arg], "%x:%x.%x", &b,&d,&f) == 3) {
-		/* We have bus/dev/function of drive */
-		current_arg++;
-	} else {
-		ipmi_setled_usage();
-		return -1;
-	}
-	/* Get mask of SES flags */
-	mask = ipmi_getsesmask(argc, argv);
-	/* Get drive mapping */
-	if (ipmi_getdrivemap (intf, b, d, f, &bayId, &slotId)) {
-		return -1;
-	}
-	/* Set drive LEDs */
-	return ipmi_setled_state (intf, bayId, slotId, mask);
-}
diff --git a/lib/ipmi_ekanalyzer.c b/lib/ipmi_ekanalyzer.c
deleted file mode 100644
index afee48b..0000000
--- a/lib/ipmi_ekanalyzer.c
+++ /dev/null
@@ -1,4182 +0,0 @@
-/*
- * Copyright (c) 2007 Kontron Canada, Inc.  All Rights Reserved.
- *
- * Base on code from
- * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include <ipmitool/ipmi_ekanalyzer.h>
-#include <ipmitool/log.h>
-#include <ipmitool/helper.h>
-#include <ipmitool/ipmi_strings.h>
-
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-
-#define NO_MORE_INFO_FIELD         0xc1
-#define TYPE_CODE 0xc0 /*Language code*/
-
-/*
- * CONSTANT
- */
-const int ERROR_STATUS  = -1;
-const int OK_STATUS     = 0;
-
-const char * STAR_LINE_LIMITER =
-            "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*";
-const char * EQUAL_LINE_LIMITER =
-            "=================================================================";
-const int SIZE_OF_FILE_TYPE          = 3;
-const unsigned char AMC_MODULE       = 0x80;
-const int PICMG_ID_OFFSET            = 3;
-const unsigned int COMPARE_CANDIDATE = 2;
-/* In AMC.0 or PICMG 3.0 specification offset start from 0 with 3 bytes of
- * Mfg.ID, 1 byte of Picmg record Id, and
- * 1 byte of format version, so the data offset start from 5
- */
-const int START_DATA_OFFSET         = 5;
-const int LOWER_OEM_TYPE            = 0xf0;
-const int UPPER_OEM_TYPE            = 0xfe;
-const unsigned char DISABLE_PORT    = 0x1f;
-
-const struct valstr ipmi_ekanalyzer_module_type[] = {
-   { ON_CARRIER_FRU_FILE,     "On-Carrier Device" },
-   { A1_AMC_FRU_FILE,         "AMC slot A1" },
-   { A2_AMC_FRU_FILE,         "AMC slot A2" },
-   { A3_AMC_FRU_FILE,         "AMC slot A3" },
-   { A4_AMC_FRU_FILE,         "AMC slot A4" },
-   { B1_AMC_FRU_FILE,         "AMC slot B1" },
-   { B2_AMC_FRU_FILE,         "AMC slot B2" },
-   { B3_AMC_FRU_FILE,         "AMC slot B3" },
-   { B4_AMC_FRU_FILE,         "AMC slot B4" },
-   { RTM_FRU_FILE,            "RTM" }, /*This is OEM specific module*/
-   { CONFIG_FILE,             "Configuration file" },
-   { SHELF_MANAGER_FRU_FILE,  "Shelf Manager" },
-   { 0xffff ,                 NULL },
-};
-
-const struct valstr ipmi_ekanalyzer_IPMBL_addr[] = {
-   { 0x72,         "AMC slot A1" },
-   { 0x74,         "AMC slot A2" },
-   { 0x76,         "AMC slot A3" },
-   { 0x78,         "AMC slot A4" },
-   { 0x7a,         "AMC slot B1" },
-   { 0x7c,         "AMC slot B2" },
-   { 0x7e,         "AMC slot B3" },
-   { 0x80,         "AMC slot B4" },
-   { 0x90,         "RTM"}, /*This is OEM specific module*/
-   { 0xffff ,      NULL },
-};
-
-const struct valstr ipmi_ekanalyzer_link_type[] = {
-   { 0x00,         "Reserved" },
-   { 0x01,         "Reserved" },
-   { 0x02,         "AMC.1 PCI Express" },
-   { 0x03,         "AMC.1 PCI Express Advanced Switching" },
-   { 0x04,         "AMC.1 PCI Express Advanced Switching" },
-   { 0x05,         "AMC.2 Ethernet" },
-   { 0x06,         "AMC.4 Serial RapidIO" },
-   { 0x07,         "AMC.3 Storage" },
-   /*This is OEM specific module*/
-   { 0xf0,         "OEM Type 0"},
-   { 0xf1,         "OEM Type 1"},
-   { 0xf2,         "OEM Type 2"},
-   { 0xf3,         "OEM Type 3"},
-   { 0xf4,         "OEM Type 4"},
-   { 0xf5,         "OEM Type 5"},
-   { 0xf6,         "OEM Type 6"},
-   { 0xf7,         "OEM Type 7"},
-   { 0xf8,         "OEM Type 8"},
-   { 0xf9,         "OEM Type 9"},
-   { 0xfa,         "OEM Type 10"},
-   { 0xfb,         "OEM Type 11"},
-   { 0xfc,         "OEM Type 12"},
-   { 0xfd,         "OEM Type 13"},
-   { 0xfe,         "OEM Type 14"},
-   { 0xff ,        "Reserved" },
-};
-
-/*Reference: AMC.1 specification*/
-const struct valstr ipmi_ekanalyzer_extension_PCIE[] = {
-   { 0x00,         "Gen 1 capable - non SSC" },
-   { 0x01,         "Gen 1 capable - SSC" },
-   { 0x02,         "Gen 2 capable - non SSC" },
-   { 0x03,         "Gen 3 capable - SSC" },
-   { 0x0f,         "Reserved"},
-};
-/*Reference: AMC.2 specification*/
-const struct valstr ipmi_ekanalyzer_extension_ETHERNET[] = {
-   { 0x00,         "1000BASE-BX (SerDES Gigabit) Ethernet link" },
-   { 0x01,         "10GBASE-BX4 10 Gigabit Ethernet link" },
-};
-/*Reference: AMC.3 specification*/
-const struct valstr ipmi_ekanalyzer_extension_STORAGE[] = {
-   { 0x00,         "Fibre Channel  (FC)" },
-   { 0x01,         "Serial ATA (SATA)" },
-   { 0x02,         "Serial Attached SCSI (SAS/SATA)" },
-};
-
-const struct valstr ipmi_ekanalyzer_asym_PCIE[] = {
-   { 0x00,         "exact match"},
-   { 0x01,         "provides a Primary PCI Express Port" },
-   { 0x02,         "provides a Secondary PCI Express Port" },
-};
-
-const struct valstr ipmi_ekanalyzer_asym_STORAGE[] = {
-   { 0x00,         "FC or SAS interface {exact match}" },
-   { 0x01,         "SATA Server interface" },
-   { 0x02,         "SATA Client interface" },
-   { 0x03,         "Reserved" },
-};
-
-const struct valstr ipmi_ekanalyzer_picmg_record_id[] = {
-   { 0x04,         "Backplane Point to Point Connectivity Record" },
-   { 0x10,         "Address Table Record" },
-   { 0x11,         "Shelf Power Distribution Record" },
-   { 0x12,         "Shelf Activation and Power Management Record" },
-   { 0x13,         "Shelf Manager IP Connection Record" },
-   { 0x14,         "Board Point to Point Connectivity Record" },
-   { 0x15,         "Radial IPMB-0 Link Mapping Record" },
-   { 0x16,         "Module Current Requirements Record" },
-   { 0x17,         "Carrier Activation and Power Management Record" },
-   { 0x18,         "Carrier Point-to-Point Connectivity Record" },
-   { 0x19,         "AdvancedMC Point-to-Point Connectivity Record" },
-   { 0x1a,         "Carrier Information Table" },
-   { 0x1b,         "Shelf Fan Geography Record" },
-   { 0x2c,         "Carrier Clock Point-to-Point Connectivity Record" },
-   { 0x2d,         "Clock Configuration Record" },
-};
-
-extern int verbose;
-
-struct ipmi_ek_multi_header {
-   struct fru_multirec_header header;
-   unsigned char * data;
-   struct ipmi_ek_multi_header * prev;
-   struct ipmi_ek_multi_header * next;
-};
-
-struct ipmi_ek_amc_p2p_connectivity_record{
-   unsigned char guid_count;
-   struct fru_picmgext_guid * oem_guid;
-   unsigned char rsc_id;
-   unsigned char ch_count;
-   struct fru_picmgext_amc_channel_desc_record * ch_desc;
-   unsigned char link_desc_count;
-   struct fru_picmgext_amc_link_desc_record * link_desc;
-   int * matching_result; /*For link descriptor comparision*/
-};
-
-/*****************************************************************************
-* Function prototype
-******************************************************************************/
-/****************************************************************************
-* command Functions
-*****************************************************************************/
-static int ipmi_ekanalyzer_print( int argc, char * opt,
-                        char ** filename, int * file_type );
-
-static tboolean ipmi_ekanalyzer_ekeying_match( int argc, char * opt,
-                        char ** filename, int * file_type );
-
-/****************************************************************************
-* Linked list Functions
-*****************************************************************************/
-static void ipmi_ek_add_record2list( struct ipmi_ek_multi_header ** record,
-      struct ipmi_ek_multi_header ** list_head,
-      struct ipmi_ek_multi_header ** list_last );
-
-static void ipmi_ek_display_record( struct ipmi_ek_multi_header * record,
-      struct ipmi_ek_multi_header * list_head,
-      struct ipmi_ek_multi_header * list_last );
-
-static void ipmi_ek_remove_record_from_list(
-      struct ipmi_ek_multi_header * record,
-      struct ipmi_ek_multi_header ** list_head,
-      struct ipmi_ek_multi_header ** list_last );
-
-static int ipmi_ekanalyzer_fru_file2structure( char * filename,
-      struct ipmi_ek_multi_header ** list_head,
-      struct ipmi_ek_multi_header ** list_record,
-      struct ipmi_ek_multi_header ** list_last );
-
-/****************************************************************************
-* Ekeying match Functions
-*****************************************************************************/
-static int ipmi_ek_matching_process( int * file_type, int index1, int index2,
-      struct ipmi_ek_multi_header ** list_head,
-      struct ipmi_ek_multi_header ** list_last, char * opt,
-      struct ipmi_ek_multi_header * pphysical );
-
-static int ipmi_ek_get_resource_descriptor( int port_count, int index,
-      struct fru_picmgext_carrier_p2p_descriptor * port_desc,
-      struct ipmi_ek_multi_header * record );
-
-static int ipmi_ek_create_amc_p2p_record( struct ipmi_ek_multi_header * record,
-      struct ipmi_ek_amc_p2p_connectivity_record * amc_record );
-
-static int ipmi_ek_compare_link( struct ipmi_ek_multi_header * physic_record,
-      struct ipmi_ek_amc_p2p_connectivity_record record1,
-      struct ipmi_ek_amc_p2p_connectivity_record record2,
-      char * opt, int file_type1, int file_type2 );
-
-static tboolean ipmi_ek_compare_channel_descriptor(
-      struct fru_picmgext_amc_channel_desc_record ch_desc1,
-      struct fru_picmgext_amc_channel_desc_record ch_desc2,
-      struct fru_picmgext_carrier_p2p_descriptor * port_desc,
-      int index_port, unsigned char rsc_id );
-
-static int ipmi_ek_compare_link_descriptor(
-      struct ipmi_ek_amc_p2p_connectivity_record record1, int index1,
-      struct ipmi_ek_amc_p2p_connectivity_record record2, int index2 );
-
-static int ipmi_ek_compare_asym( unsigned char asym[COMPARE_CANDIDATE] );
-
-static int ipmi_ek_compare_number_of_enable_port(
-      struct fru_picmgext_amc_link_desc_record link_desc[COMPARE_CANDIDATE] );
-
-static int ipmi_ek_check_physical_connectivity(
-      struct ipmi_ek_amc_p2p_connectivity_record record1, int index1,
-      struct ipmi_ek_amc_p2p_connectivity_record record2, int index2,
-      struct ipmi_ek_multi_header * record,
-      int filetype1, int filetype2, char * option );
-
-/****************************************************************************
-* Display Functions
-*****************************************************************************/
-static int ipmi_ek_display_fru_header( char * filename );
-
-static int ipmi_ek_display_fru_header_detail(char * filename);
-
-static int ipmi_ek_display_chassis_info_area(FILE * input_file, long offset);
-
-static size_t ipmi_ek_display_board_info_area( FILE * input_file,
-      char * board_type, unsigned int * board_length );
-
-static int ipmi_ek_display_product_info_area(FILE * input_file, long offset);
-
-static tboolean ipmi_ek_display_link_descriptor( int file_type,
-      unsigned char rsc_id, char * str,
-      struct fru_picmgext_amc_link_desc_record link_desc );
-
-static void ipmi_ek_display_oem_guid(
-      struct ipmi_ek_amc_p2p_connectivity_record amc_record1 );
-
-static int ipmi_ek_display_carrier_connectivity(
-      struct ipmi_ek_multi_header * record );
-
-static int ipmi_ek_display_power( int argc, char * opt,
-      char ** filename, int * file_type );
-
-static void ipmi_ek_display_current_descriptor(
-      struct fru_picmgext_carrier_activation_record car,
-      struct fru_picmgext_activation_record * cur_desc, char * filename );
-
-static void ipmi_ek_display_backplane_p2p_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_address_table_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_shelf_power_distribution_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_shelf_activation_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_shelf_ip_connection_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_shelf_fan_geography_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_board_p2p_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_radial_ipmb0_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_amc_current_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_amc_activation_record (
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_amc_p2p_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_amc_carrier_info_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_clock_carrier_p2p_record(
-      struct ipmi_ek_multi_header * record );
-
-static void ipmi_ek_display_clock_config_record(
-      struct ipmi_ek_multi_header * record );
-
-/**************************************************************************
-*
-* Function name: ipmi_ekanalyzer_usage
-*
-* Description  : Print the usage (help menu) of ekeying analyzer tool
-*
-* Restriction  : None
-*
-* Input        : None
-*
-* Output       : None
-*
-* Global       : None
-*
-* Return       :   None
-*
-***************************************************************************/
-static void
-ipmi_ekanalyzer_usage(void)
-{
-	lprintf(LOG_NOTICE,
-"Ekeying analyzer tool version 1.00");
-	lprintf(LOG_NOTICE,
-"ekanalyzer Commands:");
-	lprintf(LOG_NOTICE,
-"      print    [carrier | power | all] <oc=filename1> <b1=filename2>...");
-	lprintf(LOG_NOTICE,
-"      frushow  <b2=filename>");
-	lprintf(LOG_NOTICE,
-"      summary  [match | unmatch | all] <oc=filename1> <b1=filename2>...");
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_get_file_type
-*
-* Description: this function takes an argument, then xtract the file type and
-*              convert into module type (on carrier, AMC,...) value.
-*
-*
-* Restriction: None
-*
-* Input:       argument: strings contain the type and the name of the file
-*                        together
-*
-* Output:      None
-*
-* Global:      None
-*
-* Return:      Return value of module type: On carrier FRU file, A1 FRUM file...
-*           if the file type is invalid, it return -1. See structure
-*           ipmi_ekanalyzer_module_type for a list of valid type.
-***************************************************************************/
-static int
-ipmi_ek_get_file_type(char *argument)
-{
-	int filetype = ERROR_STATUS;
-	if (strlen(argument) <= MIN_ARGUMENT) {
-		return filetype;
-	}
-	if (strncmp(argument, "oc=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = ON_CARRIER_FRU_FILE;
-	} else if (strncmp(argument, "a1=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = A1_AMC_FRU_FILE;
-	} else if (strncmp(argument, "a2=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = A2_AMC_FRU_FILE;
-	} else if (strncmp(argument, "a3=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = A3_AMC_FRU_FILE;
-	} else if (strncmp(argument, "a4=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = A4_AMC_FRU_FILE;
-	} else if (strncmp(argument, "b1=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = B1_AMC_FRU_FILE;
-	} else if (strncmp(argument, "b2=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = B2_AMC_FRU_FILE;
-	} else if (strncmp(argument, "b3=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = B3_AMC_FRU_FILE;
-	} else if (strncmp(argument, "b4=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = B4_AMC_FRU_FILE;
-	} else if (strncmp(argument, "rt=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = RTM_FRU_FILE;
-	} else if (strncmp(argument, "rc=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = CONFIG_FILE;
-	} else if (strncmp(argument, "sm=", SIZE_OF_FILE_TYPE) == 0) {
-		filetype = SHELF_MANAGER_FRU_FILE;
-	} else {
-		filetype = ERROR_STATUS;
-	}
-	return filetype;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ekanalyzer_main
-*
-* Description: Main program of ekeying analyzer. It calls the appropriate
-*           function according to the command received.
-*
-* Restriction: None
-*
-* Input: ipmi_intf * intf: ?
-*        int argc : number of argument received
-*        int ** argv: argument strings
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   OK_STATUS as succes or ERROR_STATUS as error
-*
-***************************************************************************/
-int
-ipmi_ekanalyzer_main(struct ipmi_intf *intf, int argc, char **argv)
-{
-	int rc = ERROR_STATUS;
-	int file_type[MAX_FILE_NUMBER];
-	int tmp_ret = 0;
-	char *filename[MAX_FILE_NUMBER];
-	unsigned int argument_offset = 0;
-	unsigned int type_offset = 0;
-	/* list des multi record */
-	struct ipmi_ek_multi_header *list_head = NULL;
-	struct ipmi_ek_multi_header *list_record = NULL;
-	struct ipmi_ek_multi_header *list_last = NULL;
-
-	if (argc == 0) {
-		lprintf(LOG_ERR, "Not enough parameters given.");
-		ipmi_ekanalyzer_usage();
-		return (-1);
-	} else if ((argc - 1) > MAX_FILE_NUMBER) {
-		lprintf(LOG_ERR, "Too too many parameters given.");
-		return (-1);
-	}
-
-	if (strcmp(argv[argument_offset], "help") == 0) {
-		ipmi_ekanalyzer_usage();
-		return 0;
-	} else if ((strcmp(argv[argument_offset], "frushow") == 0)
-			&& (argc > (MIN_ARGUMENT-1))) {
-		for (type_offset = 0; type_offset < (argc-1); type_offset++ ) {
-			argument_offset++;
-			file_type[type_offset] = ipmi_ek_get_file_type(argv[argument_offset]);
-			if (file_type[type_offset] == ERROR_STATUS
-					|| file_type[type_offset] == CONFIG_FILE) {
-				lprintf(LOG_ERR, "Invalid file type!");
-				lprintf(LOG_ERR, "   ekanalyzer frushow <xx=frufile> ...");
-				return (-1);
-			}
-			/* because of strlen doesn't count '\0',
-			 * we need to add 1 byte for this character
-			 * to filename size
-			 */
-			filename[type_offset] = malloc(strlen(argv[argument_offset])
-					+ 1 - SIZE_OF_FILE_TYPE);
-			if (filename[type_offset] == NULL) {
-				lprintf(LOG_ERR, "malloc failure");
-				return (-1);
-			}
-			strcpy(filename[type_offset],
-					&argv[argument_offset][SIZE_OF_FILE_TYPE]);
-			printf("Start converting file '%s'...\n",
-					filename[type_offset]);
-			/* Display FRU header offset */
-			rc = ipmi_ek_display_fru_header (filename[type_offset]);
-			if (rc != ERROR_STATUS) {
-				/* Display FRU header info in detail record */
-				tmp_ret = ipmi_ek_display_fru_header_detail(filename[type_offset]);
-				/* Convert from binary data into multi record structure */
-				rc = ipmi_ekanalyzer_fru_file2structure (filename[type_offset],
-						&list_head, &list_record, &list_last );
-				ipmi_ek_display_record(list_record, list_head, list_last);
-				/* Remove record of list */
-				while (list_head != NULL) {
-					ipmi_ek_remove_record_from_list(list_head,
-							&list_head,&list_last );
-					if (verbose > 1) {
-						printf("record has been removed!\n");
-					}
-				}
-			}
-			free(filename[type_offset]);
-			filename[type_offset] = NULL;
-		}
-	} else if ((strcmp(argv[argument_offset], "print") == 0)
-			|| (strcmp(argv[argument_offset], "summary") == 0)) {
-		/* Display help text for corresponding command
-		 * if not enough parameters were given.
-		 */
-		char * option;
-		/* index=1 indicates start position of first file
-		 * name in command line
-		 */
-		int index = 1;
-		int filename_size=0;
-		if (argc < MIN_ARGUMENT) {
-			lprintf(LOG_ERR, "Not enough parameters given.");
-			if (strcmp(argv[argument_offset], "print") == 0) {
-				lprintf(LOG_ERR,
-						"   ekanalyzer print [carrier/power/all]"
-						" <xx=frufile> <xx=frufile> [xx=frufile]");
-			} else {
-				lprintf(LOG_ERR,
-						"   ekanalyzer summary [match/ unmatch/ all]"
-						" <xx=frufile> <xx=frufile> [xx=frufile]");
-			}
-			return ERROR_STATUS;
-		}
-		argument_offset++;
-		if ((strcmp(argv[argument_offset], "carrier") == 0)
-				|| (strcmp(argv[argument_offset], "power") == 0)
-				|| (strcmp(argv[argument_offset], "all") == 0)) {
-			option = argv[argument_offset];
-			index ++;
-			argc--;
-		} else if ((strcmp(argv[argument_offset], "match") == 0)
-				|| ( strcmp(argv[argument_offset], "unmatch") == 0)) {
-			option = argv[argument_offset];
-			index ++;
-			argc--;
-		} else if ( strncmp(&argv[argument_offset][2], "=", 1) == 0) {
-			/* since the command line must receive xx=filename,
-			 * so the position of "=" sign is 2
-			 */
-			option = "default";
-			/* Since there is no option from user, the first argument
-			 * becomes first file type
-			 */
-			index = 1; /* index of argument */
-		} else {
-			option = "invalid";
-			printf("Invalid option '%s'\n", argv[argument_offset]);
-			argument_offset--;
-			if (strcmp(argv[0], "print") == 0) {
-				lprintf (LOG_ERR,
-						"   ekanalyzer print [carrier/power/all]"
-						" <xx=frufile> <xx=frufile> [xx=frufile]");
-			} else {
-				lprintf (LOG_ERR,
-						"   ekanalyzer summary [match/ unmatch/ all]"
-						" <xx=frufile> <xx=frufile> [xx=frufile]");
-			}
-			rc = ERROR_STATUS;
-		}
-		if (strcmp(option, "invalid") != 0) {
-			int i=0;
-			for (i = 0; i < (argc-1); i++) {
-				file_type[i] = ipmi_ek_get_file_type (argv[index]);
-				if (file_type[i] == ERROR_STATUS) {
-					/* display the first 2 charactors (file type) of argument */
-					lprintf(LOG_ERR, "Invalid file type: %c%c\n",
-							argv[index][0],
-							argv[index][1]);
-					ipmi_ekanalyzer_usage();
-					rc = ERROR_STATUS;
-					break;
-				}
-				/* size is equal to string size minus 3 bytes of file type plus
-				 * 1 byte of '\0' since the strlen doesn't count the '\0'
-				 */
-				filename_size = strlen(argv[index]) - SIZE_OF_FILE_TYPE + 1;
-				if (filename_size > 0) {
-					/* TODO - check malloc() retval */
-					filename[i] = malloc( filename_size );
-					if (filename[i] != NULL) {
-						strcpy(filename[i], &argv[index][SIZE_OF_FILE_TYPE]);
-					}
-				}
-				rc = OK_STATUS;
-				index++;
-			}
-			if (rc != ERROR_STATUS) {
-				if (verbose > 0) {
-					for (i = 0; i < (argc-1); i++) {
-						printf ("Type: %s,   ",
-								val2str(file_type[i],
-									ipmi_ekanalyzer_module_type));
-						printf("file name: %s\n", filename[i]);
-					}
-				}
-				if (strcmp(argv[0], "print") == 0) {
-					rc = ipmi_ekanalyzer_print((argc-1),
-							option, filename, file_type);
-				} else {
-					rc = ipmi_ekanalyzer_ekeying_match((argc-1),
-							option, filename, file_type);
-				}
-				for (i = 0; i < (argc-1); i++) {
-					if (filename[i] != NULL) {
-						free(filename[i]);
-						filename[i] = NULL;
-					}
-				}
-			} /* End of ERROR_STATUS */
-		} /* End of comparison of invalid option */
-	} else {
-		lprintf(LOG_ERR, "Invalid ekanalyzer command: %s", argv[0]);
-		ipmi_ekanalyzer_usage();
-		rc = ERROR_STATUS;
-	}
-	return rc;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ekanalyzer_print
-*
-* Description: this function will display the topology, power or both
-*            information together according to the option that it received.
-*
-* Restriction: None
-*
-* Input: int argc: number of the argument received
-*       char* opt: option string that will tell what to display
-*       char** filename: strings that contained filename of FRU data binary file
-*       int* file_type: a pointer that contain file type (on carrier file,
-*                       a1 file, b1 file...). See structure
-*                       ipmi_ekanalyzer_module_type for a list of valid type
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return 0 as success and -1 as error.
-*
-***************************************************************************/
-static int
-ipmi_ekanalyzer_print(int argc, char *opt, char **filename, int *file_type)
-{
-	int return_value = OK_STATUS;
-	/* Display carrier topology */
-	if ((strcmp(opt, "carrier") == 0) || (strcmp(opt, "default") == 0)) {
-		tboolean found_flag = FALSE;
-		int index = 0;
-		int index_name[argc];
-		int list = 0;
-		/* list of multi record */
-		struct ipmi_ek_multi_header *list_head[argc];
-		struct ipmi_ek_multi_header *list_record[argc];
-		struct ipmi_ek_multi_header *list_last[argc];
-
-		for (list=0; list < argc; list++) {
-			list_head[list] = NULL;
-			list_record[list] = NULL;
-			list_last[list] = NULL;
-		}
-		/* reset list count */
-		list = 0;
-		for (index = 0; index < argc; index++) {
-			if (file_type[index] != ON_CARRIER_FRU_FILE) {
-				continue;
-			}
-			index_name[list] = index;
-			return_value = ipmi_ekanalyzer_fru_file2structure(filename[index],
-					&list_head[list],
-					&list_record[list],
-					&list_last[list]);
-			list++;
-			found_flag = TRUE;
-		}
-		if (!found_flag) {
-			printf("No carrier file has been found\n");
-			return_value = ERROR_STATUS;
-		} else {
-			int i = 0;
-			for (i = 0; i < argc; i++) {
-				/* this is a flag to advoid displaying
-				 * the same data multiple time
-				 */
-				tboolean first_data = TRUE;
-				for (list_record[i] = list_head[i];
-						list_record[i] != NULL;
-						list_record[i] = list_record[i]->next) {
-					if (list_record[i]->data[PICMG_ID_OFFSET] == FRU_AMC_CARRIER_P2P) {
-						if (first_data) {
-							printf("%s\n", STAR_LINE_LIMITER);
-							printf("From Carrier file: %s\n", filename[index_name[i]]);
-							first_data = FALSE;
-						}
-						return_value = ipmi_ek_display_carrier_connectivity(list_record[i]);
-					} else if (list_record[i]->data[PICMG_ID_OFFSET] == FRU_AMC_CARRIER_INFO) {
-						/*See AMC.0 specification Table3-3 for mor detail*/
-						#define COUNT_OFFSET 6
-						if (first_data) {
-							printf("From Carrier file: %s\n", filename[index_name[i]]);
-							first_data = FALSE;
-						}
-						printf("   Number of AMC bays supported by Carrier: %d\n",
-								list_record[i]->data[COUNT_OFFSET]);
-					}
-				}
-			}
-			/*Destroy the list of record*/
-			for (i = 0; i < argc; i++) {
-				while (list_head[i] != NULL) {
-					ipmi_ek_remove_record_from_list(list_head[i],
-							&list_head[i], &list_last[i]);
-				}
-				/* display deleted result when we
-				 * reach the last record
-				 */
-				if ((i == (list-1)) && verbose) {
-					printf("Record list has been removed successfully\n");
-				}
-			}
-		}
-	} else if (strcmp(opt, "power") == 0) {
-		printf("Print power information\n");
-		return_value = ipmi_ek_display_power(argc, opt, filename, file_type);
-	} else if (strcmp(opt, "all") == 0) {
-		printf("Print all information\n");
-		return_value = ipmi_ek_display_power(argc, opt, filename, file_type);
-	} else {
-		lprintf(LOG_ERR, "Invalid option %s", opt);
-		return_value = ERROR_STATUS;
-	}
-	return return_value;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_carrier_connectivity
-*
-* Description: Display the topology between a Carrier and all AMC modules by
-*           using carrier p2p connectivity record
-*
-* Restriction: Ref: AMC.0 Specification: Table 3-13 and Table 3-14
-*
-* Input: struct ipmi_ek_multi_header* record: a pointer to the carrier p2p
-*                              connectivity record.
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return 0 on success and -1 if the record doesn't exist.
-*
-***************************************************************************/
-static int
-ipmi_ek_display_carrier_connectivity(struct ipmi_ek_multi_header *record)
-{
-	int offset = START_DATA_OFFSET;
-	struct fru_picmgext_carrier_p2p_record rsc_desc;
-	struct fru_picmgext_carrier_p2p_descriptor *port_desc;
-	if (record == NULL) {
-		lprintf(LOG_ERR, "P2P connectivity record is invalid\n");
-		return ERROR_STATUS;
-	}
-	if (verbose > 1) {
-		int k = 0;
-		printf("Binary data of Carrier p2p connectivity"\
-				" record starting from mfg id\n");
-		for (k = 0; k < (record->header.len); k++) {
-			printf("%02x   ", record->data[k]);
-		}
-		printf("\n");
-	}
-	while (offset <= (record->header.len - START_DATA_OFFSET)) {
-		rsc_desc.resource_id = record->data[offset++];
-		rsc_desc.p2p_count = record->data[offset++];
-		if (verbose > 0) {
-			printf("resource id= %02x  port count= %d\n",
-					rsc_desc.resource_id, rsc_desc.p2p_count);
-		}
-		/* check if it is an AMC Module */
-		if ((rsc_desc.resource_id & AMC_MODULE) == AMC_MODULE) {
-			/* check if it is an RTM module */
-			if (rsc_desc.resource_id == AMC_MODULE) {
-				printf("   %s topology:\n",
-						val2str(RTM_IPMB_L,
-							ipmi_ekanalyzer_IPMBL_addr));
-			} else {
-				/* The last four bits of resource ID
-				 * represent site number (mask = 0x0f)
-				 */
-				printf("   %s topology:\n",
-						val2str((rsc_desc.resource_id & 0x0f),
-							ipmi_ekanalyzer_module_type));
-			}
-		} else {
-			printf("   On Carrier Device ID %d topology: \n",
-					(rsc_desc.resource_id & 0x0f));
-		}
-		while (rsc_desc.p2p_count > 0) {
-			unsigned char data[3];
-# ifndef WORDS_BIGENDIAN
-			data[0] = record->data[offset + 0];
-			data[1] = record->data[offset + 1];
-			data[2] = record->data[offset + 2];
-# else
-			data[0] = record->data[offset + 2];
-			data[1] = record->data[offset + 1];
-			data[2] = record->data[offset + 0];
-# endif
-			port_desc = (struct fru_picmgext_carrier_p2p_descriptor*)data;
-			offset += sizeof(struct fru_picmgext_carrier_p2p_descriptor);
-			if ((port_desc->remote_resource_id & AMC_MODULE) == AMC_MODULE) {
-				printf("\tPort %d =====> %s, Port %d\n",
-						port_desc->local_port,
-						val2str((port_desc->remote_resource_id & 0x0f),
-							ipmi_ekanalyzer_module_type),
-						port_desc->remote_port);
-			} else {
-				printf("\tPort %d =====> On Carrier Device ID %d, Port %d\n",
-						port_desc->local_port,
-						(port_desc->remote_resource_id & 0x0f),
-						port_desc->remote_port);
-			}
-			rsc_desc.p2p_count--;
-		}
-	}
-	return OK_STATUS;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_power
-*
-* Description: Display the power management of the Carrier and AMC module by
-*           using current management record. If the display option equal to all,
-*           it will display power and carrier topology together.
-*
-* Restriction: Reference: AMC.0 Specification, Table 3-11
-*
-* Input: int argc: number of the argument received
-*       char* opt: option string that will tell what to display
-*       char** filename: strings that contained filename of FRU data binary file
-*       int* file_type: a pointer that contain file type (on carrier file,
-*                       a1 file, b1 file...)
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return 0 on success and -1 if the record doesn't exist.
-*
-***************************************************************************/
-static int
-ipmi_ek_display_power( int argc, char * opt, char ** filename, int * file_type )
-{
-   int num_file=0;
-   int return_value = ERROR_STATUS;
-   int index = 0;
-
-   /*list des multi record*/
-   struct ipmi_ek_multi_header * list_head[argc];
-   struct ipmi_ek_multi_header * list_record[argc];
-   struct ipmi_ek_multi_header * list_last[argc];
-
-   for ( num_file = 0; num_file < argc; num_file++ ){
-      list_head[num_file] = NULL;
-      list_record[num_file] = NULL;
-      list_last[num_file] = NULL;
-   }
-
-   for ( num_file = 0; num_file < argc; num_file++ ){
-      tboolean is_first_data = TRUE;
-      if ( file_type[num_file] == CONFIG_FILE ){
-         num_file++;
-      }
-
-      if ( is_first_data ){
-         printf("%s\n", STAR_LINE_LIMITER);
-         printf("\nFrom %s file '%s'\n",
-                  val2str( file_type[num_file], ipmi_ekanalyzer_module_type),
-                  filename[num_file]);
-         is_first_data = FALSE;
-      }
-
-      return_value = ipmi_ekanalyzer_fru_file2structure( filename[num_file],
-        &list_head[num_file], &list_record[num_file], &list_last[num_file]);
-
-      if ( list_head[num_file] != NULL ){
-         for (    list_record[num_file] = list_head[num_file];
-                  list_record[num_file] != NULL;
-                  list_record[num_file] = list_record[num_file]->next
-            ){
-            if ( ( strcmp(opt, "all") == 0 )
-                  && ( file_type[num_file] == ON_CARRIER_FRU_FILE )
-               ){
-                  if ( list_record[num_file]->data[PICMG_ID_OFFSET]
-                           ==
-                        FRU_AMC_CARRIER_P2P
-                     ){
-                        return_value = ipmi_ek_display_carrier_connectivity(
-                                                list_record[num_file] );
-               }
-               else if ( list_record[num_file]->data[PICMG_ID_OFFSET]
-                           ==
-                         FRU_AMC_CARRIER_INFO
-                       ){
-                  /*Ref: See AMC.0 Specification Table 3-3: Carrier Information
-                  * Table about offset value
-                  */
-                  printf( "   Number of AMC bays supported by Carrier: %d\n",
-                          list_record[num_file]->data[START_DATA_OFFSET+1] );
-               }
-            }
-            /*Ref: AMC.0 Specification: Table 3-11
-            * Carrier Activation and Current Management Record
-            */
-            if ( list_record[num_file]->data[PICMG_ID_OFFSET]
-                  ==
-                 FRU_AMC_ACTIVATION
-               ){
-               int index_data = START_DATA_OFFSET;
-               struct fru_picmgext_carrier_activation_record car;
-               struct fru_picmgext_activation_record * cur_desc;
-
-               memcpy ( &car, &list_record[num_file]->data[index_data],
-                     sizeof (struct fru_picmgext_carrier_activation_record) );
-               index_data +=
-                     sizeof (struct fru_picmgext_carrier_activation_record);
-               cur_desc = malloc (car.module_activation_record_count * \
-                     sizeof (struct fru_picmgext_activation_record) );
-               for(index=0; index<car.module_activation_record_count; index++){
-                  memcpy( &cur_desc[index],
-                           &list_record[num_file]->data[index_data],
-                           sizeof (struct fru_picmgext_activation_record) );
-
-                  index_data += sizeof (struct fru_picmgext_activation_record);
-               }
-               /*Display the current*/
-               ipmi_ek_display_current_descriptor( car,
-                                    cur_desc, filename[num_file] );
-               free(cur_desc);
-               cur_desc = NULL;
-            }
-            /*Ref: AMC.0 specification, Table 3-10: Module Current Requirement*/
-            else if ( list_record[num_file]->data[PICMG_ID_OFFSET]
-                       == FRU_AMC_CURRENT
-                    ){
-               float power_in_watt = 0;
-               float current_in_amp = 0;
-
-               printf("   %s power required (Current Draw): ",
-                  val2str ( file_type[num_file], ipmi_ekanalyzer_module_type) );
-               current_in_amp =
-                        list_record[num_file]->data[START_DATA_OFFSET]*0.1;
-               power_in_watt = current_in_amp * AMC_VOLTAGE;
-               printf("%.2f Watts (%.2f Amps)\n",power_in_watt, current_in_amp);
-            }
-         }
-         return_value = OK_STATUS;
-         /*Destroy the list of record*/
-         for ( index = 0; index < argc; index++ ){
-            while ( list_head[index] != NULL ){
-               ipmi_ek_remove_record_from_list ( list_head[index],
-                        &list_head[index],&list_last[index] );
-            }
-            if ( verbose > 1 )
-               printf("Record list has been removed successfully\n");
-         }
-      }
-   }
-   printf("%s\n", STAR_LINE_LIMITER);
-   return return_value;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_current_descriptor
-*
-* Description: Display the current descriptor under format xx Watts (xx Amps)
-*
-* Restriction: None
-*
-* Input: struct fru_picmgext_carrier_activation_record car: contain binary data
-*                  of carrier activation record
-*        struct fru_picmgext_activation_record * cur_desc: contain current
-*                  descriptor
-*        char* filename: strings that contained filename of FRU data binary file
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_current_descriptor(
-		struct fru_picmgext_carrier_activation_record car,
-		struct fru_picmgext_activation_record *cur_desc,
-		char *filename)
-{
-	int index = 0;
-	float power_in_watt = 0.0;
-	float current_in_amp = 0.0;
-	for (index = 0; index < car.module_activation_record_count; index++) {
-		/* See AMC.0 specification, Table 3-12 for
-		 * detail about calculation
-		 */
-		current_in_amp = (float)cur_desc[index].max_module_curr * 0.1;
-		power_in_watt = (float)current_in_amp * AMC_VOLTAGE;
-		printf("   Carrier AMC power available on %s:\n",
-				val2str( cur_desc[index].ibmb_addr,
-					ipmi_ekanalyzer_IPMBL_addr));
-		printf("\t- Local IPMB Address    \t: %02x\n",
-				cur_desc[index].ibmb_addr);
-		printf("\t- Maximum module Current\t: %.2f Watts (%.2f Amps)\n",
-				power_in_watt, current_in_amp);
-	}
-	/* Display total power on Carrier */
-	current_in_amp =  (float)car.max_internal_curr * 0.1;
-	power_in_watt = (float)current_in_amp * AMC_VOLTAGE;
-	printf("   Carrier AMC total power available for all bays from file '%s':",
-			filename);
-	printf(" %.2f Watts (%.2f Amps)\n", power_in_watt, current_in_amp);
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ekanalyzer_ekeying_match
-*
-* Description: Check for possible Ekeying match between two FRU files
-*
-* Restriction: None
-*
-* Input: argc: number of the argument received
-*        opt: string that contains display option received from user.
-*        filename: strings that contained filename of FRU data binary file
-*        file_type: a pointer that contain file type (on carrier file,
-*                       a1 file, b1 file...)
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return TRUE on success and FALSE if the record doesn't exist.
-*
-***************************************************************************/
-static tboolean
-ipmi_ekanalyzer_ekeying_match( int argc, char * opt,
-         char ** filename, int * file_type )
-{
-   tboolean return_value = FALSE;
-
-   if ( (strcmp(opt, "carrier") == 0 ) || (strcmp(opt, "power") == 0) ){
-      lprintf(LOG_ERR, "   ekanalyzer summary [match/ unmatch/ all]"\
-                   " <xx=frufile> <xx=frufile> [xx=frufile]");
-      return_value = ERROR_STATUS;
-   }
-   else{
-      int num_file=0;
-      tboolean amc_file = FALSE; /*used to indicate the present of AMC file*/
-      tboolean oc_file = FALSE; /*used to indicate the present of Carrier file*/
-
-      /*Check for possible ekeying match between files*/
-      for ( num_file=0; num_file < argc; num_file++ ){
-         if ( ( file_type[num_file] == ON_CARRIER_FRU_FILE )
-              || ( file_type[num_file] == CONFIG_FILE )
-              || ( file_type[num_file] == SHELF_MANAGER_FRU_FILE )
-            ){
-            amc_file = FALSE;
-         }
-         else {   /*there is an amc file*/
-            amc_file = TRUE;
-            break;
-         }
-      }
-      if ( amc_file == FALSE ){
-         printf("\nNo AMC FRU file is provided --->" \
-                       " No possible ekeying match!\n");
-         return_value = ERROR_STATUS;
-      }
-      else{
-         /*If no carrier file is provided, return error*/
-         for ( num_file=0; num_file < argc; num_file++ ){
-            if ( (file_type[num_file] == ON_CARRIER_FRU_FILE )
-                 || ( file_type[num_file] == CONFIG_FILE )
-                 || ( file_type[num_file] == SHELF_MANAGER_FRU_FILE )
-               ){
-               oc_file = TRUE;
-               break;
-            }
-         }
-         if ( !oc_file ){
-            printf("\nNo Carrier FRU file is provided" \
-                        " ---> No possible ekeying match!\n");
-            return_value = ERROR_STATUS;
-         }
-         else{
-            /*list des multi record*/
-            struct ipmi_ek_multi_header * list_head[argc];
-            struct ipmi_ek_multi_header * list_record[argc];
-            struct ipmi_ek_multi_header * list_last[argc];
-            struct ipmi_ek_multi_header * pcarrier_p2p;
-            int list = 0;
-            int match_pair = 0;
-
-            /*Create an empty list*/
-            for ( list=0; list<argc; list++ ){
-               list_head[list] = NULL;
-               list_record[list] = NULL;
-               list_last[list] = NULL;
-            }
-            list=0;
-
-            for ( num_file=0; num_file < argc; num_file++ ){
-               if (file_type[num_file] != CONFIG_FILE){
-                  return_value = ipmi_ekanalyzer_fru_file2structure(
-                                filename[num_file], &list_head[num_file],
-                                &list_record[num_file], &list_last[num_file]);
-               }
-            }
-            /*Get Carrier p2p connectivity record for physical check*/
-            for (num_file=0; num_file < argc; num_file++){
-               if (file_type[num_file] == ON_CARRIER_FRU_FILE ){
-                  for ( pcarrier_p2p=list_head[num_file];
-                        pcarrier_p2p != NULL ;
-                        pcarrier_p2p = pcarrier_p2p->next
-                     ){
-                     if ( pcarrier_p2p->data[PICMG_ID_OFFSET]
-                           == FRU_AMC_CARRIER_P2P
-                        ){
-                        break;
-                     }
-                  }
-                  break;
-               }
-            }
-            /*Determine the match making pair*/
-            while ( match_pair < argc ){
-               for ( num_file = (match_pair+1); num_file<argc; num_file++ ){
-                  if ( ( file_type[match_pair] != CONFIG_FILE )
-                        && ( file_type[num_file] != CONFIG_FILE )
-                     ){
-                     if ( ( file_type[match_pair] != ON_CARRIER_FRU_FILE )
-                           || ( file_type[num_file] != ON_CARRIER_FRU_FILE )
-                        ){
-                        printf("%s vs %s\n",
-                                 val2str(file_type[match_pair],
-                                                ipmi_ekanalyzer_module_type),
-                                 val2str(file_type[num_file],
-                                                ipmi_ekanalyzer_module_type));
-                        /*Ekeying match between 2 files*/
-                        if (verbose>0){
-                           printf("Start matching process\n");
-                        }
-                        return_value = ipmi_ek_matching_process( file_type,
-                                             match_pair, num_file, list_head,
-                                             list_last, opt, pcarrier_p2p);
-                     }
-                  }
-               }
-               match_pair ++;
-            }
-            for( num_file=0; num_file < argc; num_file++ ){
-               if (list_head[num_file] != NULL ){
-                  ipmi_ek_remove_record_from_list( list_head[num_file],
-                           &list_record[num_file], &list_last[num_file]);
-               }
-               if ( ( num_file == argc-1 ) && verbose )
-                  printf("Record list has been removed successfully\n");
-            }
-            return_value = OK_STATUS;
-         }
-      }
-   }
-   return return_value;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_matching_process
-*
-* Description: This function process the OEM check, Physical Connectivity check,
-*              and Link Descriptor comparison to do Ekeying match
-*
-* Restriction: None
-*
-* Input: file_type: a pointer that contain file type (on carrier file,
-*                       a1 file, b1 file...)
-*        index1: position of the first record in the list of the record
-*        index2: position of the second record in the list of the record
-*        ipmi_ek_multi_header ** list_head: pointer to the header of a
-*                 linked list that contain FRU multi record
-*        ipmi_ek_multi_header ** list_last: pointer to the tale of a
-*                 linked list that contain FRU multi record
-*        opt: string that contain display option such as "match", "unmatch", or
-*               "all".
-*        pphysical: a pointer that contain a carrier p2p connectivity record
-*                   to perform physical check
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return OK_STATUS on success and ERROR_STATUS if the record doesn't
-*           exist.
-*
-***************************************************************************/
-static int ipmi_ek_matching_process( int * file_type, int index1, int index2,
-      struct ipmi_ek_multi_header ** list_head,
-      struct ipmi_ek_multi_header ** list_last, char * opt,
-      struct ipmi_ek_multi_header * pphysical )
-{
-   int result = ERROR_STATUS;
-   struct ipmi_ek_multi_header * record;
-   int num_amc_record1 = 0;/*Number of AMC records in the first module*/
-   int num_amc_record2 = 0;/*Number of AMC records in the second module*/
-
-   /* Comparison between an On-Carrier and an AMC*/
-   if ( file_type[index2] == ON_CARRIER_FRU_FILE ){
-      int index_temp = 0;
-      index_temp = index1;
-      index1 = index2; /*index1 indicate on carrier*/
-      index2 = index_temp; /*index2 indcate an AMC*/
-   }
-   /*Calculate record size for Carrier file*/
-   for ( record=list_head[index1]; record != NULL;record = record->next ){
-      if ( record->data[PICMG_ID_OFFSET] == FRU_AMC_P2P ){
-         num_amc_record2++;
-      }
-   }
-   /*Calculate record size for amc file*/
-   for ( record=list_head[index2]; record != NULL;record = record->next){
-      if ( record->data[PICMG_ID_OFFSET] == FRU_AMC_P2P ){
-         num_amc_record1++;
-      }
-   }
-   if ( (num_amc_record1 > 0) && (num_amc_record2 > 0) ){
-      int index_record1 = 0;
-      int index_record2 = 0;
-      /* Multi records of AMC module */
-      struct ipmi_ek_amc_p2p_connectivity_record * amc_record1 = NULL;
-      /* Multi records of Carrier or an AMC module */
-      struct ipmi_ek_amc_p2p_connectivity_record * amc_record2 = NULL;
-
-      amc_record1 = malloc ( num_amc_record1 * \
-                           sizeof(struct ipmi_ek_amc_p2p_connectivity_record));
-      amc_record2 = malloc ( num_amc_record2 * \
-                           sizeof(struct ipmi_ek_amc_p2p_connectivity_record));
-
-      for (record=list_head[index2]; record != NULL;record = record->next){
-         if ( record->data[PICMG_ID_OFFSET] == FRU_AMC_P2P ){
-            result = ipmi_ek_create_amc_p2p_record( record,
-                                       &amc_record1[index_record1] );
-            if (result != ERROR_STATUS){
-               struct ipmi_ek_multi_header * current_record = NULL;
-
-               for ( current_record=list_head[index1];
-                     current_record != NULL ;
-                     current_record = current_record->next
-                  ){
-                  if ( current_record->data[PICMG_ID_OFFSET] == FRU_AMC_P2P ){
-                     result = ipmi_ek_create_amc_p2p_record( current_record,
-                                       &amc_record2[index_record2] );
-                     if ( result != ERROR_STATUS ){
-                        if ( result == OK_STATUS ){
-                           /*Compare Link descriptor*/
-                           result = ipmi_ek_compare_link ( pphysical,
-                                    amc_record1[index_record1],
-                                    amc_record2[index_record2],
-                                    opt, file_type[index1], file_type[index2]);
-                        }
-                        index_record2++;
-                     }
-                  } /*end of FRU_AMC_P2P */
-               } /* end of for loop */
-               index_record1++;
-            }
-         }
-      }
-      free(amc_record1) ;
-      amc_record1 = NULL;
-      free(amc_record2) ;
-      amc_record2 = NULL;
-   }
-   else{
-      printf("No amc record is found!\n");
-   }
-
-   return result;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_check_physical_connectivity
-*
-* Description: This function check for point to point connectivity between
-*               two modules by comparing each enable port in link descriptor
-*               with local and remote ports of port descriptor in
-*               carrier point-to-point connectivity record according to the
-*               corresponding file type ( a1, b1, b2...).
-*
-* Restriction: In order to perform physical check connectivity, it needs to
-*               compare between 2 AMC Modules, so the use of index ( 1 and 2 )
-*               can facilitate the comparison in this case.
-*
-* Input: record1: is an AMC p2p record for an AMC module
-*        record2 is an AMC p2p record for an On-Carrier record or an AMC module
-*        char* opt: option string that will tell if a matching result, unmatched
-*                 result or all the results will be displayed.
-*        file_type1: indicates type of the first module
-*        file_type2: indicates type of the second module
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return OK_STATUS if both link are matched, otherwise
-*            return ERROR_STATUS
-*
-***************************************************************************/
-static int
-ipmi_ek_check_physical_connectivity(
-      struct ipmi_ek_amc_p2p_connectivity_record record1, int index1,
-      struct ipmi_ek_amc_p2p_connectivity_record record2, int index2,
-      struct ipmi_ek_multi_header * record,
-      int filetype1, int filetype2, char * option )
-{
-   int return_status = OK_STATUS;
-
-   if ( record == NULL ){
-      printf("NO Carrier p2p connectivity !\n");
-      return_status = ERROR_STATUS;
-   }
-   else{
-      #define INVALID_AMC_SITE_NUMBER      -1
-      int index = START_DATA_OFFSET;
-      int amc_site = INVALID_AMC_SITE_NUMBER;
-      struct fru_picmgext_carrier_p2p_record rsc_desc;
-      struct fru_picmgext_carrier_p2p_descriptor * port_desc = NULL;
-
-      /* Get the physical connectivity record */
-      while ( index < record->header.len ) {
-         rsc_desc.resource_id = record->data[index++];
-         rsc_desc.p2p_count = record->data[index++];
-         /* carrier p2p record starts with on-carrier device */
-         if ( (rsc_desc.resource_id == record1.rsc_id)
-               ||
-              (rsc_desc.resource_id == record2.rsc_id)
-            ){
-            if (rsc_desc.p2p_count <= 0){
-               printf("No p2p count\n");
-               return_status = ERROR_STATUS;
-            }
-            else{
-               port_desc = malloc ( rsc_desc.p2p_count *
-                           sizeof(struct fru_picmgext_carrier_p2p_descriptor) );
-               index = ipmi_ek_get_resource_descriptor( rsc_desc.p2p_count,
-                           index, port_desc, record );
-               amc_site = INVALID_AMC_SITE_NUMBER;
-               break;
-            }
-         }
-         else{ /* carrier p2p record starts with AMC module */
-            if (rsc_desc.resource_id == AMC_MODULE){
-               if (filetype1 != ON_CARRIER_FRU_FILE){
-                  amc_site = filetype1;
-               }
-               else{
-                  amc_site = filetype2;
-               }
-            }
-            else{
-               amc_site = rsc_desc.resource_id & 0x0f;
-            }
-            if ( amc_site > 0 ){
-               if ( (amc_site == filetype1) || (amc_site == filetype2) ){
-                  port_desc = malloc ( rsc_desc.p2p_count *
-                           sizeof(struct fru_picmgext_carrier_p2p_descriptor) );
-                  index = ipmi_ek_get_resource_descriptor( rsc_desc.p2p_count,
-                                    index, port_desc, record );
-                  break;
-               }
-            }
-            else{
-               return_status = ERROR_STATUS;
-            }
-         }
-         /*If the record doesn't contain the same AMC site number in command
-         * line, go to the next record
-         */
-         index += ( sizeof(struct fru_picmgext_carrier_p2p_descriptor) *
-                     rsc_desc.p2p_count );
-      }
-
-      if ( (port_desc != NULL) && (return_status != ERROR_STATUS) ){
-         int j=0;
-
-         for ( j = 0; j < rsc_desc.p2p_count; j++ ){
-            /* Compare only enable channel descriptor */
-            if ( record1.ch_desc[index1].lane0port != DISABLE_PORT ){
-               /* matching result from channel descriptor comparison */
-               tboolean match_lane = FALSE;
-
-               match_lane = ipmi_ek_compare_channel_descriptor (
-                              record1.ch_desc[index1], record2.ch_desc[index2],
-                              port_desc, j, rsc_desc.resource_id );
-
-               if ( match_lane ){
-                  if ( filetype1 != ON_CARRIER_FRU_FILE ){
-                     if ( (
-                           (filetype1 == (rsc_desc.resource_id & 0x0f))
-                              &&
-                           (filetype2 ==(port_desc[j].remote_resource_id &0x0f))
-                          )
-                          ||
-                          (
-                           (filetype2 == (rsc_desc.resource_id & 0x0f))
-                              &&
-                           (filetype1 ==(port_desc[j].remote_resource_id &0x0f))
-                          )
-                        ){
-                        if ( ! (strcmp(option, "unmatch") == 0) ){
-                           printf("%s port %d ==> %s port %d\n",
-                              val2str(filetype2, ipmi_ekanalyzer_module_type),
-                              record1.ch_desc[index1].lane0port,
-                              val2str(filetype1, ipmi_ekanalyzer_module_type),
-                              record2.ch_desc[index2].lane0port);
-                        }
-                        return_status = OK_STATUS;
-
-                        break;
-                     }
-                     else{
-                        if (verbose == LOG_DEBUG){
-                           printf("No point 2 point connectivity\n");
-                        }
-                        return_status = ERROR_STATUS;
-                     }
-                  }
-                  else{
-                     if ( (record2.rsc_id == (rsc_desc.resource_id) )
-                           &&
-                         (filetype2 == (port_desc[j].remote_resource_id & 0x0f))
-                        ){
-                        if ( ! (strcmp(option, "unmatch") == 0) ){
-                           printf("%s port %d ==> %s port %d\n",
-                              val2str(filetype2, ipmi_ekanalyzer_module_type),
-                              record1.ch_desc[index1].lane0port,
-                              val2str(filetype1, ipmi_ekanalyzer_module_type),
-                              record2.ch_desc[index2].lane0port);
-                        }
-                        return_status = OK_STATUS;
-                        break;
-                     }
-                     else if ( (filetype2 == (rsc_desc.resource_id & 0x0f) )
-                              &&
-                           (record2.rsc_id == (port_desc[j].remote_resource_id))
-                        ){
-                        if ( ! (strcmp(option, "unmatch") == 0) ){
-                           printf("%s port %d ==> %s %x port %d\n",
-                              val2str(filetype2, ipmi_ekanalyzer_module_type),
-                              record1.ch_desc[index1].lane0port,
-                              val2str(filetype1, ipmi_ekanalyzer_module_type),
-                              record2.rsc_id,record2.ch_desc[index2].lane0port);
-                        }
-                        return_status = OK_STATUS;
-                        break;
-                     }
-                     else{
-                        if (verbose == LOG_DEBUG){
-                           printf("No point 2 point connectivity\n");
-                        }
-                        return_status = ERROR_STATUS;
-                     }
-                  }
-               }
-               else{
-                  if (verbose == LOG_DEBUG){
-                           printf("No point 2 point connectivity\n");
-                  }
-                  return_status = ERROR_STATUS;
-               }
-            }
-            else{ /*If the link is disable, the result is always true*/
-               return_status = OK_STATUS;
-            }
-         }
-      }
-      else{
-         if (verbose == LOG_WARN){
-            printf("Invalid Carrier p2p connectivity record\n");
-         }
-         return_status = ERROR_STATUS;
-      }
-      if (port_desc != NULL){
-         free(port_desc);
-         port_desc = NULL;
-      }
-   }
-   return return_status;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_compare_link
-*
-* Description: This function compares link grouping id of each
-*               amc p2p connectiviy record
-*
-* Restriction: None
-*
-* Input: record1: is an AMC p2p record for an AMC module
-*        record2 is an AMC p2p record for an On-Carrier record or an AMC module
-*        char* opt: option string that will tell if a matching result, unmatched
-*                 result or all the results will be displayed.
-*        file_type1: indicates type of the first module
-*        file_type2: indicates type of the second module
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return 0 if both link are matched, otherwise return -1
-*
-***************************************************************************/
-static int
-ipmi_ek_compare_link( struct ipmi_ek_multi_header * physic_record,
-   struct ipmi_ek_amc_p2p_connectivity_record record1,
-   struct ipmi_ek_amc_p2p_connectivity_record record2, char * opt,
-   int file_type1, int file_type2 )
-{
-   int result = ERROR_STATUS;
-   int index1 = 0; /*index for AMC module*/
-   int index2 = 0; /*index for On-carrier type*/
-
-   record1.matching_result = malloc ( record1.link_desc_count * sizeof(int) );
-   record2.matching_result = malloc ( record2.link_desc_count * sizeof(int) );
-   /*Initialize all the matching_result to false*/
-   for( index2 = 0; index2 < record2.link_desc_count; index2++ ){
-      record2.matching_result[index2] = FALSE;
-   }
-   for( index1 = 0; index1 < record1.link_desc_count; index1++ ){
-      for( index2 = 0; index2 < record2.link_desc_count; index2++ ){
-         if( record1.link_desc[index1].group_id == 0 ){
-            if( record2.link_desc[index2].group_id == 0 ){
-               result = ipmi_ek_compare_link_descriptor(
-                              record1, index1, record2, index2 );
-               if ( result == OK_STATUS ){
-                  /*Calculate the index for Channel descriptor in function of
-                  * link designator channel ID
-                  */
-                  /*first channel_id in the AMC Link descriptor of record1*/
-                  static int flag_first_link1;
-                  int index_ch_desc1; /*index of channel descriptor */
-                  /*first channel_id in the AMC Link descriptor of record2*/
-                  static int flag_first_link2;
-                  int index_ch_desc2; /*index of channel descriptor*/
-
-                  if (index1==0){ /*this indicate the first link is encounter*/
-                     flag_first_link1 = record1.link_desc[index1].channel_id;
-                  }
-                  index_ch_desc1 = record1.link_desc[index1].channel_id -
-                              flag_first_link1;
-                  if (index2==0){
-                     flag_first_link2 = record2.link_desc[index2].channel_id;
-                  }
-                  index_ch_desc2 = record2.link_desc[index2].channel_id -
-                              flag_first_link2;
-                  /*Check for physical connectivity for each link*/
-                  result = ipmi_ek_check_physical_connectivity ( record1,
-                      index_ch_desc1, record2, index_ch_desc2,
-                           physic_record, file_type1, file_type2, opt );
-                  if ( result == OK_STATUS ){
-                     /*Display the result if option = match or all*/
-                     if ( (strcmp( opt, "match" ) == 0)
-                           || (strcmp( opt, "all" ) == 0)
-                           || (strcmp( opt, "default" ) == 0)
-                        ){
-                        tboolean isOEMtype = FALSE;
-                        printf(" Matching Result\n");
-                        isOEMtype = ipmi_ek_display_link_descriptor( file_type1,
-                                          record2.rsc_id,
-                                          "From", record2.link_desc[index2]);
-                        if (isOEMtype){
-                           ipmi_ek_display_oem_guid (record2);
-                        }
-                        isOEMtype = ipmi_ek_display_link_descriptor( file_type2,
-                                          record1.rsc_id,
-                                          "To", record1.link_desc[index1] );
-                        if (isOEMtype){
-                           ipmi_ek_display_oem_guid (record1);
-                        }
-                        printf("  %s\n", STAR_LINE_LIMITER);
-                     }
-                     record2.matching_result[index2] = TRUE;
-                     record1.matching_result[index1] = TRUE;
-                     /*quit the fist loop since the match is found*/
-                     index2 = record2.link_desc_count;
-                  }
-               }
-            }
-         }
-         else { /*Link Grouping ID is non zero, Compare all link descriptor
-                 * that has non-zero link grouping id together
-                 */
-            if (record2.link_desc[index2].group_id != 0 ){
-               result = ipmi_ek_compare_link_descriptor(
-                              record1, index1, record2, index2 );
-               if ( result == OK_STATUS ){
-                  /*Calculate the index for Channel descriptor in function of
-                  * link designator channel ID
-                  */
-                  /*first channel_id in the AMC Link descriptor of record1*/
-                  static int flag_first_link1;
-                  int index_ch_desc1; /*index of channel descriptor */
-                  /*first channel_id in the AMC Link descriptor of record2*/
-                  static int flag_first_link2;
-                  int index_ch_desc2; /*index of channel descriptor*/
-
-                  if (index1==0){ /*this indicate the first link is encounter*/
-                     flag_first_link1 = record1.link_desc[index1].channel_id;
-                  }
-                  index_ch_desc1 = record1.link_desc[index1].channel_id -
-                              flag_first_link1;
-                  if (index2==0){
-                     flag_first_link2 = record2.link_desc[index2].channel_id;
-                  }
-                  index_ch_desc2 = record2.link_desc[index2].channel_id -
-                              flag_first_link2;
-                  /*Check for physical connectivity for each link*/
-                  result = ipmi_ek_check_physical_connectivity (
-                           record1, index_ch_desc1, record2, index_ch_desc2,
-                           physic_record, file_type1, file_type2, opt );
-                  if ( result == OK_STATUS ){
-                     if ( (strcmp( opt, "match" ) == 0)
-                           || (strcmp( opt, "all" ) == 0)
-                           || (strcmp( opt, "default" ) == 0)
-                        ){
-                        tboolean isOEMtype = FALSE;
-                        printf("  Matching Result\n");
-                        isOEMtype = ipmi_ek_display_link_descriptor( file_type1,
-                                       record2.rsc_id,
-                                       "From", record2.link_desc[index2] );
-                        if ( isOEMtype ){
-                           ipmi_ek_display_oem_guid (record2);
-                        }
-                        isOEMtype = ipmi_ek_display_link_descriptor( file_type2,
-                                       record1.rsc_id,
-                                       "To", record1.link_desc[index1] );
-                        if (isOEMtype){
-                           ipmi_ek_display_oem_guid (record1);
-                        }
-                        printf("  %s\n", STAR_LINE_LIMITER);
-                     }
-                     record2.matching_result[index2] = TRUE;
-                     record1.matching_result[index1] = TRUE;
-                     /*leave the fist loop since the match is found*/
-                     index2 = record2.link_desc_count;
-                  }
-               }
-            }
-         }
-      }
-   }
-
-   if ( (strcmp(opt, "unmatch") == 0) || (strcmp(opt, "all") == 0) ){
-      int isOEMtype = FALSE;
-      printf("  Unmatching result\n");
-      for (index1 = 0; index1 < record1.link_desc_count; index1++){
-         isOEMtype = ipmi_ek_display_link_descriptor( file_type2,
-                           record1.rsc_id, "", record1.link_desc[index1] );
-         if ( isOEMtype ){
-            ipmi_ek_display_oem_guid (record1);
-         }
-         printf("   %s\n", STAR_LINE_LIMITER);
-      }
-      for ( index2 = 0; index2 < record2.link_desc_count; index2++){
-         if ( !record2.matching_result[index2] ){
-            isOEMtype = ipmi_ek_display_link_descriptor( file_type1,
-                           record2.rsc_id, "", record2.link_desc[index2] );
-            if ( isOEMtype ){
-               ipmi_ek_display_oem_guid (record2);
-            }
-            printf("   %s\n", STAR_LINE_LIMITER);
-         }
-      }
-   }
-
-   free(record1.matching_result);
-   record1.matching_result = NULL;
-   free(record2.matching_result);
-   record2.matching_result = NULL;
-
-   return result;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_compare_channel_descriptor
-*
-* Description: This function compares 2 channel descriptors of 2 AMC
-*               point-to-point connectivity records with port descriptor of
-*                carrier point-to-point connectivity record. The comparison is
-*                made between each enable port only.
-*
-* Restriction: Reference: AMC.0 specification:
-*                     - Table 3-14 for port descriptor
-*                     - Table 3-17 for channel descriptor
-*
-* Input: ch_desc1: first channel descriptor
-*        ch_desc2: second channel descriptor
-*        port_desc: a pointer that contain a list of port descriptor
-*        index_port: index of the port descriptor
-*         rsc_id: resource id that represents as local resource id in the
-*                  resource descriptor table.
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return TRUE if both channel descriptor are matched,
-*         or FALSE otherwise
-*
-***************************************************************************/
-static tboolean
-ipmi_ek_compare_channel_descriptor(
-      struct fru_picmgext_amc_channel_desc_record ch_desc1,
-      struct fru_picmgext_amc_channel_desc_record ch_desc2,
-      struct fru_picmgext_carrier_p2p_descriptor * port_desc,
-      int index_port, unsigned char rsc_id )
-{
-   tboolean match_lane = FALSE;
-
-   /* carrier p2p record start with AMC_MODULE as local port */
-   if ( (rsc_id & AMC_MODULE) == AMC_MODULE ){
-      if ( (ch_desc1.lane0port == port_desc[index_port].local_port)
-               &&
-           (ch_desc2.lane0port == port_desc[index_port].remote_port)
-         ){
-         /*check if the port is enable*/
-         if (ch_desc1.lane1port != DISABLE_PORT){
-            index_port ++;
-            if ( (ch_desc1.lane1port == port_desc[index_port].local_port)
-                     &&
-                 (ch_desc2.lane1port == port_desc[index_port].remote_port)
-               ){
-               if (ch_desc1.lane2port != DISABLE_PORT){
-                  index_port++;
-                  if ( (ch_desc1.lane2port == port_desc[index_port].local_port)
-                           &&
-                       (ch_desc2.lane2port == port_desc[index_port].remote_port)
-                     ){
-                     if (ch_desc1.lane3port != DISABLE_PORT){
-                        index_port++;
-                        if ( (ch_desc1.lane3port ==
-                                             port_desc[index_port].local_port)
-                                 &&
-                             (ch_desc2.lane3port ==
-                                             port_desc[index_port].remote_port)
-                           ){
-                              match_lane = TRUE;
-                        }
-                     }
-                     else{
-                        match_lane = TRUE;
-                     }
-                  } /* end of if lane2port */
-               }
-               else{
-                  match_lane = TRUE;
-               }
-            } /* end of if lane1port */
-         }
-         else{ /*if the port is disable, the compare result is always true*/
-              match_lane = TRUE;
-         }
-      }/* end of if lane0port */
-   }
-   /* carrier p2p record start with Carrier as local port */
-   else{
-      if ( (ch_desc1.lane0port == port_desc[index_port].remote_port)
-               &&
-           (ch_desc2.lane0port == port_desc[index_port].local_port)
-         ){
-         if (ch_desc1.lane1port != DISABLE_PORT){
-            index_port ++;
-            if ( (ch_desc1.lane1port == port_desc[index_port].remote_port)
-                     &&
-                 (ch_desc2.lane1port == port_desc[index_port].local_port)
-               ){
-               if (ch_desc1.lane2port != DISABLE_PORT){
-                  index_port++;
-                  if ( (ch_desc1.lane2port == port_desc[index_port].remote_port)
-                           &&
-                       (ch_desc2.lane2port == port_desc[index_port].local_port)
-                     ){
-                     if (ch_desc1.lane3port != DISABLE_PORT){
-                        index_port++;
-                        if ( (ch_desc1.lane3port ==
-                                             port_desc[index_port].remote_port)
-                                 &&
-                             (ch_desc2.lane3port ==
-                                             port_desc[index_port].local_port)
-                           ){
-                              match_lane = TRUE;
-                        }
-                     }
-                     else{
-                        match_lane = TRUE;
-                     }
-                  } /* end of if lane2port */
-               }
-               else{
-                  match_lane = TRUE;
-               }
-            } /* end of if lane1port */
-         }
-         else{
-              match_lane = TRUE;
-         }
-      } /* end of if lane0port */
-   }
-
-   return match_lane;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_compare_link_descriptor
-*
-* Description: This function compares 2 link descriptors of 2
-*               amc p2p connectiviy record
-*
-* Restriction: None
-*
-* Input: record1: AMC p2p connectivity record of the 1rst AMC or Carrier Module
-*         index1: index of AMC link descriptor in 1rst record
-*         record2: AMC p2p connectivity record of the 2nd AMC or Carrier Module
-*         index1: index of AMC link descriptor in 2nd record
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return OK_STATUS if both link are matched,
-*            otherwise return ERROR_STATUS
-*
-***************************************************************************/
-static int
-ipmi_ek_compare_link_descriptor(
-		struct ipmi_ek_amc_p2p_connectivity_record record1,
-		int index1,
-		struct ipmi_ek_amc_p2p_connectivity_record record2,
-		int index2)
-{
-	int result = ERROR_STATUS;
-	if (record1.link_desc[index1].type != record2.link_desc[index2].type) {
-		return ERROR_STATUS;
-	}
-	/* if it is an OEM type, we compare the OEM GUID */
-	if ((record1.link_desc[index1].type >= LOWER_OEM_TYPE)
-			&& (record1.link_desc[index1].type <= UPPER_OEM_TYPE)) {
-		if ((record1.guid_count == 0) && (record2.guid_count == 0)) {
-			/*there is no GUID for comparison, so the result is always OK*/
-			result = OK_STATUS;
-		} else {
-			int i = 0;
-			int j = 0;
-			for (i = 0; i < record1.guid_count; i++) {
-				for (j = 0; j < record2.guid_count; j++) {
-					if (memcmp(&record1.oem_guid[i],
-								&record2.oem_guid[j],
-								SIZE_OF_GUID) == 0) {
-						result = OK_STATUS;
-						break;
-					}
-				}
-			}
-		}
-	} else {
-		result = OK_STATUS;
-	}
-	if (result != OK_STATUS) {
-		return result;
-	}
-	if (record1.link_desc[index1].type_ext == record2.link_desc[index2].type_ext) {
-		unsigned char asym[COMPARE_CANDIDATE];
-		int offset = 0;
-		asym[offset++] = record1.link_desc[index1].asym_match;
-		asym[offset] = record2.link_desc[index2].asym_match;
-		result = ipmi_ek_compare_asym (asym);
-		if (result == OK_STATUS){
-			struct fru_picmgext_amc_link_desc_record link[COMPARE_CANDIDATE];
-			int index = 0;
-			link[index++] = record1.link_desc[index1];
-			link[index] = record2.link_desc[index2];
-			result = ipmi_ek_compare_number_of_enable_port(link);
-		} else {
-			result = ERROR_STATUS;
-		}
-	} else {
-		result = ERROR_STATUS;
-	}
-	return result;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_compare_asym
-*
-* Description: This function compares 2 asymetric match of 2
-*               amc link descriptors
-*
-* Restriction: None
-*
-* Input:      asym[COMPARE_CANDIDATE]: Contain 2 asymetric match for comparison
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return 0 if both asym. match are matched, otherwise return -1
-*
-***************************************************************************/
-
-static int
-ipmi_ek_compare_asym(unsigned char asym[COMPARE_CANDIDATE])
-{
-	int return_value = ERROR_STATUS;
-	int first_index = 0;
-	int second_index = 1;
-
-	if ((asym[first_index] == 0) && (asym[second_index] == 0)) {
-		return_value = OK_STATUS;
-	} else if ((asym[first_index] & asym[second_index]) == 0) {
-		return_value = OK_STATUS;
-	} else {
-		return_value = ERROR_STATUS;
-	}
-	return return_value;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_compare_link_descriptor
-*
-* Description: This function compare number of enble port of Link designator
-*
-* Restriction: None
-*
-* Input: link_designator1: first link designator
-*        link_designator2:  second link designator
-*
-* Output: None
-*
-* Global: None
-*
-* Return:   return 0 if both link are matched, otherwise return -1
-*
-***************************************************************************/
-static int
-ipmi_ek_compare_number_of_enable_port(
-		struct fru_picmgext_amc_link_desc_record link_desc[COMPARE_CANDIDATE])
-{
-	int amc_port_count = 0;
-	int carrier_port_count = 0;
-	int return_value = ERROR_STATUS;
-	int index = 0;
-
-	if (link_desc[index].port_flag_0) {
-		/*bit 0 indicates port 0*/
-		amc_port_count++;
-	}
-	if (link_desc[index].port_flag_1) {
-		/*bit 1 indicates port 1*/
-		amc_port_count++;
-	}
-	if (link_desc[index].port_flag_2) {
-		/*bit 2 indicates port 2*/
-		amc_port_count++;
-	}
-	if (link_desc[index++].port_flag_3) {
-		/*bit 3 indicates port 3*/
-		amc_port_count++;
-	}
-
-	/* 2nd link designator */
-	if (link_desc[index].port_flag_0) {
-		/*bit 0 indicates port 0*/
-		carrier_port_count++;
-	}
-	if (link_desc[index].port_flag_1) {
-		/*bit 1 indicates port 1*/
-		carrier_port_count++;
-	}
-	if (link_desc[index].port_flag_2) {
-		/*bit 2 indicates port 2*/
-		carrier_port_count++;
-	}
-	if (link_desc[index].port_flag_3) {
-		/*bit 3 indicates port 3*/
-		carrier_port_count++;
-	}
-
-	if (carrier_port_count == amc_port_count) {
-		return_value = OK_STATUS;
-	} else {
-		return_value = ERROR_STATUS;
-	}
-	return return_value;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_link_descriptor
-*
-* Description: Display the link descriptor of an AMC p2p connectivity record
-*
-* Restriction: See AMC.0 or PICMG 3.0 specification for detail about bit masks
-*
-* Input: file_type: module type.
-*        rsc_id: resource id
-*        char* str: indicates if it is a source (its value= "From") or a
-*                 destination (its value = "To"). ( it is set to "" if it is not
-*                 a source nor destination
-*        link_desc: AMC link descriptor
-*        asym:  asymetric match
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static tboolean
-ipmi_ek_display_link_descriptor(int file_type, unsigned char rsc_id,
-		char *str,
-		struct fru_picmgext_amc_link_desc_record link_desc)
-{
-	tboolean isOEMtype = FALSE;
-	if (file_type == ON_CARRIER_FRU_FILE) {
-		printf("  - %s On-Carrier Device ID %d\n", str,
-				(rsc_id & 0x0f));
-	} else {
-		printf("  - %s %s\n", str, val2str(file_type,
-					ipmi_ekanalyzer_module_type));
-	}
-	printf("    - Channel ID %d || ",  link_desc.channel_id);
-	printf("%s", link_desc.port_flag_0 ? "Lane 0: enable" : "");
-	printf("%s", link_desc.port_flag_1 ? ", Lane 1: enable" : "");
-	printf("%s", link_desc.port_flag_2 ? ", Lane 2: enable" : "");
-	printf("%s", link_desc.port_flag_3 ? ", Lane 3: enable" : "");
-	printf("\n");
-	printf("    - Link Type: %s \n", val2str(link_desc.type,
-				ipmi_ekanalyzer_link_type));
-	switch (link_desc.type) {
-	case FRU_PICMGEXT_AMC_LINK_TYPE_PCIE:
-	case FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS1:
-	case FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS2:
-		printf("    - Link Type extension: %s\n",
-				val2str(link_desc.type_ext,
-					ipmi_ekanalyzer_extension_PCIE));
-		printf("    - Link Group ID: %d || ", link_desc.group_id);
-		printf("Link Asym. Match: %d - %s\n",
-				link_desc.asym_match, 
-				val2str(link_desc.asym_match,
-					ipmi_ekanalyzer_asym_PCIE));
-		break;
-	case FRU_PICMGEXT_AMC_LINK_TYPE_ETHERNET:
-		printf("    - Link Type extension: %s\n",
-				val2str(link_desc.type_ext,
-					ipmi_ekanalyzer_extension_ETHERNET));
-		printf("    - Link Group ID: %d || ", link_desc.group_id);
-		printf("Link Asym. Match: %d - %s\n",
-				link_desc.asym_match, 
-				val2str(link_desc.asym_match,
-					ipmi_ekanalyzer_asym_PCIE));
-		break;
-	case FRU_PICMGEXT_AMC_LINK_TYPE_STORAGE:
-		printf("    - Link Type extension: %s\n",
-				val2str(link_desc.type_ext,
-					ipmi_ekanalyzer_extension_STORAGE));
-		printf("    - Link Group ID: %d || ",
-				link_desc.group_id);
-		printf("Link Asym. Match: %d - %s\n",
-				link_desc.asym_match, 
-				val2str(link_desc.asym_match,
-					ipmi_ekanalyzer_asym_STORAGE));
-		break;
-	default:
-		printf("    - Link Type extension: %i\n",
-				link_desc.type_ext);
-		printf("    - Link Group ID: %d || ",
-				link_desc.group_id);
-		printf("Link Asym. Match: %i\n",
-				link_desc.asym_match);
-		break;
-	}
-	/* return as OEM type if link type indicates OEM */
-	if ((link_desc.type >= LOWER_OEM_TYPE)
-			&& (link_desc.type <= UPPER_OEM_TYPE)) {
-		isOEMtype = TRUE;
-	}
-	return isOEMtype;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_oem_guid
-*
-* Description: Display the oem guid of an AMC p2p connectivity record
-*
-* Restriction: None
-*
-* Input: amc_record: AMC p2p connectivity record
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_oem_guid(struct ipmi_ek_amc_p2p_connectivity_record amc_record)
-{
-	int index_oem = 0;
-	int index = 0;
-	if (amc_record.guid_count == 0) {
-		printf("\tThere is no OEM GUID for this module\n");
-	}
-	for (index_oem = 0; index_oem < amc_record.guid_count; index_oem++) {
-		printf("    - GUID: ");
-		for (index = 0; index < SIZE_OF_GUID; index++) {
-			printf("%02x",
-					amc_record.oem_guid[index_oem].guid[index]);
-			/* For a better look: putting a "-" after displaying
-			 * four bytes of GUID
-			 */
-			if (!(index % 4)){
-				printf("-");
-			}
-		}
-		printf("\n");
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_create_amc_p2p_record
-*
-* Description: this function create an AMC point 2 point connectivity record
-*            that contain link descriptor, channel descriptor, oem guid
-*
-* Restriction: Reference: AMC.0 Specification Table 3-16
-*
-* Input: record: a pointer to FRU multi record
-*
-* Output: amc_record: a pointer to the created AMC p2p record
-*
-* Global: None
-*
-* Return: Return OK_STATUS on success, or ERROR_STATUS if no record has been
-*          created.
-*
-***************************************************************************/
-static int
-ipmi_ek_create_amc_p2p_record(struct ipmi_ek_multi_header *record,
-		struct ipmi_ek_amc_p2p_connectivity_record *amc_record)
-{
-	int index_data = START_DATA_OFFSET;
-	int return_status = OK_STATUS;
-
-	amc_record->guid_count = record->data[index_data++];
-	if (amc_record->guid_count > 0) {
-		int index_oem = 0;
-		amc_record->oem_guid = malloc(amc_record->guid_count * \
-				sizeof(struct fru_picmgext_guid));
-		for (index_oem = 0; index_oem < amc_record->guid_count;
-				index_oem++) {
-			memcpy(&amc_record->oem_guid[index_oem].guid,
-					&record->data[index_data],
-					SIZE_OF_GUID);
-			index_data += (int)SIZE_OF_GUID;
-		}
-		amc_record->rsc_id = record->data[index_data++];
-		amc_record->ch_count = record->data[index_data++];
-		/* Calculate link descriptor count */
-		amc_record->link_desc_count = ((record->header.len) - 8 -
-				(SIZE_OF_GUID*amc_record->guid_count) -
-				(FRU_PICMGEXT_AMC_CHANNEL_DESC_RECORD_SIZE *
-				amc_record->ch_count)) / 5 ;
-	} else {
-		amc_record->rsc_id = record->data[index_data++];
-		amc_record->ch_count = record->data[index_data++];
-		/* Calculate link descriptor count see spec AMC.0 for detail */
-		amc_record->link_desc_count = ((record->header.len) - 8 -
-				(FRU_PICMGEXT_AMC_CHANNEL_DESC_RECORD_SIZE *
-				amc_record->ch_count)) / 5;
-	}
-
-	if (amc_record->ch_count > 0) {
-		int ch_index = 0;
-		amc_record->ch_desc = malloc((amc_record->ch_count) * \
-				sizeof(struct fru_picmgext_amc_channel_desc_record));
-		for (ch_index = 0; ch_index < amc_record->ch_count;
-				ch_index++) {
-			unsigned int data;
-			struct fru_picmgext_amc_channel_desc_record *src, *dst;
-			data = record->data[index_data] | 
-				(record->data[index_data + 1] << 8) |
-				(record->data[index_data + 2] << 16);
-			
-			src = (struct fru_picmgext_amc_channel_desc_record *)&data;
-			dst = (struct fru_picmgext_amc_channel_desc_record *)
-				&amc_record->ch_desc[ch_index];
-
-			dst->lane0port = src->lane0port;
-			dst->lane1port = src->lane1port;
-			dst->lane2port = src->lane2port;
-			dst->lane3port = src->lane3port;
-			index_data += FRU_PICMGEXT_AMC_CHANNEL_DESC_RECORD_SIZE;
-		}
-	}
-	if (amc_record->link_desc_count > 0) {
-		int i=0;
-		amc_record->link_desc = malloc(amc_record->link_desc_count * \
-				sizeof(struct fru_picmgext_amc_link_desc_record));
-		for (i = 0; i< amc_record->link_desc_count; i++) {
-			unsigned int data[2];
-			struct fru_picmgext_amc_link_desc_record *src, *dst;
-			data[0] = record->data[index_data] | 
-				(record->data[index_data + 1] << 8) |
-				(record->data[index_data + 2] << 16) |
-				(record->data[index_data + 3] << 24);
-
-			data[1] = record->data[index_data + 4];
-			src = (struct fru_picmgext_amc_link_desc_record*)&data;
-			dst = (struct fru_picmgext_amc_link_desc_record*) 
-				&amc_record->link_desc[i];
-
-			dst->channel_id = src->channel_id;
-			dst->port_flag_0 = src->port_flag_0;
-			dst->port_flag_1 = src->port_flag_1;
-			dst->port_flag_2 = src->port_flag_2;
-			dst->port_flag_3 = src->port_flag_3;
-			dst->type = src->type;
-			dst->type_ext = src->type_ext;
-			dst->group_id = src->group_id;
-			dst->asym_match = src->asym_match;
-			index_data += FRU_PICMGEXT_AMC_LINK_DESC_RECORD_SIZE;
-		}
-	} else {
-		return_status = ERROR_STATUS;
-	}
-	return return_status;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_get_resource_descriptor
-*
-* Description: this function create the resource descriptor of Carrier p2p
-*              connectivity record.
-*
-* Restriction: None
-*
-* Input: port_count: number of port count
-*        index: index to the position of data start offset
-*        record: a pointer to FRU multi record
-*
-* Output: port_desc: a pointer to the created resource descriptor
-*
-* Global: None
-*
-* Return: Return index that indicates the current position of data in record.
-*
-***************************************************************************/
-static int
-ipmi_ek_get_resource_descriptor(int port_count, int index,
-		struct fru_picmgext_carrier_p2p_descriptor *port_desc,
-		struct ipmi_ek_multi_header *record)
-{
-	int num_port = 0;
-	while (num_port < port_count) {
-		memcpy(&port_desc[num_port], &record->data[index],
-				sizeof (struct fru_picmgext_carrier_p2p_descriptor));
-		index += sizeof (struct fru_picmgext_carrier_p2p_descriptor);
-		num_port++;
-	}
-	return index;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_fru_header
-*
-* Description: this function display FRU header offset from a FRU binary file
-*
-* Restriction: Reference: IPMI Platform Management FRU Information Storage
-*                  Definition V1.0, Section 8
-*
-* Input: filename: name of FRU binary file
-*
-* Output: None
-*
-* Global: None
-*
-* Return: Return OK_STATUS on sucess, ERROR_STATUS on error
-*
-***************************************************************************/
-static int
-ipmi_ek_display_fru_header(char *filename)
-{
-	FILE *input_file;
-	struct fru_header header;
-	int ret = 0;
-
-	input_file = fopen(filename, "r");
-	if (input_file == NULL) {
-		lprintf(LOG_ERR, "File '%s' not found.", filename);
-		return (ERROR_STATUS);
-	}
-	ret = fread(&header, sizeof (struct fru_header), 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Failed to read FRU header!");
-		fclose(input_file);
-		return (ERROR_STATUS);
-	}
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	printf("FRU Header Info\n");
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	printf("Format Version          :0x%02x %s\n",
-		(header.version & 0x0f),
-		((header.version & 0x0f) == 1) ? "" : "{unsupported}");
-	printf("Internal Use Offset     :0x%02x\n", header.offset.internal);
-	printf("Chassis Info Offset     :0x%02x\n", header.offset.chassis);
-	printf("Board Info Offset       :0x%02x\n", header.offset.board);
-	printf("Product Info Offset     :0x%02x\n", header.offset.product);
-	printf("MultiRecord Offset      :0x%02x\n", header.offset.multi);
-	printf("Common header Checksum  :0x%02x\n", header.checksum);
-
-	fclose(input_file);
-	return OK_STATUS;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_fru_header_detail
-*
-* Description: this function display detail FRU header information
-*               from a FRU binary file.
-
-*
-* Restriction: Reference: IPMI Platform Management FRU Information Storage
-*                  Definition V1.0, Section 8
-*
-* Input: filename: name of FRU binary file
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static int
-ipmi_ek_display_fru_header_detail(char *filename)
-{
-# define FACTOR_OFFSET 8
-# define SIZE_MFG_DATE 3
-	FILE *input_file;
-	size_t file_offset = 0;
-	struct fru_header header;
-	time_t tval;
-	int ret = 0;
-	unsigned char data = 0;
-	unsigned char lan_code = 0;
-	unsigned char mfg_date[SIZE_MFG_DATE];
-	unsigned int board_length = 0;
-
-	input_file = fopen(filename, "r");
-	if (input_file == NULL) {
-		lprintf(LOG_ERR, "File '%s' not found.", filename);
-		return (-1);
-	}
-	/* The offset in each fru is in multiple of 8 bytes
-	 * See IPMI Platform Management FRU Information Storage Definition
-	 * for detail
-	 */
-	ret = fread(&header, sizeof(struct fru_header), 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Failed to read FRU header!");
-		fclose(input_file);
-		return (-1);
-	}
-	/*** Display FRU Internal Use Info ***/
-	if (!feof(input_file)) {
-		unsigned char format_version;
-		unsigned long len = 0;
-
-		printf("%s\n", EQUAL_LINE_LIMITER);
-		printf("FRU Internal Use Info\n");
-		printf("%s\n", EQUAL_LINE_LIMITER);
-
-		ret = fread(&format_version, 1, 1, input_file);
-		if ((ret != 1) || ferror(input_file)) {
-			lprintf(LOG_ERR, "Invalid format version!");
-			fclose(input_file);
-			return (-1);
-		}
-		printf("Format Version: %d\n", (format_version & 0x0f));
-
-		if (header.offset.chassis > 0) {
-			len = (header.offset.chassis * FACTOR_OFFSET)
-				- (header.offset.internal * FACTOR_OFFSET);
-		} else {
-			len = (header.offset.board * FACTOR_OFFSET)
-				- (header.offset.internal * FACTOR_OFFSET);
-		}
-		printf("Length: %ld\n", len);
-		printf("Data dump:\n");
-		while ((len > 0) && (!feof(input_file))) {
-			unsigned char data;
-			ret = fread(&data, 1, 1, input_file);
-			if ((ret != 1) || ferror(input_file)) {
-				lprintf(LOG_ERR, "Invalid data!");
-				fclose(input_file);
-				return (-1);
-			}
-			printf("0x%02x ", data);
-			len--;
-		}
-		printf("\n");
-	}
-	/*** Chassis Info Area ***/
-	if (header.offset.chassis != 0) {
-		long offset = 0;
-		offset = header.offset.chassis * FACTOR_OFFSET;
-		ret = ipmi_ek_display_chassis_info_area(input_file, offset);
-	}
-	/*** Display FRU Board Info Area ***/
-	while (1) {
-		if (header.offset.board == 0) {
-			break;
-		}
-		ret = fseek(input_file,
-				(header.offset.board * FACTOR_OFFSET),
-				SEEK_SET);
-		if (feof(input_file)) {
-			break;
-		}
-		file_offset = ftell(input_file);
-		printf("%s\n", EQUAL_LINE_LIMITER);
-		printf("FRU Board Info Area\n");
-		printf("%s\n", EQUAL_LINE_LIMITER);
-
-		ret = fread(&data, 1, 1, input_file); /* Format version */
-		if ((ret != 1) || ferror(input_file)) {
-			lprintf(LOG_ERR, "Invalid FRU Format Version!");
-			fclose(input_file);
-			return (-1);
-		}
-		printf("Format Version: %d\n", (data & 0x0f));
-		if (feof(input_file)) {
-			break;
-		}
-		ret = fread(&data, 1, 1, input_file); /* Board Area Length */
-		if ((ret != 1) || ferror(input_file)) {
-			lprintf(LOG_ERR, "Invalid Board Area Length!");
-			fclose(input_file);
-			return (-1);
-		}
-		board_length = (data * FACTOR_OFFSET);
-		printf("Area Length: %d\n", board_length);
-		/* Decrease the length of board area by 1 byte of format version
-		 * and 1 byte for area length itself. the rest of this length will
-		 * be used to check for additional custom mfg. byte
-		 */
-		board_length -= 2;
-		if (feof(input_file)) {
-			break;
-		}
-		ret = fread(&lan_code, 1, 1, input_file); /* Language Code */
-		if ((ret != 1) || ferror(input_file)) {
-			lprintf(LOG_ERR, "Invalid Language Code in input");
-			fclose(input_file);
-			return (-1);
-		}
-		printf("Language Code: %d\n", lan_code);
-		board_length--;
-		/* Board Mfg Date */
-		if (feof(input_file)) {
-			break;
-		}
-
-		ret = fread(mfg_date, SIZE_MFG_DATE, 1, input_file);
-		if (ret != 1) {
-			lprintf(LOG_ERR, "Invalid Board Data.");
-			fclose(input_file);
-			return (-1);
-		}
-		tval = ((mfg_date[2] << 16) + (mfg_date[1] << 8)
-				+ (mfg_date[0]));
-		tval = tval * 60;
-		tval = tval + secs_from_1970_1996;
-		printf("Board Mfg Date: %ld, %s", tval,
-				asctime(localtime(&tval)));
-		board_length -= SIZE_MFG_DATE;
-		/* Board Mfg */
-		file_offset = ipmi_ek_display_board_info_area(
-				input_file, "Board Manufacture Data", &board_length);
-		ret = fseek(input_file, file_offset, SEEK_SET);
-		/* Board Product */
-		file_offset = ipmi_ek_display_board_info_area(
-				input_file, "Board Product Name", &board_length);
-		ret = fseek(input_file, file_offset, SEEK_SET);
-		/* Board Serial */
-		file_offset = ipmi_ek_display_board_info_area(
-				input_file, "Board Serial Number", &board_length);
-		ret = fseek(input_file, file_offset, SEEK_SET);
-		/* Board Part */
-		file_offset = ipmi_ek_display_board_info_area(
-				input_file, "Board Part Number", &board_length);
-		ret = fseek(input_file, file_offset, SEEK_SET);
-		/* FRU file ID */
-		file_offset = ipmi_ek_display_board_info_area(
-				input_file, "FRU File ID", &board_length);
-		ret = fseek(input_file, file_offset, SEEK_SET);
-		/* Additional Custom Mfg. */
-		file_offset = ipmi_ek_display_board_info_area(
-				input_file, "Custom", &board_length);
-		break;
-	}
-	/* Product Info Area */
-	if (header.offset.product && (!feof(input_file))) {
-		long offset = 0;
-		offset = header.offset.product * FACTOR_OFFSET;
-		ret = ipmi_ek_display_product_info_area(input_file,
-				offset);
-	}
-	fclose(input_file);
-	return 0;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_chassis_info_area
-*
-* Description: this function displays detail format of product info area record
-*               into humain readable text format
-*
-* Restriction: Reference: IPMI Platform Management FRU Information Storage
-*                  Definition V1.0, Section 10
-*
-* Input: input_file: pointer to file stream
-*         offset: start offset of chassis info area
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static int
-ipmi_ek_display_chassis_info_area(FILE *input_file, long offset)
-{
-	size_t file_offset;
-	int ret = 0;
-	unsigned char data = 0;
-	unsigned char ch_len = 0;
-	unsigned char ch_type = 0;
-	unsigned int len;
-
-	if (input_file == NULL) {
-		lprintf(LOG_ERR, "No file stream to read.");
-		return (-1);
-	}
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	printf("Chassis Info Area\n");
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	ret = fseek(input_file, offset, SEEK_SET);
-	if (feof(input_file)) {
-		lprintf(LOG_ERR, "Invalid Chassis Info Area!");
-		return (-1);
-	}
-	ret = fread(&data, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid Version Number!");
-		return (-1);
-	}
-	printf("Format Version Number: %d\n", (data & 0x0f));
-	ret = fread(&ch_len, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid length!");
-		return (-1);
-	}
-	/* len is in factor of 8 bytes */
-	len = ch_len * 8;
-	printf("Area Length: %d\n", len);
-	len -= 2;
-	if (feof(input_file)) {
-		return (-1);
-	}
-	/* Chassis Type*/
-	ret = fread(&ch_type, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid Chassis Type!");
-		return (-1);
-	}
-	printf("Chassis Type: %d\n", ch_type);
-	len--;
-	/* Chassis Part Number*/
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Chassis Part Number", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Chassis Serial */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Chassis Serial Number", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Custom product info area */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Custom", &len);
-	return 0;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_board_info_area
-*
-* Description: this function displays board info area depending on board type
-*               that pass in argument. Board type can be:
-*               Manufacturer, Serial, Product or Part...
-*
-* Restriction: IPMI Platform Management FRU Information Storage
-*                  Definition V1.0, Section 11
-*
-* Input: input_file: pointer to file stream
-*         board_type: a string that contain board type
-*         board_length: length of info area
-*
-* Output: None
-*
-* Global: None
-*
-* Return: the current position of input_file
-*
-***************************************************************************/
-static size_t
-ipmi_ek_display_board_info_area(FILE *input_file, char *board_type,
-		unsigned int *board_length)
-{
-	size_t file_offset;
-	int ret = 0;
-	unsigned char len = 0;
-	unsigned int size_board = 0;
-	if (input_file == NULL || board_type == NULL
-			|| board_length == NULL) {
-		return (size_t)(-1);
-	}
-	file_offset = ftell(input_file);
-
-	/* Board length*/
-	ret = fread(&len, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid Length!");
-		goto out;
-	}
-	(*board_length)--;
-
-	/* Bit 5:0 of Board Mfg type represent legnth */
-	size_board = (len & 0x3f);
-	if (size_board == 0) {
-		printf("%s: None\n", board_type);
-		goto out;
-	}
-	if (strncmp(board_type, "Custom", 6 ) != 0) {
-		unsigned char *data;
-		unsigned int i = 0;
-		data = malloc(size_board);
-		if (data == NULL) {
-			lprintf(LOG_ERR, "ipmitool: malloc failure");
-			return (size_t)(-1);
-		}
-		ret = fread(data, size_board, 1, input_file);
-		if ((ret != 1) || ferror(input_file)) {
-			lprintf(LOG_ERR, "Invalid board type size!");
-			free(data);
-			data = NULL;
-			goto out;
-		}
-		printf("%s type: 0x%02x\n", board_type, len);
-		printf("%s: ", board_type);
-		for (i = 0; i < size_board; i++) {
-			if ((len & TYPE_CODE) == TYPE_CODE) {
-				printf("%c", data[i]);
-			} else {
-				/* other than language code (binary, BCD,
-				 * ASCII 6 bit...) is not supported
-				 */
-				printf("%02x", data[i]);
-			}
-		}
-		printf("\n");
-		free(data);
-		data = NULL;
-		(*board_length) -= size_board;
-		goto out;
-	}
-	while (!feof(input_file)) {
-		if (len == NO_MORE_INFO_FIELD) {
-			unsigned char padding;
-			unsigned char checksum = 0;
-			/* take the rest of data in the area minus 1 byte of 
-			 * checksum
-			 */
-			printf("Additional Custom Mfg. length: 0x%02x\n", len);
-			padding = (*board_length) - 1;
-			if ((padding > 0) && (!feof(input_file))) {
-				printf("Unused space: %d (bytes)\n", padding);
-				fseek(input_file, padding, SEEK_CUR);
-			}
-			ret = fread(&checksum, 1, 1, input_file);
-			if ((ret != 1) || ferror(input_file)) {
-				lprintf(LOG_ERR, "Invalid Checksum!");
-				goto out;
-			}
-			printf("Checksum: 0x%02x\n", checksum);
-			goto out;
-		}
-		printf("Additional Custom Mfg. length: 0x%02x\n", len);
-		if ((size_board > 0) && (size_board < (*board_length))) {
-			unsigned char * additional_data = NULL;
-			unsigned int i = 0;
-			additional_data = malloc(size_board);
-			if (additional_data == NULL) {
-				lprintf(LOG_ERR, "ipmitool: malloc failure");
-				return (size_t)(-1);
-			}
-				
-			ret = fread(additional_data, size_board, 1, input_file);
-			if ((ret != 1) || ferror(input_file)) {
-				lprintf(LOG_ERR, "Invalid Additional Data!");
-				if (additional_data != NULL) {
-					free(additional_data);
-					additional_data = NULL;
-				}
-				goto out;
-			}
-			printf("Additional Custom Mfg. Data: %02x",
-					additional_data[0]);
-			for (i = 1; i < size_board; i++) {
-				printf("-%02x", additional_data[i]);
-			}
-			printf("\n");
-			free(additional_data);
-			additional_data = NULL;
-			(*board_length) -= size_board;
-		}
-		else {
-			printf("No Additional Custom Mfg. %d\n", *board_length);
-			goto out;
-		}
-	}
- 
-out:
-	file_offset = ftell(input_file);
-	return file_offset;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_product_info_area
-*
-* Description: this function displays detail format of product info area record
-*               into humain readable text format
-*
-* Restriction: Reference: IPMI Platform Management FRU Information Storage
-*                  Definition V1.0, Section 12
-*
-* Input: input_file: pointer to file stream
-*         offset: start offset of product info area
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static int
-ipmi_ek_display_product_info_area(FILE *input_file, long offset)
-{
-	size_t file_offset;
-	int ret = 0;
-	unsigned char ch_len = 0;
-	unsigned char data = 0;
-	unsigned int len = 0;
-
-	if (input_file == NULL) {
-		lprintf(LOG_ERR, "No file stream to read.");
-		return (-1);
-	}
-	file_offset = ftell(input_file);
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	printf("Product Info Area\n");
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	ret = fseek(input_file, offset, SEEK_SET);
-	if (feof(input_file)) {
-		lprintf(LOG_ERR, "Invalid Product Info Area!");
-		return (-1);
-	}
-	ret = fread(&data, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid Data!");
-		return (-1);
-	}
-	printf("Format Version Number: %d\n", (data & 0x0f));
-	if (feof(input_file)) {
-		return (-1);
-	}
-	/* Have to read this into a char or else
-	 * it ends up byte swapped on big endian machines */
-	ret = fread(&ch_len, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid Length!");
-		return (-1);
-	}
-	/* length is in factor of 8 bytes */
-	len = ch_len * 8;
-	printf("Area Length: %d\n", len);
-	len -= 2; /* -1 byte of format version and -1 byte itself */
-
-	ret = fread(&data, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid Length!");
-		return (-1);
-	}
-
-	fread(&data, 1, 1, input_file);
-	printf("Language Code: %d\n", data);
-	len--;
-	/* Product Mfg */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Product Manufacture Data", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Product Name */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Product Name", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Product Part */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Product Part/Model Number", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Product Version */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Product Version", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Product Serial */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Product Serial Number", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Product Asset Tag */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Asset Tag", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* FRU file ID */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"FRU File ID", &len);
-	ret = fseek(input_file, file_offset, SEEK_SET);
-	/* Custom product info area */
-	file_offset = ipmi_ek_display_board_info_area(input_file,
-			"Custom", &len);
-	return 0;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_record
-*
-* Description: this function displays FRU multi record information.
-*
-* Restriction: None
-*
-* Input: record: a pointer to current record
-*        list_head: a pointer to header of the list
-*        list_last: a pointer to tale of the list
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_record(struct ipmi_ek_multi_header *record,
-		struct ipmi_ek_multi_header *list_head,
-		struct ipmi_ek_multi_header *list_last)
-{
-	if (list_head == NULL) {
-		printf("***empty list***\n");
-		return;
-	}
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	printf("FRU Multi Info area\n");
-	printf("%s\n", EQUAL_LINE_LIMITER);
-	for (record = list_head; record != NULL; record = record->next) {
-		printf("Record Type ID: 0x%02x\n", record->header.type);
-		printf("Record Format version: 0x%02x\n",
-				record->header.format);
-		if (record->header.len <= PICMG_ID_OFFSET) {
-			continue;
-		}
-		/* In picmg3.0 specification, picmg record
-		 * id lower than 4 or greater than 0x2d
-		 * isn't supported
-		 */
-		#define PICMG_ID_LOWER_LIMIT  0x04
-		#define PICMG_ID_UPPER_LIMIT  0x2d
-		unsigned char picmg_id;
-
-		picmg_id = record->data[PICMG_ID_OFFSET];
-		printf("Manufacturer ID: %02x%02x%02x h\n",
-				record->data[2], record->data[1],
-				record->data[0]);
-		if ((picmg_id < PICMG_ID_LOWER_LIMIT)
-				|| (picmg_id > PICMG_ID_UPPER_LIMIT)) {
-			printf("Picmg record ID: Unsupported {0x%02x}\n", picmg_id);
-		} else {
-			printf("Picmg record ID: %s {0x%02x}\n",
-					val2str(picmg_id, ipmi_ekanalyzer_picmg_record_id),
-					picmg_id);
-		}
-		switch (picmg_id) {
-		case FRU_PICMG_BACKPLANE_P2P: /*0x04*/
-			ipmi_ek_display_backplane_p2p_record (record);
-			break;
-		case FRU_PICMG_ADDRESS_TABLE: /*0x10*/
-			ipmi_ek_display_address_table_record (record);
-			break;
-		case FRU_PICMG_SHELF_POWER_DIST: /*0x11*/
-			ipmi_ek_display_shelf_power_distribution_record (record);
-			break;
-		case FRU_PICMG_SHELF_ACTIVATION: /*/0x12*/
-			ipmi_ek_display_shelf_activation_record (record);
-			break;
-		case FRU_PICMG_SHMC_IP_CONN: /*0x13*/
-			ipmi_ek_display_shelf_ip_connection_record (record);
-			break;
-		case FRU_PICMG_BOARD_P2P: /*0x14*/
-			ipmi_ek_display_board_p2p_record (record);
-			break;
-		case FRU_RADIAL_IPMB0_LINK_MAPPING: /*0x15*/
-			ipmi_ek_display_radial_ipmb0_record (record);
-			break;
-		case FRU_AMC_CURRENT: /*0x16*/
-			ipmi_ek_display_amc_current_record (record);
-			break;
-		case FRU_AMC_ACTIVATION: /*0x17*/
-			ipmi_ek_display_amc_activation_record (record);
-			break;
-		case FRU_AMC_CARRIER_P2P: /*0x18*/
-			ipmi_ek_display_carrier_connectivity (record);
-			break;
-		case FRU_AMC_P2P: /*0x19*/
-			ipmi_ek_display_amc_p2p_record (record);
-			break;
-		case FRU_AMC_CARRIER_INFO: /*0x1a*/
-			ipmi_ek_display_amc_carrier_info_record (record);
-			break;
-		case FRU_PICMG_CLK_CARRIER_P2P: /*0x2c*/
-			ipmi_ek_display_clock_carrier_p2p_record (record);
-			break;
-		case FRU_PICMG_CLK_CONFIG: /*0x2d*/
-			ipmi_ek_display_clock_config_record (record);
-			break;
-		default:
-			if (verbose > 0) {
-				int i;
-				printf("%02x %02x %02x %02x %02x ",
-						record->header.type,
-						record->header.format,
-						record->header.len,
-						record->header.record_checksum,
-						record->header.header_checksum);
-				for (i = 0; i < record->header.len; i++) {
-					printf("%02x ", record->data[i]);
-				}
-				printf("\n");
-			}
-			break;
-		}
-		printf("%s\n", STAR_LINE_LIMITER);
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_backplane_p2p_record
-*
-* Description: this function displays backplane p2p record.
-*
-* Restriction: Reference: PICMG 3.0 Specification Table 3-40
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_backplane_p2p_record(struct ipmi_ek_multi_header *record)
-{
-	uint8_t index;
-	int offset = START_DATA_OFFSET;
-	struct fru_picmgext_slot_desc *slot_d =
-		(struct fru_picmgext_slot_desc*)&record->data[offset];
-
-	offset += sizeof(struct fru_picmgext_slot_desc);
-	while (offset <= record->header.len) {
-		printf("   Channel Type: ");
-		switch (slot_d->chan_type) {
-		case 0x00:
-		case 0x07:
-			printf("PICMG 2.9\n");
-			break;
-		case 0x08:
-			printf("Single Port Fabric IF\n");
-			break;
-		case 0x09:
-			printf("Double Port Fabric IF\n");
-			break;
-		case 0x0a:
-			printf("Full Channel Fabric IF\n");
-			break;
-		case 0x0b:
-			printf("Base IF\n");
-			break;
-		case 0x0c:
-			printf("Update Channel IF\n");
-			break;
-		default:
-			printf("Unknown IF\n");
-			break;
-		}
-		printf("   Slot Address:  %02x\n", slot_d->slot_addr);
-		printf("   Channel Count: %i\n", slot_d->chn_count);
-		for (index = 0; index < (slot_d->chn_count); index++) {
-			struct fru_picmgext_chn_desc *d =
-				(struct fru_picmgext_chn_desc *)&record->data[offset];
-			if (verbose) {
-				printf("\t"
-						"Chn: %02x   -->   "
-						"Chn: %02x in "
-						"Slot: %02x\n",
-						d->local_chn,
-						d->remote_chn,
-						d->remote_slot);
-			}
-			offset += sizeof(struct fru_picmgext_chn_desc);
-		}
-		slot_d = (struct fru_picmgext_slot_desc*)&record->data[offset];
-		offset += sizeof(struct fru_picmgext_slot_desc);
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_address_table_record
-*
-* Description: this function displays address table record.
-*
-* Restriction: Reference: PICMG 3.0 Specification Table 3-6
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_address_table_record(struct ipmi_ek_multi_header *record)
-{
-#define SIZE_SHELF_ADDRESS_BYTE 20
-	unsigned char entries = 0;
-	unsigned char i;
-	int offset = START_DATA_OFFSET;
-
-	printf("   Type/Len:    0x%02x\n", record->data[offset++]);
-	printf("   Shelf Addr: ");
-	for (i = 0; i < SIZE_SHELF_ADDRESS_BYTE; i++) {
-		printf("0x%02x ", record->data[offset++]);
-	}
-	printf("\n");
-	entries = record->data[offset++];
-	printf("   Addr Table Entries count: 0x%02x\n", entries);
-	for (i = 0; i < entries; i++) {
-		printf("\tHWAddr: 0x%02x  - SiteNum: 0x%02x - SiteType: 0x%02x \n",
-				record->data[offset+0],
-				record->data[offset+1],
-				record->data[offset+2]);
-		offset += 3;
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_shelf_power_distribution_record
-*
-* Description: this function displays shelf power distribution record.
-*
-* Restriction: Reference: PICMG 3.0 Specification Table 3-70
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_shelf_power_distribution_record(
-		struct ipmi_ek_multi_header *record)
-{
-	int offset = START_DATA_OFFSET;
-	unsigned char i;
-	unsigned char j;
-	unsigned char feeds = 0;
-
-	feeds = record->data[offset++];
-	printf("   Number of Power Feeds: 0x%02x\n", feeds);
-	for (i = 0; i < feeds; i++) {
-		unsigned char entries;
-		unsigned long max_ext = 0;
-		unsigned long max_int = 0;
-		max_ext = record->data[offset+0]
-			| (record->data[offset+1] << 8);
-		printf("   Max External Available Current: %ld Amps\n",
-				(max_ext * 10));
-		offset += 2;
-		max_int = record->data[offset+0]
-			| (record->data[offset+1] << 8);
-		printf("   Max Internal Current:\t   %ld Amps\n",
-				(max_int * 10));
-		offset += 2;
-		printf("   Min Expected Operating Voltage: %d Volts\n",
-				(record->data[offset++] / 2));
-		entries = record->data[offset++];
-		printf("   Feed to FRU count: 0x%02x\n", entries);
-		for (j = 0; j < entries; j++) {
-			printf("\tHW: 0x%02x", record->data[offset++]);
-			printf("\tFRU ID: 0x%02x\n", record->data[offset++]);
-		}
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_shelf_activation_record
-*
-* Description: this function displays shelf activation record.
-*
-* Restriction: Reference: PICMG 3.0 Specification Table 3-73
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_shelf_activation_record(struct ipmi_ek_multi_header *record)
-{
-	unsigned char count = 0;
-	int offset = START_DATA_OFFSET;
-
-	printf("   Allowance for FRU Act Readiness: 0x%02x\n",
-			record->data[offset++]);
-	count = record->data[offset++];
-	printf("   FRU activation and Power Desc Cnt: 0x%02x\n", count);
-	while (count > 0) {
-		printf("   FRU activation and Power descriptor:\n");
-		printf("\tHardware Address:\t\t0x%02x\n",
-				record->data[offset++]);
-		printf("\tFRU Device ID:\t\t\t0x%02x\n",
-				record->data[offset++]);
-		printf("\tMax FRU Power Capability:\t0x%04x Watts\n",
-				(record->data[offset+0]
-				 | (record->data[offset+1]<<8)));
-		offset += 2;
-		printf("\tConfiguration parameter:\t0x%02x\n",
-				record->data[offset++]);
-		count --;
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_shelf_ip_connection_record
-*
-* Description: this function displays shelf ip connection record.
-*
-* Restriction: Fix me: Don't test yet
-*               Reference: PICMG 3.0 Specification Table 3-31
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_shelf_ip_connection_record(struct ipmi_ek_multi_header *record)
-{
-	int ioffset = START_DATA_OFFSET;
-	if (ioffset > record->header.len) {
-		printf("   Shelf Manager IP Address: %d.%d.%d.%d\n",
-				record->data[ioffset+0],
-				record->data[ioffset+1],
-				record->data[ioffset+2],
-				record->data[ioffset+3]);
-		ioffset += 4;
-	}
-	if (ioffset > record->header.len) {
-		printf("   Default Gateway Address: %d.%d.%d.%d\n",
-				record->data[ioffset+0],
-				record->data[ioffset+1],
-				record->data[ioffset+2],
-				record->data[ioffset+3]);
-		ioffset += 4;
-	}
-	if (ioffset > record->header.len) {
-		printf("   Subnet Mask: %d.%d.%d.%d\n", 
-				record->data[ioffset+0],
-				record->data[ioffset+1],
-				record->data[ioffset+2],
-				record->data[ioffset+3]);
-		ioffset += 4;
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_shelf_fan_geography_record
-*
-* Description: this function displays shelf fan geography record.
-*
-* Restriction: Fix me: Don't test yet
-*               Reference: PICMG 3.0 Specification Table 3-75
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_shelf_fan_geography_record(struct ipmi_ek_multi_header *record)
-{
-	int ioffset = START_DATA_OFFSET;
-	unsigned char fan_count = 0;
-
-	fan_count = record->data[ioffset];
-	ioffset++;
-	printf("   Fan-to-FRU Entry Count: 0x%02x\n", fan_count);
-	while ((fan_count > 0) && (ioffset <= record->header.len)) {
-		printf("   Fan-to-FRU Mapping Entry: {%2x%2x%2x%2x}\n",
-				record->data[ioffset],
-				record->data[ioffset+1],
-				record->data[ioffset+2],
-				record->data[ioffset+3]);
-		printf("      Hardware Address:   0x%02x\n",
-				record->data[ioffset++]);
-		printf("      FRU device ID:   0x%02x\n",
-				record->data[ioffset++]);
-		printf("      Site Number:   0x%02x\n",
-				record->data[ioffset++]);
-		printf("      Site Type:   0x%02x\n",
-				record->data[ioffset++]);
-		fan_count --;
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_board_p2p_record
-*
-* Description: this function displays board pont-to-point record.
-*
-* Restriction: Reference: PICMG 3.0 Specification Table 3-44
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_board_p2p_record(struct ipmi_ek_multi_header *record)
-{
-	unsigned char guid_count;
-	int offset = START_DATA_OFFSET;
-	int i = 0;
-
-	guid_count = record->data[offset++];
-	printf("   GUID count: %2d\n", guid_count);
-	for (i = 0 ; i < guid_count; i++) {
-		int j;
-		printf("\tGUID: ");
-		for (j = 0; j < sizeof(struct fru_picmgext_guid); j++) {
-			printf("%02x", record->data[offset+j]);
-		}
-		printf("\n");
-		offset += sizeof(struct fru_picmgext_guid);
-	}
-	for (offset;
-			offset < record->header.len;
-			offset += sizeof(struct fru_picmgext_link_desc)) {
-		/* to solve little endian/big endian problem */
-		unsigned long data;
-		struct fru_picmgext_link_desc * d;
-		data = (record->data[offset+0])
-			| (record->data[offset+1] << 8)\
-			| (record->data[offset+2] << 16)\
-			| (record->data[offset+3] << 24);
-		d = (struct fru_picmgext_link_desc *)&data;
-
-		printf("   Link Descriptor\n");
-		printf("\tLink Grouping ID:\t0x%02x\n", d->grouping);
-		printf("\tLink Type Extension:\t0x%02x - ", d->ext);
-		if (d->type == FRU_PICMGEXT_LINK_TYPE_BASE) {
-			switch (d->ext) {
-			case 0:
-				printf("10/100/1000BASE-T Link (four-pair)\n");
-				break;
-			case 1:
-				printf("ShMC Cross-connect (two-pair)\n");
-				break;
-			default:
-				printf("Unknwon\n");
-				break;
-			}
-		} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET) {
-			switch (d->ext) {
-			case 0:
-				printf("Fixed 1000Base-BX\n");
-				break;
-			case 1:
-				printf("Fixed 10GBASE-BX4 [XAUI]\n");
-				break;
-			case 2:
-				printf("FC-PI\n");
-				break;
-			default:
-				printf("Unknwon\n");
-				break;
-			}
-		} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_INFINIBAND) {
-			printf("Unknwon\n");
-		} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_STAR) {
-			printf("Unknwon\n");
-		} else if (d->type == FRU_PICMGEXT_LINK_TYPE_PCIE) {
-			printf("Unknwon\n");
-		} else {
-			printf("Unknwon\n");
-		}
-		printf("\tLink Type:\t\t0x%02x - ", d->type);
-		if (d->type == 0 || d->type == 0xff) {
-			printf("Reserved\n");
-		} else if (d->type >= 0x06 && d->type <= 0xef) {
-			printf("Reserved\n");
-		} else if (d->type >= LOWER_OEM_TYPE && d->type <= UPPER_OEM_TYPE) {
-			printf("OEM GUID Definition\n");
-		} else {
-			switch (d->type){
-			case FRU_PICMGEXT_LINK_TYPE_BASE:
-				printf("PICMG 3.0 Base Interface 10/100/1000\n");
-				break;
-			case FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET:
-				printf("PICMG 3.1 Ethernet Fabric Interface\n");
-				break;
-			case FRU_PICMGEXT_LINK_TYPE_FABRIC_INFINIBAND:
-				printf("PICMG 3.2 Infiniband Fabric Interface\n");
-				break;
-			case FRU_PICMGEXT_LINK_TYPE_FABRIC_STAR:
-				printf("PICMG 3.3 Star Fabric Interface\n");
-				break;
-			case FRU_PICMGEXT_LINK_TYPE_PCIE:
-				printf("PICMG 3.4 PCI Express Fabric Interface\n");
-				break;
-			default:
-				printf("Invalid\n");
-				break;
-			}
-		}
-		printf("\tLink Designator: \n");
-		printf("\t   Port 0 Flag:   %s\n",
-				(d->desig_port & 0x01) ? "enable" : "disable");
-		printf("\t   Port 1 Flag:   %s\n",
-				(d->desig_port & 0x02) ? "enable" : "disable");
-		printf("\t   Port 2 Flag:   %s\n",
-				(d->desig_port & 0x04) ? "enable" : "disable");
-		printf("\t   Port 3 Flag:   %s\n",
-				(d->desig_port & 0x08) ? "enable" : "disable");
-		printf("\t   Interface:    0x%02x - ", d->desig_if);
-		switch (d->desig_if) {
-		case FRU_PICMGEXT_DESIGN_IF_BASE:
-			printf("Base Interface\n");
-			break;
-		case FRU_PICMGEXT_DESIGN_IF_FABRIC:
-			printf("Fabric Interface\n");
-			break;
-		case FRU_PICMGEXT_DESIGN_IF_UPDATE_CHANNEL:
-			printf("Update Channel\n");
-			break;
-		case FRU_PICMGEXT_DESIGN_IF_RESERVED:
-			printf("Reserved\n");
-			break;
-		default:
-			printf("Invalid");
-			break;
-		}
-		printf("\t   Channel Number:    0x%02x\n",
-				d->desig_channel);
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_radial_ipmb0_record
-*
-* Description: this function displays radial IPMB-0 record.
-*
-* Restriction: Fix me: Don't test yet
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_radial_ipmb0_record(struct ipmi_ek_multi_header *record)
-{
-#define SIZE_OF_CONNECTOR_DEFINER  3; /*bytes*/
-	int offset = START_DATA_OFFSET;
-	/* Ref: PICMG 3.0 Specification Revision 2.0, Table 3-59 */
-	printf("   IPMB-0 Connector Definer: ");
-#ifndef WORDS_BIGENDIAN
-	printf("%02x %02x %02x h\n", record->data[offset],
-			record->data[offset+1], record->data[offset+2]);
-#else
-	printf("%02x %02x %02x h\n", record->data[offset+2],
-			record->data[offset+1], record->data[offset]);
-#endif
-	/* 3 bytes of connector definer was used */
-	offset += SIZE_OF_CONNECTOR_DEFINER;
-	printf("   IPMB-0 Connector version ID: ");
-#ifndef WORDS_BIGENDIAN
-	printf("%02x %02x h\n", record->data[offset],
-			record->data[offset+1]);
-#else
-	printf("%02x %02x h\n", record->data[offset+1],
-			record->data[offset]);
-#endif
-	offset += 2;
-	printf("   IPMB-0 Hub Descriptor Count: 0x%02x",
-			record->data[offset++]);
-	if (record->data[offset] < 1) {
-		return;
-	}
-	for (offset; offset < record->header.len;) {
-		unsigned char entry_count = 0;
-		printf("   IPMB-0 Hub Descriptor\n");
-		printf("\tHardware Address: 0x%02x\n",
-				record->data[offset++]);
-		printf("\tHub Info {0x%02x}: ", record->data[offset]);
-		/* Bit mask specified in Table 3-59
-		 * of PICMG 3.0 Specification
-		 */
-		if ((record->data[offset] & 0x01) == 0x01) {
-			printf("IPMB-A only\n");
-		} else if ((record->data[offset] & 0x02) == 0x02) {
-			printf("IPMB-B only\n");
-		} else if ((record->data[offset] & 0x03) == 0x03) {
-			printf("IPMB-A and IPMB-B\n");
-		} else {
-			printf("Reserved.\n");
-		}
-		offset ++;
-		entry_count = record->data[offset++];
-		printf("\tAddress Entry count: 0x%02x", entry_count);
-		while (entry_count > 0) {
-			printf("\t   Hardware Address: 0x%02x\n",
-					record->data[offset++]);
-			printf("\t   IPMB-0 Link Entry: 0x%02x\n",
-					record->data[offset++]);
-			entry_count --;
-		}
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_amc_current_record
-*
-* Description: this function displays AMC current record.
-*
-* Restriction: None
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_amc_current_record(struct ipmi_ek_multi_header *record)
-{
-	unsigned char current;
-	current = record->data[START_DATA_OFFSET];
-	printf("   Current draw: %.1f A @ 12V => %.2f Watt\n",
-			(float)current / 10.0,
-			((float)current / 10.0) * 12.0);
-	printf("\n");
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_amc_activation_record
-*
-* Description: this function displays carrier activation and current management
-*             record.
-*
-* Restriction: Reference: AMC.0 Specification Table 3-11 and Table 3-12
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_amc_activation_record(struct ipmi_ek_multi_header *record)
-{
-	uint16_t max_current;
-	int offset = START_DATA_OFFSET;
-
-	max_current = record->data[offset];
-	max_current |= record->data[++offset] << 8;
-	printf("   Maximum Internal Current(@12V): %.2f A [ %.2f Watt ]\n",
-			(float) max_current / 10,
-			(float) max_current / 10 * 12);
-	printf("   Module Activation Readiness:    %i sec.\n",
-			record->data[++offset]);
-	printf("   Descriptor Count: %i\n", record->data[++offset]);
-	for (++offset; (offset < record->header.len); offset += 3) {
-		struct fru_picmgext_activation_record *a =
-			(struct fru_picmgext_activation_record *)&record->data[offset];
-		printf("\tIPMB-Address:\t\t0x%x\n", a->ibmb_addr);
-		printf("\tMax. Module Current:\t%.2f A\n",
-				(float)a->max_module_curr / 10);
-		printf("\n");
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_amc_p2p_record
-*
-* Description: this function display amc p2p connectivity record in humain
-*              readable text format
-*
-* Restriction: Reference: AMC.0 Specification Table 3-16
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_amc_p2p_record(struct ipmi_ek_multi_header *record)
-{
-	int index_data = START_DATA_OFFSET;
-	int oem_count = 0;
-	int ch_count = 0;
-	int index=0;
-
-	oem_count = record->data[index_data++];
-	printf("OEM GUID count: %02x\n", oem_count);
-	if (oem_count > 0) {
-		while (oem_count > 0) {
-			printf("OEM GUID: ");
-			for (index = 1; index <= SIZE_OF_GUID; index++) {
-				printf("%02x", record->data[index_data++]);
-				/* For a better look, display a "-" character
-				 * after each 5 bytes of OEM GUID
-				 */
-				if (!(index % 5)) {
-					printf("-");
-				}
-			}
-			printf("\n");
-			oem_count--;
-		}
-	}
-	if ((record->data[index_data] & AMC_MODULE) == AMC_MODULE) {
-		printf("AMC module connection\n");
-	} else {
-		printf("On-Carrier Device %02x h\n",
-				(record->data[index_data] & 0x0f));
-	}
-	index_data ++;
-	ch_count = record->data[index_data++];
-	printf("AMC Channel Descriptor count: %02x h\n", ch_count);
-
-	if (ch_count > 0) {
-		for (index = 0; index < ch_count; index++) {
-			unsigned int data;
-			struct fru_picmgext_amc_channel_desc_record *ch_desc;
-			printf("   AMC Channel Descriptor {%02x%02x%02x}\n",
-					record->data[index_data+2],
-					record->data[index_data+1],
-					record->data[index_data]);
-			data = record->data[index_data]
-				| (record->data[index_data + 1] << 8)
-				| (record->data[index_data + 2] << 16);
-			ch_desc = (struct fru_picmgext_amc_channel_desc_record *)&data;
-			printf("      Lane 0 Port: %d\n", ch_desc->lane0port);
-			printf("      Lane 1 Port: %d\n", ch_desc->lane1port);
-			printf("      Lane 2 Port: %d\n", ch_desc->lane2port);
-			printf("      Lane 3 Port: %d\n\n", ch_desc->lane3port);
-			index_data += FRU_PICMGEXT_AMC_CHANNEL_DESC_RECORD_SIZE;
-		}
-	}
-	while (index_data < record->header.len) {
-		/* Warning: This code doesn't work with gcc version
-		 * between 4.0 and 4.3
-		 */
-		unsigned int data[2];
-		struct fru_picmgext_amc_link_desc_record *link_desc;
-		data[0] = record->data[index_data]
-			| (record->data[index_data + 1] << 8)
-			| (record->data[index_data + 2] << 16)
-			| (record->data[index_data + 3] << 24);
-		data[1] = record->data[index_data + 4];
-
-		link_desc = (struct fru_picmgext_amc_link_desc_record *)&data[0];
-		printf("   AMC Link Descriptor:\n");
-		printf("\t- Link Type: %s \n",
-				val2str(link_desc->type, ipmi_ekanalyzer_link_type));
-		switch (link_desc->type) {
-		case FRU_PICMGEXT_AMC_LINK_TYPE_PCIE:
-		case FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS1:
-		case FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS2:
-			printf("\t- Link Type extension: %s\n",
-					val2str(link_desc->type_ext,
-						ipmi_ekanalyzer_extension_PCIE));
-			printf("\t- Link Group ID: %d\n ",
-					link_desc->group_id);
-			printf("\t- Link Asym. Match: %d - %s\n",
-					link_desc->asym_match, 
-					val2str(link_desc->asym_match,
-						ipmi_ekanalyzer_asym_PCIE));
-			break;
-		case FRU_PICMGEXT_AMC_LINK_TYPE_ETHERNET:
-			printf("\t- Link Type extension: %s\n",
-					val2str (link_desc->type_ext,
-						ipmi_ekanalyzer_extension_ETHERNET));
-			printf("\t- Link Group ID: %d \n",
-					link_desc->group_id);
-			printf("\t- Link Asym. Match: %d - %s\n",
-					link_desc->asym_match, 
-					val2str(link_desc->asym_match,
-						ipmi_ekanalyzer_asym_PCIE));
-			break;
-		case FRU_PICMGEXT_AMC_LINK_TYPE_STORAGE:
-			printf("\t- Link Type extension: %s\n",
-					val2str (link_desc->type_ext,
-						ipmi_ekanalyzer_extension_STORAGE));
-			printf("\t- Link Group ID: %d \n",
-					link_desc->group_id);
-			printf("\t- Link Asym. Match: %d - %s\n",
-					link_desc->asym_match, 
-					val2str(link_desc->asym_match,
-						ipmi_ekanalyzer_asym_STORAGE));
-			break;
-		default:
-			printf("\t- Link Type extension: %i (Unknown)\n",
-					link_desc->type_ext);
-			printf("\t- Link Group ID: %d \n",
-					link_desc->group_id);
-			printf("\t- Link Asym. Match: %i\n",
-					link_desc->asym_match);
-			break;
-		}
-		printf("\t- AMC Link Designator:\n");
-		printf("\t    Channel ID: %i\n", link_desc->channel_id);
-		printf("\t\t Lane 0: %s\n",
-				(link_desc->port_flag_0) ? "enable" : "disable");
-		printf("\t\t Lane 1: %s\n",
-				(link_desc->port_flag_1) ? "enable" : "disable");
-		printf("\t\t Lane 2: %s\n",
-				(link_desc->port_flag_2) ? "enable" : "disable");
-		printf("\t\t Lane 3: %s\n",
-				(link_desc->port_flag_3) ? "enable" : "disable");
-		index_data += FRU_PICMGEXT_AMC_LINK_DESC_RECORD_SIZE;
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_amc_carrier_info_record
-*
-* Description: this function displays Carrier information table.
-*
-* Restriction: Reference: AMC.0 Specification Table 3-3
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: START_DATA_OFFSET
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_amc_carrier_info_record(struct ipmi_ek_multi_header *record)
-{
-	unsigned char extVersion;
-	unsigned char siteCount;
-	int offset = START_DATA_OFFSET;
-
-	extVersion = record->data[offset++];
-	siteCount  = record->data[offset++];
-	printf("   AMC.0 extension version: R%d.%d\n",
-			(extVersion >> 0) & 0x0F,
-			(extVersion >> 4) & 0x0F);
-	printf("   Carrier Sie Number Count: %d\n", siteCount);
-	while (siteCount > 0) {
-		printf("\tSite ID (%d): %s \n", record->data[offset],
-				val2str(record->data[offset], ipmi_ekanalyzer_module_type));
-		offset++;
-		siteCount--;
-	}
-	printf("\n");
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_clock_carrier_p2p_record
-*
-* Description: this function displays Carrier clock point-to-pont
-*              connectivity record.
-*
-* Restriction: the following code is copy from ipmi_fru.c with modification in
-*               reference to AMC.0 Specification Table 3-29
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_display_clock_carrier_p2p_record(struct ipmi_ek_multi_header *record)
-{
-	unsigned char desc_count;
-	int i;
-	int j;
-	int offset = START_DATA_OFFSET;
-
-	desc_count = record->data[offset++];
-	for(i = 0; i < desc_count; i++) {
-		unsigned char resource_id;
-		unsigned char channel_count;
-
-		resource_id = record->data[offset++];
-		channel_count = record->data[offset++];
-
-		printf("   Clock Resource ID: 0x%02x\n", resource_id);
-		printf("   Type: ");
-		if ((resource_id & 0xC0) >> 6 == 0) {
-			printf("On-Carrier-Device\n");
-		} else if ((resource_id & 0xC0) >> 6 == 1) {
-			printf("AMC slot\n");
-		} else if ((resource_id & 0xC0) >> 6 == 2) {
-			printf("Backplane\n");
-		} else{
-			printf("reserved\n");
-		}
-		printf("   Channel Count: 0x%02x\n", channel_count);
-
-		for (j = 0; j < channel_count; j++) {
-			unsigned char loc_channel;
-			unsigned char rem_channel;
-			unsigned char rem_resource;
-
-			loc_channel = record->data[offset++];
-			rem_channel = record->data[offset++];
-			rem_resource = record->data[offset++];
-
-			printf("\tCLK-ID: 0x%02x   --->  ", loc_channel);
-			printf(" remote CLKID: 0x%02x   ", rem_channel);
-			if ((rem_resource & 0xC0) >> 6 == 0) {
-				printf("[ Carrier-Dev");
-			} else if ((rem_resource & 0xC0) >> 6 == 1) {
-				printf("[ AMC slot    ");
-			} else if ((rem_resource & 0xC0) >> 6 == 2) {
-				printf("[ Backplane    ");
-			} else {
-				printf("reserved          ");
-			}
-			printf(" 0x%02x ]\n", rem_resource & 0xF);
-		}
-	}
-	printf("\n");
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_display_clock_config_record
-*
-* Description: this function displays clock configuration record.
-*
-* Restriction: the following codes are copy from ipmi_fru.c with modification
-*               in reference to AMC.0 Specification Table 3-35 and Table 3-36
-*
-* Input: record: a pointer to current record to be displayed
-*
-* Output: None
-*
-* Global: START_DATA_OFFSET
-*
-* Return: None
-*
-***************************************************************************/
-void
-ipmi_ek_display_clock_config_record(struct ipmi_ek_multi_header *record)
-{
-	unsigned char resource_id;
-	unsigned char descr_count;
-	int i;
-	int offset = START_DATA_OFFSET;
-
-	resource_id = record->data[offset++];
-	descr_count = record->data[offset++];
-	printf("   Clock Resource ID: 0x%02x\n", resource_id);
-	printf("   Clock Configuration Descriptor Count: 0x%02x\n", descr_count);
-
-	for (i = 0; i < descr_count; i++) {
-		int j = 0;
-		unsigned char channel_id;
-		unsigned char control;
-		unsigned char indirect_cnt;
-		unsigned char direct_cnt;
-
-		channel_id = record->data[offset++];
-		control = record->data[offset++];
-		printf("\tCLK-ID: 0x%02x  -  ", channel_id);
-		printf("CTRL 0x%02x [ %12s ]\n", control,
-				((control & 0x1) == 0) ? "Carrier IPMC" : "Application");
-
-		indirect_cnt = record->data[offset++];
-		direct_cnt = record->data[offset++];
-		printf("\t   Count: Indirect 0x%02x   / Direct 0x%02x\n",
-				indirect_cnt,
-				direct_cnt);
-
-		/* indirect desc */
-		for (j = 0; j < indirect_cnt; j++) {
-			unsigned char feature;
-			unsigned char dep_chn_id;
-
-			feature = record->data[offset++];
-			dep_chn_id = record->data[offset++];
-			printf("\t\tFeature: 0x%02x [%8s] - ",
-					feature,
-					(feature & 0x1) == 1 ? "Source" : "Receiver");
-			printf(" Dep. CLK-ID: 0x%02x\n", dep_chn_id);
-		}
-		/* direct desc */
-		for (j = 0; j < direct_cnt; j++) {
-			unsigned char feature;
-			unsigned char family;
-			unsigned char accuracy;
-			unsigned long freq;
-			unsigned long min_freq;
-			unsigned long max_freq;
-
-			feature = record->data[offset++];
-			family = record->data[offset++];
-			accuracy = record->data[offset++];
-			freq = (record->data[offset+0] << 0)
-				| (record->data[offset+1] << 8)
-				| (record->data[offset+2] << 16)
-				| (record->data[offset+3] << 24);
-			offset += 4;
-			min_freq = (record->data[offset+0] << 0)
-				| (record->data[offset+1] << 8)
-				| (record->data[offset+2] << 16)
-				| (record->data[offset+3] << 24);
-			offset += 4;
-			max_freq = (record->data[offset+0] << 0)
-				| (record->data[offset+1] << 8)
-				| (record->data[offset+2] << 16)
-				| (record->data[offset+3] << 24);
-			offset += 4;
-
-			printf("\t- Feature: 0x%02x    - PLL: %x / Asym: %s\n",
-					feature,
-					(feature > 1) & 1,
-					(feature & 1) ? "Source" : "Receiver");
-			printf("\tFamily:  0x%02x    - AccLVL: 0x%02x\n",
-					family, accuracy);
-			printf("\tFRQ: %-9ld - min: %-9ld - max: %-9ld\n",
-					freq, min_freq, max_freq);
-		}
-		printf("\n");
-	}
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ekanalyzer_fru_file2structure
-*
-* Description: this function convert a FRU binary file into a linked list of
-*              FRU multi record
-*
-* Restriction: None
-*
-* Input/Ouput: filename1: name of the file that contain FRU binary data
-*        record: a pointer to current record
-*        list_head: a pointer to header of the list
-*        list_last: a pointer to tale of the list
-*
-* Global: None
-*
-* Return: return -1 as Error status, and 0 as Ok status
-*
-***************************************************************************/
-static int
-ipmi_ekanalyzer_fru_file2structure(char *filename,
-		struct ipmi_ek_multi_header **list_head,
-		struct ipmi_ek_multi_header **list_record,
-		struct ipmi_ek_multi_header **list_last)
-{
-	FILE *input_file;
-	unsigned char data;
-	unsigned char last_record = 0;
-	unsigned int multi_offset = 0;
-	int record_count = 0;
-	int ret = 0;
-
-	input_file = fopen(filename, "r");
-	if (input_file == NULL) {
-		lprintf(LOG_ERR, "File: '%s' is not found", filename);
-		return ERROR_STATUS;
-	}
-
-	fseek(input_file, START_DATA_OFFSET, SEEK_SET);
-	data = 0;
-	ret = fread(&data, 1, 1, input_file);
-	if ((ret != 1) || ferror(input_file)) {
-		lprintf(LOG_ERR, "Invalid Offset!");
-		fclose(input_file);
-		return ERROR_STATUS;
-	}
-	if (data == 0) {
-		lprintf(LOG_ERR, "There is no multi record in the file '%s'",
-				filename);
-		fclose(input_file);
-		return ERROR_STATUS;
-	}
-	/* the offset value is in multiple of 8 bytes. */
-	multi_offset = data * 8;
-	lprintf(LOG_DEBUG, "start multi offset = 0x%02x", 
-			multi_offset);
-
-	fseek(input_file, multi_offset, SEEK_SET);
-	while (!feof(input_file)) {
-		/* TODO - check malloc() */
-		*list_record = malloc(sizeof(struct ipmi_ek_multi_header));
-		ret = fread(&(*list_record)->header, START_DATA_OFFSET, 1, 
-				input_file);
-		if ((ret != 1) || ferror(input_file)) {
-			/* TODO - no free?! */
-			lprintf(LOG_ERR, "Invalid Header!");
-			fclose(input_file);
-			return ERROR_STATUS;
-		}
-		if ((*list_record)->header.len == 0) {
-			record_count++;
-			continue;
-		}
-		(*list_record)->data = malloc((*list_record)->header.len);
-		if ((*list_record)->data == NULL) {
-			lprintf(LOG_ERR, "Failed to allocation memory size %d\n",
-					(*list_record)->header.len);
-			record_count++;
-			continue;
-		}
-
-		ret = fread((*list_record)->data, ((*list_record)->header.len),
-				1, input_file);
-		if ((ret != 1) || ferror(input_file)) {
-			lprintf(LOG_ERR, "Invalid Record Data!");
-			fclose(input_file);
-			return ERROR_STATUS;
-		}
-		if (verbose > 0)
-			printf("Record %d has length = %02x\n", record_count,
-					(*list_record)->header.len);
-		if (verbose > 1) {
-			int i;
-			printf("Type: %02x", (*list_record)->header.type);
-			for (i = 0; i < ((*list_record)->header.len); i++) {
-				if (!(i % 8)) {
-					printf("\n0x%02x: ", i);
-				}
-				printf("%02x ",
-					(*list_record)->data[i]);
-			}
-			printf("\n\n");
-		}
-		ipmi_ek_add_record2list(list_record, list_head, list_last);
-		/* mask the 8th bits to see if it is the last record */
-		last_record = ((*list_record)->header.format) & 0x80;
-		if (last_record) {
-			break;
-		}
-		record_count++;
-	}
-	fclose(input_file);
-	return OK_STATUS;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_add_record2list
-*
-* Description: this function adds a sigle FRU multi record to a linked list of
-*              FRU multi record.
-*
-* Restriction: None
-*
-* Input/Output: record: a pointer to current record
-*        list_head: a pointer to header of the list
-*        list_last: a pointer to tale of the list
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_add_record2list(struct ipmi_ek_multi_header **record,
-		struct ipmi_ek_multi_header **list_head,
-		struct ipmi_ek_multi_header **list_last)
-{
-	if (*list_head == NULL) {
-		*list_head = *record;
-		(*record)->prev = NULL;
-		if (verbose > 2) {
-			printf("Adding first record to list\n");
-		}
-	} else {
-		(*list_last)->next = *record;
-		(*record)->prev = *list_last;
-		if (verbose > 2) {
-			printf("Add 1 record to list\n");
-		}
-	}
-	*list_last = *record;
-	(*record)->next = NULL;
-}
-
-/**************************************************************************
-*
-* Function name: ipmi_ek_remove_record_from_list
-*
-* Description: this function removes a sigle FRU multi record from a linked
-*              list of FRU multi record.
-*
-* Restriction: None
-*
-* Input/Output: record: a pointer to record to be deleted
-*        list_head: a pointer to header of the list
-*        list_last: a pointer to tale of the list
-*
-* Global: None
-*
-* Return: None
-*
-***************************************************************************/
-static void
-ipmi_ek_remove_record_from_list(struct ipmi_ek_multi_header *record,
-		struct ipmi_ek_multi_header **list_head,
-		struct ipmi_ek_multi_header **list_last)
-{
-	if (record->prev == NULL) {
-		*list_head = record->next;
-	} else {
-		record->prev->next = record->next;
-	}
-	if (record->next == NULL) {
-		(*list_last) = record->prev;
-	} else {
-		record->next->prev = record->prev;
-	}
-	free(record);
-	record = NULL;
-}
diff --git a/lib/ipmi_fwum.c b/lib/ipmi_fwum.c
deleted file mode 100644
index d1e3f4f..0000000
--- a/lib/ipmi_fwum.c
+++ /dev/null
@@ -1,1128 +0,0 @@
-/*
- * Copyright (c) 2004 Kontron Canada, Inc.  All Rights Reserved.
- *
- * Base on code from
- * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include <string.h>
-#include <math.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <ipmitool/log.h>
-#include <ipmitool/helper.h>
-#include <ipmitool/ipmi.h>
-#include <ipmitool/ipmi_fwum.h>
-#include <ipmitool/ipmi_intf.h>
-#include <ipmitool/ipmi_mc.h>
-
-extern int verbose;
-unsigned char firmBuf[1024*512];
-tKFWUM_SaveFirmwareInfo save_fw_nfo;
-
-int KfwumGetFileSize(const char *pFileName,
-		unsigned long *pFileSize);
-int KfwumSetupBuffersFromFile(const char *pFileName,
-		unsigned long fileSize);
-void KfwumShowProgress(const char *task, unsigned long current,
-		unsigned long total);
-unsigned short KfwumCalculateChecksumPadding(unsigned char *pBuffer,
-		unsigned long totalSize);
-int KfwumGetInfo(struct ipmi_intf *intf, unsigned char output,
-		unsigned char *pNumBank);
-int KfwumGetDeviceInfo(struct ipmi_intf *intf,
-		unsigned char output, tKFWUM_BoardInfo *pBoardInfo);
-int KfwumGetStatus(struct ipmi_intf *intf);
-int KfwumManualRollback(struct ipmi_intf *intf);
-int KfwumStartFirmwareImage(struct ipmi_intf *intf,
-		unsigned long length, unsigned short padding);
-int KfwumSaveFirmwareImage(struct ipmi_intf *intf,
-		unsigned char sequenceNumber, unsigned long address,
-		unsigned char *pFirmBuf, unsigned char *pInBufLength);
-int KfwumFinishFirmwareImage(struct ipmi_intf *intf,
-		tKFWUM_InFirmwareInfo firmInfo);
-int KfwumUploadFirmware(struct ipmi_intf *intf,
-		unsigned char *pBuffer, unsigned long totalSize);
-int KfwumStartFirmwareUpgrade(struct ipmi_intf *intf);
-int KfwumGetInfoFromFirmware(unsigned char *pBuf,
-		unsigned long bufSize, tKFWUM_InFirmwareInfo *pInfo);
-void KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo *pInfo);
-int KfwumGetTraceLog(struct ipmi_intf *intf);
-int ipmi_kfwum_checkfwcompat(tKFWUM_BoardInfo boardInfo,
-		tKFWUM_InFirmwareInfo firmInfo);
-
-int ipmi_fwum_fwupgrade(struct ipmi_intf *intf, char *file, int action);
-int ipmi_fwum_info(struct ipmi_intf *intf);
-int ipmi_fwum_status(struct ipmi_intf *intf);
-void printf_kfwum_help(void);
-void printf_kfwum_info(tKFWUM_BoardInfo boardInfo,
-		tKFWUM_InFirmwareInfo firmInfo);
-
-/* String table */
-/* Must match eFWUM_CmdId */
-const char *CMD_ID_STRING[] = {
-	"GetFwInfo",
-	"KickWatchdog",
-	"GetLastAnswer",
-	"BootHandshake",
-	"ReportStatus",
-	"CtrlIPMBLine",
-	"SetFwState",
-	"GetFwStatus",
-	"GetSpiMemStatus",
-	"StartFwUpdate",
-	"StartFwImage",
-	"SaveFwImage",
-	"FinishFwImage",
-	"ReadFwImage",
-	"ManualRollback",
-	"GetTraceLog"
-};
-
-const char *EXT_CMD_ID_STRING[] = {
-	"FwUpgradeLock",
-	"ProcessFwUpg",
-	"ProcessFwRb",
-	"WaitHSAfterUpg",
-	"WaitFirstHSUpg",
-	"FwInfoStateChange"
-};
-
-const char *CMD_STATE_STRING[] = {
-	"Invalid",
-	"Begin",
-	"Progress",
-	"Completed"
-};
-
-const struct valstr bankStateValS[] = {
-	{ 0x00, "Not programmed" },
-	{ 0x01, "New firmware" },
-	{ 0x02, "Wait for validation" },
-	{ 0x03, "Last Known Good" },
-	{ 0x04, "Previous Good" }
-};
-
-/* ipmi_fwum_main  -  entry point for this ipmitool mode
- *
- * @intf: ipmi interface
- * @arc: number of arguments
- * @argv: point to argument array
- *
- * returns 0 on success
- * returns -1 on error
- */
-int
-ipmi_fwum_main(struct ipmi_intf *intf, int argc, char **argv)
-{
-	int rc = 0;
-	printf("FWUM extension Version %d.%d\n", VER_MAJOR, VER_MINOR);
-	if (argc < 1) {
-		lprintf(LOG_ERR, "Not enough parameters given.");
-		printf_kfwum_help();
-		return (-1);
-	}
-	if (strncmp(argv[0], "help", 4) == 0) {
-		printf_kfwum_help();
-		rc = 0;
-	} else if (strncmp(argv[0], "info", 4) == 0) {
-		rc = ipmi_fwum_info(intf);
-	} else if (strncmp(argv[0], "status", 6) == 0) {
-		rc = ipmi_fwum_status(intf);
-	} else if (strncmp(argv[0], "rollback", 8) == 0) {
-		rc = KfwumManualRollback(intf);
-	} else if (strncmp(argv[0], "download", 8) == 0) {
-		if ((argc < 2) || (strlen(argv[1]) < 1)) {
-			lprintf(LOG_ERR,
-					"Path and file name must be specified.");
-			return (-1);
-		}
-		printf("Firmware File Name         : %s\n", argv[1]);
-		rc = ipmi_fwum_fwupgrade(intf, argv[1], 0);
-	} else if (strncmp(argv[0], "upgrade", 7) == 0) {
-		if ((argc >= 2) && (strlen(argv[1]) > 0)) {
-			printf("Upgrading using file name %s\n", argv[1]);
-			rc = ipmi_fwum_fwupgrade(intf, argv[1], 1);
-		} else {
-			rc = KfwumStartFirmwareUpgrade(intf);
-		}
-	} else if (strncmp(argv[0], "tracelog", 8) == 0) {
-		rc = KfwumGetTraceLog(intf);
-	} else {
-		lprintf(LOG_ERR, "Invalid KFWUM command: %s", argv[0]);
-		printf_kfwum_help();
-		rc = (-1);
-	}
-	return rc;
-}
-
-void
-printf_kfwum_help(void)
-{
-	lprintf(LOG_NOTICE,
-"KFWUM Commands:  info status download upgrade rollback tracelog");
-}
-
-/*  private definitions and macros */
-typedef enum eFWUM_CmdId
-{
-	KFWUM_CMD_ID_GET_FIRMWARE_INFO                         = 0,
-	KFWUM_CMD_ID_KICK_IPMC_WATCHDOG                        = 1,
-	KFWUM_CMD_ID_GET_LAST_ANSWER                           = 2,
-	KFWUM_CMD_ID_BOOT_HANDSHAKE                            = 3,
-	KFWUM_CMD_ID_REPORT_STATUS                             = 4,
-	KFWUM_CMD_ID_GET_FIRMWARE_STATUS                       = 7,
-	KFWUM_CMD_ID_START_FIRMWARE_UPDATE                     = 9,
-	KFWUM_CMD_ID_START_FIRMWARE_IMAGE                      = 0x0a,
-	KFWUM_CMD_ID_SAVE_FIRMWARE_IMAGE                       = 0x0b,
-	KFWUM_CMD_ID_FINISH_FIRMWARE_IMAGE                     = 0x0c,
-	KFWUM_CMD_ID_READ_FIRMWARE_IMAGE                       = 0x0d,
-	KFWUM_CMD_ID_MANUAL_ROLLBACK                           = 0x0e,
-	KFWUM_CMD_ID_GET_TRACE_LOG                             = 0x0f,
-	KFWUM_CMD_ID_STD_MAX_CMD,
-	KFWUM_CMD_ID_EXTENDED_CMD                              = 0xC0
-}  tKFWUM_CmdId;
-
-int
-ipmi_fwum_info(struct ipmi_intf *intf)
-{
-	tKFWUM_BoardInfo b_info;
-	int rc = 0;
-	unsigned char not_used;
-	if (verbose) {
-		printf("Getting Kontron FWUM Info\n");
-	}
-	if (KfwumGetDeviceInfo(intf, 1, &b_info) != 0) {
-		rc = (-1);
-	}
-	if (KfwumGetInfo(intf, 1, &not_used) != 0) {
-		rc = (-1);
-	}
-	return rc;
-}
-
-int
-ipmi_fwum_status(struct ipmi_intf *intf)
-{
-	if (verbose) {
-		printf("Getting Kontron FWUM Status\n");
-	}
-	if (KfwumGetStatus(intf) != 0) {
-		return (-1);
-	}
-	return 0;
-}
-
-/* ipmi_fwum_fwupgrade - function implements download/upload of the firmware
- * data received as parameters
- *
- * @file: fw file
- * @action: 0 = download, 1 = upload/start upload
- *
- * returns 0 on success, otherwise (-1)
- */
-int
-ipmi_fwum_fwupgrade(struct ipmi_intf *intf, char *file, int action)
-{
-	tKFWUM_BoardInfo b_info;
-	tKFWUM_InFirmwareInfo fw_info = { 0 };
-	unsigned short padding;
-	unsigned long fsize = 0;
-	unsigned char not_used;
-	if (file == NULL) {
-		lprintf(LOG_ERR, "No file given.");
-		return (-1);
-	}
-	if (KfwumGetFileSize(file, &fsize) != 0) {
-		return (-1);
-	}
-	if (KfwumSetupBuffersFromFile(file, fsize) != 0) {
-		return (-1);
-	}
-	padding = KfwumCalculateChecksumPadding(firmBuf, fsize);
-	if (KfwumGetInfoFromFirmware(firmBuf, fsize, &fw_info) != 0) {
-		return (-1);
-	}
-	if (KfwumGetDeviceInfo(intf, 0, &b_info) != 0) {
-		return (-1);
-	}
-	if (ipmi_kfwum_checkfwcompat(b_info, fw_info) != 0) {
-		return (-1);
-	}
-	KfwumGetInfo(intf, 0, &not_used);
-	printf_kfwum_info(b_info, fw_info);
-	if (KfwumStartFirmwareImage(intf, fsize, padding) != 0) {
-		return (-1);
-	}
-	if (KfwumUploadFirmware(intf, firmBuf, fsize) != 0) {
-		return (-1);
-	}
-	if (KfwumFinishFirmwareImage(intf, fw_info) != 0) {
-		return (-1);
-	}
-	if (KfwumGetStatus(intf) != 0) {
-		return (-1);
-	}
-	if (action != 0) {
-		if (KfwumStartFirmwareUpgrade(intf) != 0) {
-			return (-1);
-		}
-	}
-	return 0;
-}
-
-/* KfwumGetFileSize  -  gets the file size
- *
- * @pFileName : filename ptr
- * @pFileSize : output ptr for filesize
- *
- * returns 0 on success, otherwise (-1)
- */
-int
-KfwumGetFileSize(const char *pFileName, unsigned long *pFileSize)
-{
-	FILE *pFileHandle = NULL;
-	pFileHandle = fopen(pFileName, "rb");
-	if (pFileHandle == NULL) {
-		return (-1);
-	}
-	if (fseek(pFileHandle, 0L , SEEK_END) == 0) {
-		*pFileSize = ftell(pFileHandle);
-	}
-	fclose(pFileHandle);
-	if (*pFileSize != 0) {
-		return 0;
-	}
-	return (-1);
-}
-
-/* KfwumSetupBuffersFromFile  -  small buffers are used to store the file data
- *
- * @pFileName : filename ptr
- * unsigned long : filesize
- *
- * returns 0 on success, otherwise (-1)
- */
-int
-KfwumSetupBuffersFromFile(const char *pFileName, unsigned long fileSize)
-{
-	int rc = (-1);
-	FILE *pFileHandle = NULL;
-	int count;
-	int modulus;
-	int qty = 0;
-
-	pFileHandle = fopen(pFileName, "rb");
-	if (pFileHandle == NULL) {
-		lprintf(LOG_ERR, "Failed to open '%s' for reading.",
-				pFileName);
-		return (-1);
-	}
-	count = fileSize / MAX_BUFFER_SIZE;
-	modulus = fileSize % MAX_BUFFER_SIZE;
-
-	rewind(pFileHandle);
-	for (qty = 0; qty < count; qty++) {
-		KfwumShowProgress("Reading Firmware from File",
-				qty, count);
-		if (fread(&firmBuf[qty * MAX_BUFFER_SIZE], 1,
-					MAX_BUFFER_SIZE,
-					pFileHandle) == MAX_BUFFER_SIZE) {
-			rc = 0;
-		}
-	}
-	if (modulus) {
-		if (fread(&firmBuf[qty * MAX_BUFFER_SIZE], 1,
-					modulus, pFileHandle) == modulus) {
-			rc = 0;
-		}
-	}
-	if (rc == 0) {
-		KfwumShowProgress("Reading Firmware from File", 100, 100);
-	}
-	fclose(pFileHandle);
-	return rc;
-}
-
-/* KfwumShowProgress  -  helper routine to display progress bar
- *
- * Converts current/total in percent
- *
- * *task  : string identifying current operation
- * current: progress
- * total  : limit
- */
-void
-KfwumShowProgress(const char *task, unsigned long current, unsigned long total)
-{
-# define PROG_LENGTH 42
-	static unsigned long staticProgress=0xffffffff;
-	unsigned char spaces[PROG_LENGTH + 1];
-	unsigned short hash;
-	float percent = ((float)current / total);
-	unsigned long progress =  100 * (percent);
-
-	if (staticProgress == progress) {
-		/* We displayed the same last time.. so don't do it */
-		return;
-	}
-	staticProgress = progress;
-	printf("%-25s : ", task); /* total 20 bytes */
-	hash = (percent * PROG_LENGTH);
-	memset(spaces, '#', hash);
-	spaces[hash] = '\0';
-
-	printf("%s", spaces);
-	memset(spaces, ' ', (PROG_LENGTH - hash));
-	spaces[(PROG_LENGTH - hash)] = '\0';
-	printf("%s", spaces );
-
-	printf(" %3ld %%\r", progress); /* total 7 bytes */
-	if (progress == 100) {
-		printf("\n");
-	}
-	fflush(stdout);
-}
-
-/* KfwumCalculateChecksumPadding - TBD
- */
-unsigned short
-KfwumCalculateChecksumPadding(unsigned char *pBuffer, unsigned long totalSize)
-{
-	unsigned short sumOfBytes = 0;
-	unsigned short padding;
-	unsigned long  counter;
-	for (counter = 0; counter < totalSize; counter ++) {
-		sumOfBytes += pBuffer[counter];
-	}
-	padding = 0 - sumOfBytes;
-	return padding;
-}
-
-/* KfwumGetInfo  -  Get Firmware Update Manager (FWUM) information
- *
- * *intf  : IPMI interface
- * output  : when set to non zero, queried information is displayed
- * pNumBank: output ptr for number of banks
- *
- * returns 0 on success, otherwise (-1)
- */
-int
-KfwumGetInfo(struct ipmi_intf *intf, unsigned char output,
-		unsigned char *pNumBank)
-{
-	int rc = 0;
-	static struct KfwumGetInfoResp *pGetInfo;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_FIRMWARE;
-	req.msg.cmd = KFWUM_CMD_ID_GET_FIRMWARE_INFO;
-	req.msg.data_len = 0;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (!rsp) {
-		lprintf(LOG_ERR, "Error in FWUM Firmware Get Info Command.");
-		return (-1);
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "FWUM Firmware Get Info returned %x",
-				rsp->ccode);
-		return (-1);
-	}
-
-	pGetInfo = (struct KfwumGetInfoResp *)rsp->data;
-	if (output) {
-		printf("\nFWUM info\n");
-		printf("=========\n");
-		printf("Protocol Revision         : %02Xh\n",
-				pGetInfo->protocolRevision);
-		printf("Controller Device Id      : %02Xh\n",
-				pGetInfo->controllerDeviceId);
-		printf("Firmware Revision         : %u.%u%u",
-				pGetInfo->firmRev1, pGetInfo->firmRev2 >> 4,
-				pGetInfo->firmRev2 & 0x0f);
-		if (pGetInfo->byte.mode != 0) {
-			printf(" - DEBUG BUILD\n");
-		} else {
-			printf("\n");
-		}
-		printf("Number Of Memory Bank     : %u\n", pGetInfo->numBank);
-	}
-	*pNumBank = pGetInfo->numBank;
-	/* Determine wich type of download to use: */
-	/* Old FWUM or Old IPMC fw (data_len < 7)
-	 * --> Address with small buffer size
-	 */
-	if ((pGetInfo->protocolRevision) <= 0x05 || (rsp->data_len < 7 )) {
-		save_fw_nfo.downloadType = KFWUM_DOWNLOAD_TYPE_ADDRESS;
-		save_fw_nfo.bufferSize   = KFWUM_SMALL_BUFFER;
-		save_fw_nfo.overheadSize = KFWUM_OLD_CMD_OVERHEAD;
-		if (verbose) {
-			printf("Protocol Revision          :");
-			printf(" <= 5 detected, adjusting buffers\n");
-		}
-	} else {
-		/* Both fw are using the new protocol */
-		save_fw_nfo.downloadType = KFWUM_DOWNLOAD_TYPE_SEQUENCE;
-		save_fw_nfo.overheadSize = KFWUM_NEW_CMD_OVERHEAD;
-		/* Buffer size depending on access type (Local or remote) */
-		/* Look if we run remote or locally */
-		if (verbose) {
-			printf("Protocol Revision          :");
-			printf(" > 5 optimizing buffers\n");
-		}
-		if (strstr(intf->name,"lan") != NULL) {
-			/* also covers lanplus */
-			save_fw_nfo.bufferSize = KFWUM_SMALL_BUFFER;
-			if (verbose) {
-				printf("IOL payload size           : %d\n",
-						save_fw_nfo.bufferSize);
-			}
-		} else if ((strstr(intf->name,"open")!= NULL)
-				&& intf->target_addr != IPMI_BMC_SLAVE_ADDR 
-				&& (intf->target_addr !=  intf->my_addr)) {
-			save_fw_nfo.bufferSize = KFWUM_SMALL_BUFFER;
-			if (verbose) {
-				printf("IPMB payload size          : %d\n",
-						save_fw_nfo.bufferSize);
-			}
-		} else {
-			save_fw_nfo.bufferSize = KFWUM_BIG_BUFFER;
-			if (verbose) {
-				printf("SMI payload size           : %d\n",
-						save_fw_nfo.bufferSize);
-			}
-		}
-	}
-	return rc;
-}
-
-/* KfwumGetDeviceInfo - Get IPMC/Board information
- *
- * *intf: IPMI interface
- * output: when set to non zero, queried information is displayed
- * tKFWUM_BoardInfo: output ptr for IPMC/Board information
- *
- * returns 0 on success, otherwise (-1)
- */
-int
-KfwumGetDeviceInfo(struct ipmi_intf *intf, unsigned char output,
-		tKFWUM_BoardInfo *pBoardInfo)
-{
-	struct ipm_devid_rsp *pGetDevId;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	/* Send Get Device Id */
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_APP;
-	req.msg.cmd = BMC_GET_DEVICE_ID;
-	req.msg.data_len = 0;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in Get Device Id Command");
-		return (-1);
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Get Device Id returned %x",
-				rsp->ccode);
-		return (-1);
-	}
-	pGetDevId = (struct ipm_devid_rsp *)rsp->data;
-	pBoardInfo->iana = IPM_DEV_MANUFACTURER_ID(pGetDevId->manufacturer_id);
-	pBoardInfo->boardId = buf2short(pGetDevId->product_id);
-	if (output) {
-		printf("\nIPMC Info\n");
-		printf("=========\n");
-		printf("Manufacturer Id           : %u\n",
-				pBoardInfo->iana);
-		printf("Board Id                  : %u\n",
-				pBoardInfo->boardId);
-		printf("Firmware Revision         : %u.%u%u",
-				pGetDevId->fw_rev1, pGetDevId->fw_rev2 >> 4,
-				pGetDevId->fw_rev2 & 0x0f);
-		if (((pBoardInfo->iana == IPMI_OEM_KONTRON)
-					&& (pBoardInfo->boardId == KFWUM_BOARD_KONTRON_5002))) {
-			printf(" SDR %u", pGetDevId->aux_fw_rev[0]);
-		}
-		printf("\n");
-	}
-	return 0;
-}
-
-/* KfwumGetStatus  -  Get (and prints) FWUM  banks information
- *
- * *intf  : IPMI interface
- *
- * returns 0 on success, otherwise (-1)
- */
-int
-KfwumGetStatus(struct ipmi_intf * intf)
-{
-	int rc = 0;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	struct KfwumGetStatusResp *pGetStatus;
-	unsigned char numBank;
-	unsigned char counter;
-	unsigned long firmLength;
-	if (verbose) {
-		printf(" Getting Status!\n");
-	}
-	/* Retreive the number of bank */
-	rc = KfwumGetInfo(intf, 0, &numBank);
-	for(counter = 0;
-			(counter < numBank) && (rc == 0);
-			counter ++) {
-		/* Retreive the status of each bank */
-		memset(&req, 0, sizeof(req));
-		req.msg.netfn = IPMI_NETFN_FIRMWARE;
-		req.msg.cmd = KFWUM_CMD_ID_GET_FIRMWARE_STATUS;
-		req.msg.data = &counter;
-		req.msg.data_len = 1;
-		rsp = intf->sendrecv(intf, &req);
-		if (rsp == NULL) {
-			lprintf(LOG_ERR,
-					"Error in FWUM Firmware Get Status Command.");
-			rc = (-1);
-			break;
-		} else if (rsp->ccode) {
-			lprintf(LOG_ERR,
-					"FWUM Firmware Get Status returned %x",
-					rsp->ccode);
-			rc = (-1);
-			break;
-		}
-		pGetStatus = (struct KfwumGetStatusResp *) rsp->data;
-		printf("\nBank State %d               : %s\n",
-				counter,
-				val2str(pGetStatus->bankState, bankStateValS));
-		if (!pGetStatus->bankState) {
-			continue;
-		}
-		firmLength  = pGetStatus->firmLengthMSB;
-		firmLength  = firmLength << 8;
-		firmLength |= pGetStatus->firmLengthMid;
-		firmLength  = firmLength << 8;
-		firmLength |= pGetStatus->firmLengthLSB;
-		printf("Firmware Length            : %ld bytes\n",
-				firmLength);
-		printf("Firmware Revision          : %u.%u%u SDR %u\n",
-				pGetStatus->firmRev1,
-				pGetStatus->firmRev2 >> 4,
-				pGetStatus->firmRev2 & 0x0f,
-				pGetStatus->firmRev3);
-	}
-	printf("\n");
-	return rc;
-}
-
-/* KfwumManualRollback  -  Ask IPMC to rollback to previous version
- *
- * *intf  : IPMI interface
- *
- * returns 0 on success
- * returns (-1) on error
- */
-int
-KfwumManualRollback(struct ipmi_intf *intf)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	struct KfwumManualRollbackReq thisReq;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_FIRMWARE;
-	req.msg.cmd = KFWUM_CMD_ID_MANUAL_ROLLBACK;
-	thisReq.type = 0; /* Wait BMC shutdown */
-	req.msg.data = (unsigned char *)&thisReq;
-	req.msg.data_len = 1;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Error in FWUM Manual Rollback Command.");
-		return (-1);
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR,
-				"Error in FWUM Manual Rollback Command returned %x",
-				rsp->ccode);
-		return (-1);
-	}
-	printf("FWUM Starting Manual Rollback \n");
-	return 0;
-}
-
-int
-KfwumStartFirmwareImage(struct ipmi_intf *intf, unsigned long length,
-		unsigned short padding)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	struct KfwumStartFirmwareDownloadResp *pResp;
-	struct KfwumStartFirmwareDownloadReq thisReq;
-
-	thisReq.lengthLSB  = length         & 0x000000ff;
-	thisReq.lengthMid  = (length >>  8) & 0x000000ff;
-	thisReq.lengthMSB  = (length >> 16) & 0x000000ff;
-	thisReq.paddingLSB = padding        & 0x00ff;
-	thisReq.paddingMSB = (padding>>  8) & 0x00ff;
-	thisReq.useSequence = 0x01;
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_FIRMWARE;
-	req.msg.cmd = KFWUM_CMD_ID_START_FIRMWARE_IMAGE;
-	req.msg.data = (unsigned char *) &thisReq;
-	/* Look for download type */
-	if (save_fw_nfo.downloadType == KFWUM_DOWNLOAD_TYPE_ADDRESS) {
-		req.msg.data_len = 5;
-	} else {
-		req.msg.data_len = 6;
-	}
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR,
-				"Error in FWUM Firmware Start Firmware Image Download Command.");
-		return (-1);
-	} else if (rsp->ccode) {
-		lprintf(LOG_ERR,
-				"FWUM Firmware Start Firmware Image Download returned %x",
-				rsp->ccode);
-		return (-1);
-	}
-	pResp = (struct KfwumStartFirmwareDownloadResp *)rsp->data;
-	printf("Bank holding new firmware  : %d\n", pResp->bank);
-	sleep(5);
-	return 0;
-}
-
-int
-KfwumSaveFirmwareImage(struct ipmi_intf *intf, unsigned char sequenceNumber,
-		unsigned long address, unsigned char *pFirmBuf,
-		unsigned char *pInBufLength)
-{
-	int rc = 0;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	struct KfwumSaveFirmwareAddressReq addr_req;
-	struct KfwumSaveFirmwareSequenceReq seq_req;
-	int retry = 0;
-	int no_rsp = 0;
-	do {
-		memset(&req, 0, sizeof(req));
-		req.msg.netfn = IPMI_NETFN_FIRMWARE;
-		req.msg.cmd = KFWUM_CMD_ID_SAVE_FIRMWARE_IMAGE;
-		if (save_fw_nfo.downloadType == KFWUM_DOWNLOAD_TYPE_ADDRESS) {
-			addr_req.addressLSB  = address         & 0x000000ff;
-			addr_req.addressMid  = (address >>  8) & 0x000000ff;
-			addr_req.addressMSB  = (address >> 16) & 0x000000ff;
-			addr_req.numBytes    = *pInBufLength;
-			memcpy(addr_req.txBuf, pFirmBuf, *pInBufLength);
-			req.msg.data = (unsigned char *)&addr_req;
-			req.msg.data_len = *pInBufLength + 4;
-		} else {
-			seq_req.sequenceNumber = sequenceNumber;
-			memcpy(seq_req.txBuf, pFirmBuf, *pInBufLength);
-			req.msg.data = (unsigned char *)&seq_req;
-			req.msg.data_len = *pInBufLength + sizeof(unsigned char);
-			/* + 1 => sequenceNumber*/
-		}
-		rsp = intf->sendrecv(intf, &req);
-		if (rsp == NULL) {
-			lprintf(LOG_ERR,
-					"Error in FWUM Firmware Save Firmware Image Download Command.");
-			/* We don't receive "C7" on errors with IOL,
-			 * instead we receive nothing
-			 */
-			if (strstr(intf->name, "lan") != NULL) {
-				no_rsp++;
-				if (no_rsp < FWUM_SAVE_FIRMWARE_NO_RESPONSE_LIMIT) {
-					*pInBufLength -= 1;
-					continue;
-				}
-				lprintf(LOG_ERR,
-						"Error, too many commands without response.");
-				*pInBufLength = 0;
-				break;
-			} /* For other interface keep trying */
-		} else if (rsp->ccode != 0) {
-			if (rsp->ccode == 0xc0) {
-				sleep(1);
-			} else if ((rsp->ccode == 0xc7)
-					|| ((rsp->ccode == 0xc3)
-						&& (sequenceNumber == 0))) {
-				*pInBufLength -= 1;
-				retry = 1;
-			} else if (rsp->ccode == 0x82) {
-				/* Double sent, continue */
-				rc = 0;
-				break;
-			} else if (rsp->ccode == 0x83) {
-				if (retry == 0) {
-					retry = 1;
-					continue;
-				}
-				rc = (-1);
-				break;
-			} else if (rsp->ccode == 0xcf) {
-				/* Ok if receive duplicated request */
-				retry = 1;
-			} else if (rsp->ccode == 0xc3) {
-				if (retry == 0) {
-					retry = 1;
-					continue;
-				}
-				rc = (-1);
-				break;
-			} else {
-				lprintf(LOG_ERR,
-						"FWUM Firmware Save Firmware Image Download returned %x",
-						rsp->ccode);
-				rc = (-1);
-				break;
-			}
-		} else {
-			break;
-		}
-	} while (1);
-	return rc;
-}
-
-int
-KfwumFinishFirmwareImage(struct ipmi_intf *intf, tKFWUM_InFirmwareInfo firmInfo)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	struct KfwumFinishFirmwareDownloadReq thisReq;
-
-	thisReq.versionMaj = firmInfo.versMajor;
-	thisReq.versionMinSub = ((firmInfo.versMinor <<4)
-			| firmInfo.versSubMinor);
-	thisReq.versionSdr = firmInfo.sdrRev;
-	thisReq.reserved = 0;
-	/* Byte 4 reserved, write 0 */
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_FIRMWARE;
-	req.msg.cmd = KFWUM_CMD_ID_FINISH_FIRMWARE_IMAGE;
-	req.msg.data = (unsigned char *)&thisReq;
-	req.msg.data_len = 4;
-	/* Infinite loop if BMC doesn't reply or replies 0xc0 every time. */
-	do {
-		rsp = intf->sendrecv(intf, &req);
-	} while (rsp == NULL || rsp->ccode == 0xc0);
-
-	if (rsp->ccode != 0) {
-		lprintf(LOG_ERR,
-				"FWUM Firmware Finish Firmware Image Download returned %x",
-				rsp->ccode);
-		return (-1);
-	}
-	return 0;
-}
-
-int
-KfwumUploadFirmware(struct ipmi_intf *intf, unsigned char *pBuffer,
-		unsigned long totalSize)
-{
-	int rc = (-1);
-	unsigned long address = 0x0;
-	unsigned char writeSize;
-	unsigned char oldWriteSize;
-	unsigned long lastAddress = 0;
-	unsigned char sequenceNumber = 0;
-	unsigned char retry = FWUM_MAX_UPLOAD_RETRY;
-	do {
-		writeSize = save_fw_nfo.bufferSize - save_fw_nfo.overheadSize;
-		/* Reach the end */
-		if (address + writeSize > totalSize) {
-			writeSize = (totalSize - address);
-		} else if (((address % KFWUM_PAGE_SIZE)
-					+ writeSize) > KFWUM_PAGE_SIZE) {
-			/* Reach boundary end */
-			writeSize = (KFWUM_PAGE_SIZE - (address % KFWUM_PAGE_SIZE));
-		}
-		oldWriteSize = writeSize;
-		rc = KfwumSaveFirmwareImage(intf, sequenceNumber,
-				address, &pBuffer[address], &writeSize);
-		if ((rc != 0) && (retry-- != 0)) {
-			address = lastAddress;
-			rc = 0;
-		} else if ( writeSize == 0) {
-			rc = (-1);
-		} else {
-			if (writeSize != oldWriteSize) {
-				printf("Adjusting length to %d bytes \n",
-						writeSize);
-				save_fw_nfo.bufferSize -= (oldWriteSize - writeSize);
-			}
-			retry = FWUM_MAX_UPLOAD_RETRY;
-			lastAddress = address;
-			address+= writeSize;
-		}
-		if (rc == 0) {
-			if ((address % 1024) == 0) {
-				KfwumShowProgress("Writing Firmware in Flash",
-						address, totalSize);
-			}
-			sequenceNumber++;
-		}
-	} while ((rc == 0) && (address < totalSize));
-	if (rc == 0) {
-		KfwumShowProgress("Writing Firmware in Flash",
-				100, 100);
-	}
-	return rc;
-}
-
-int
-KfwumStartFirmwareUpgrade(struct ipmi_intf *intf)
-{
-	int rc = 0;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	/* Upgrade type, wait BMC shutdown */
-	unsigned char upgType = 0 ;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_FIRMWARE;
-	req.msg.cmd = KFWUM_CMD_ID_START_FIRMWARE_UPDATE;
-	req.msg.data = (unsigned char *) &upgType;
-	req.msg.data_len = 1;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR,
-				"Error in FWUM Firmware Start Firmware Upgrade Command");
-		rc = (-1);
-	} else if (rsp->ccode) {
-		if (rsp->ccode == 0xd5) {
-			lprintf(LOG_ERR,
-					"No firmware available for upgrade.  Download Firmware first.");
-		} else {
-			lprintf(LOG_ERR,
-					"FWUM Firmware Start Firmware Upgrade returned %x",
-					rsp->ccode);
-		}
-		rc = (-1);
-	}
-	return rc;
-}
-
-int
-KfwumGetTraceLog(struct ipmi_intf *intf)
-{
-	int rc = 0;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char chunkIdx;
-	unsigned char cmdIdx;
-	if (verbose) {
-		printf(" Getting Trace Log!\n");
-	}
-	for (chunkIdx = 0;
-			(chunkIdx < TRACE_LOG_CHUNK_COUNT)
-			&& (rc == 0);
-			chunkIdx++) {
-		/* Retreive each log chunk and print it */
-		memset(&req, 0, sizeof(req));
-		req.msg.netfn = IPMI_NETFN_FIRMWARE;
-		req.msg.cmd = KFWUM_CMD_ID_GET_TRACE_LOG;
-		req.msg.data = &chunkIdx;
-		req.msg.data_len = 1;
-
-		rsp = intf->sendrecv(intf, &req);
-		if (rsp == NULL) {
-			lprintf(LOG_ERR,
-					"Error in FWUM Firmware Get Trace Log Command");
-			rc = (-1);
-			break;
-		} else if (rsp->ccode) {
-			lprintf(LOG_ERR,
-					"FWUM Firmware Get Trace Log returned %x",
-					rsp->ccode);
-			rc = (-1);
-			break;
-		}
-		for (cmdIdx=0; cmdIdx < TRACE_LOG_CHUNK_SIZE; cmdIdx++) {
-			/* Don't diplay commands with an invalid state */
-			if ((rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx + 1] != 0)
-					&& (rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx] < KFWUM_CMD_ID_STD_MAX_CMD)) {
-				printf("  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n",
-						CMD_ID_STRING[rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx]],
-						CMD_STATE_STRING[rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx + 1]],
-						rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx + 2]);
-			} else if ((rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx + 1] != 0)
-					&& (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx] >= KFWUM_CMD_ID_EXTENDED_CMD)) {
-				printf("  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n",
-						EXT_CMD_ID_STRING[rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx] - KFWUM_CMD_ID_EXTENDED_CMD],
-						CMD_STATE_STRING[rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx + 1]],
-						rsp->data[TRACE_LOG_ATT_COUNT * cmdIdx + 2]);
-			}
-		}
-	}
-	printf("\n");
-	return rc;
-}
-
-int
-KfwumGetInfoFromFirmware(unsigned char *pBuf, unsigned long bufSize,
-		tKFWUM_InFirmwareInfo *pInfo)
-{
-	unsigned long offset = 0;
-	if (bufSize < (IN_FIRMWARE_INFO_OFFSET_LOCATION + IN_FIRMWARE_INFO_SIZE)) {
-		return (-1);
-	}
-	offset = IN_FIRMWARE_INFO_OFFSET_LOCATION;
-
-	/* Now, fill the structure with read informations */
-	pInfo->checksum = (unsigned short)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + 0 + IN_FIRMWARE_INFO_OFFSET_CHECKSUM ) << 8;
-
-	pInfo->checksum|= (unsigned short)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + 1 + IN_FIRMWARE_INFO_OFFSET_CHECKSUM);
-
-	pInfo->sumToRemoveFromChecksum = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_CHECKSUM);
-
-	pInfo->sumToRemoveFromChecksum+= KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_CHECKSUM + 1);
-
-	pInfo->fileSize = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_FILE_SIZE + 0) << 24;
-
-	pInfo->fileSize|= (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_FILE_SIZE + 1) << 16;
-
-	pInfo->fileSize|= (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_FILE_SIZE + 2) << 8;
-
-	pInfo->fileSize|= (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_FILE_SIZE + 3);
-
-	pInfo->boardId = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_BOARD_ID + 0) << 8;
-
-	pInfo->boardId|= KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_BOARD_ID + 1);
-
-	pInfo->deviceId = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_DEVICE_ID);
-
-	pInfo->tableVers = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_TABLE_VERSION);
-
-	pInfo->implRev = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_IMPLEMENT_REV);
-
-	pInfo->versMajor = (KWUM_GET_BYTE_AT_OFFSET(pBuf,
-				offset
-				+ IN_FIRMWARE_INFO_OFFSET_VER_MAJOROR)) & 0x0f;
-
-	pInfo->versMinor = (KWUM_GET_BYTE_AT_OFFSET(pBuf,
-				offset
-				+ IN_FIRMWARE_INFO_OFFSET_VER_MINORSUB) >> 4) & 0x0f;
-
-	pInfo->versSubMinor = (KWUM_GET_BYTE_AT_OFFSET(pBuf,
-				offset + IN_FIRMWARE_INFO_OFFSET_VER_MINORSUB)) & 0x0f;
-
-	pInfo->sdrRev = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_SDR_REV);
-
-	pInfo->iana = KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_IANA2) << 16;
-
-	pInfo->iana|= (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_IANA1) << 8;
-
-	pInfo->iana|= (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-			offset + IN_FIRMWARE_INFO_OFFSET_IANA0);
-
-	KfwumFixTableVersionForOldFirmware(pInfo);
-	return 0;
-}
-
-void
-KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo * pInfo)
-{
-	switch(pInfo->boardId) {
-	case KFWUM_BOARD_KONTRON_UNKNOWN:
-		pInfo->tableVers = 0xff;
-		break;
-	default:
-		/* pInfo->tableVers is already set for
-		 * the right version
-		 */
-		break;
-	}
-}
-
-/* ipmi_kfwum_checkfwcompat - check whether firmware we're about to upload is
- * compatible with board.
- *
- * @boardInfo:
- * @firmInfo:
- *
- * returns 0 if compatible, otherwise (-1)
- */
-int
-ipmi_kfwum_checkfwcompat(tKFWUM_BoardInfo boardInfo,
-		tKFWUM_InFirmwareInfo firmInfo)
-{
-	int compatible = 0;
-	if (boardInfo.iana != firmInfo.iana) {
-		lprintf(LOG_ERR,
-				"Board IANA does not match firmware IANA.");
-		compatible = (-1);
-	}
-	if (boardInfo.boardId != firmInfo.boardId) {
-		lprintf(LOG_ERR,
-				"Board IANA does not match firmware IANA.");
-		compatible = (-1);
-	}
-	if (compatible != 0) {
-		lprintf(LOG_ERR,
-				"Firmware invalid for target board. Download of upgrade aborted.");
-	}
-	return compatible;
-}
-
-void
-printf_kfwum_info(tKFWUM_BoardInfo boardInfo, tKFWUM_InFirmwareInfo firmInfo)
-{
-	printf(
-"Target Board Id            : %u\n", boardInfo.boardId);
-	printf(
-"Target IANA number         : %u\n", boardInfo.iana);
-	printf(
-"File Size                  : %lu bytes\n", firmInfo.fileSize);
-	printf(
-"Firmware Version           : %d.%d%d SDR %d\n", firmInfo.versMajor,
-firmInfo.versMinor, firmInfo.versSubMinor, firmInfo.sdrRev);
-}
diff --git a/lib/ipmi_kontronoem.c b/lib/ipmi_kontronoem.c
deleted file mode 100644
index 64860be..0000000
--- a/lib/ipmi_kontronoem.c
+++ /dev/null
@@ -1,702 +0,0 @@
-/*
- * Copyright (c) 2004 Kontron Canada, Inc.  All Rights Reserved.
- *
- * Base on code from
- * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-/*
- * Tue Mar 7 14:36:12 2006
- * <stephane.filion@ca.kontron.com>
- *
- * This code implements an Kontron OEM proprietary commands.
- */
-#include <string.h>
-#include <ipmitool/helper.h>
-#include <ipmitool/log.h>
-#include <ipmitool/ipmi.h>
-#include <ipmitool/ipmi_intf.h>
-#include <ipmitool/ipmi_fru.h>
-
-extern int verbose;
-extern int read_fru_area(struct ipmi_intf *intf, struct fru_info *fru,
-		uint8_t id, uint32_t offset, uint32_t length,
-		uint8_t *frubuf);
-extern int write_fru_area(struct ipmi_intf * intf, struct fru_info *fru,
-		uint8_t id, uint16_t soffset,
-		uint16_t doffset,  uint16_t length,
-		uint8_t *pFrubuf);
-extern char *get_fru_area_str(uint8_t *data, uint32_t *offset);
-
-static void ipmi_kontron_help(void);
-static int ipmi_kontron_set_serial_number(struct ipmi_intf *intf);
-static int ipmi_kontron_set_mfg_date (struct ipmi_intf *intf);
-static void ipmi_kontron_nextboot_help(void);
-static int ipmi_kontron_nextboot_set(struct ipmi_intf *intf, int argc,
-		char **argv);
-static int ipmi_kontronoem_send_set_large_buffer(struct ipmi_intf *intf,
-		unsigned char channel, unsigned char size);
-
-static char *bootdev[] = {"BIOS", "FDD", "HDD", "CDROM", "network", 0};
-
-int
-ipmi_kontronoem_main(struct ipmi_intf *intf, int argc, char **argv)
-{
-	int rc = 0;
-	if (argc == 0) {
-		lprintf(LOG_ERR, "Not enough parameters given.");
-		ipmi_kontron_help();
-		return (-1);
-	}
-	if (strncmp(argv[0], "help", 4) == 0) {
-		ipmi_kontron_help();
-		rc = 0;
-	} else if (!strncmp(argv[0], "setsn", 5)) {
-		if (argc < 1) {
-			printf("fru setsn\n");
-			return (-1);
-		}
-		if (ipmi_kontron_set_serial_number(intf) > 0) {
-			printf("FRU serial number setted successfully\n");
-		} else {
-			printf("FRU serial number set failed\n");
-			rc = (-1);
-		}
-	} else if (!strncmp(argv[0], "setmfgdate", 10)) {
-		if (argc < 1) {
-			printf("fru setmfgdate\n");
-			return (-1);
-		}
-		if (ipmi_kontron_set_mfg_date(intf) > 0) {
-			printf("FRU manufacturing date setted successfully\n");
-		} else {
-			printf("FRU manufacturing date set failed\n");
-			rc = (-1);
-		}
-	} else if (!strncmp(argv[0], "nextboot", 8)) {
-		if (argc < 2) {
-			lprintf(LOG_ERR, "Not enough parameters given.");
-			ipmi_kontron_nextboot_help();
-			return (-1);
-		}
-		rc = ipmi_kontron_nextboot_set(intf, (argc - 1), (argv + 1));
-		if (rc == 0) {
-			printf("Nextboot set successfully\n");
-		} else {
-			printf("Nextboot set failed\n");
-			rc = (-1);
-		}
-	} else  {
-		lprintf(LOG_ERR, "Invalid Kontron command: %s", argv[0]);
-		ipmi_kontron_help();
-		rc = (-1);
-	}
-	return rc;
-}
-
-static void
-ipmi_kontron_help(void)
-{
-	printf("Kontron Commands:  setsn setmfgdate nextboot\n");
-}
-
-int
-ipmi_kontronoem_set_large_buffer(struct ipmi_intf *intf, unsigned char size)
-{
-	uint8_t error_occurs = 0;
-	uint32_t prev_target_addr = intf->target_addr ;
-	if (intf->target_addr > 0 && (intf->target_addr != intf->my_addr)) {
-		intf->target_addr = intf->my_addr;
-		printf("Set local big buffer\n");
-		if (ipmi_kontronoem_send_set_large_buffer(intf, 0x0e, size) == 0) {
-			printf("Set local big buffer:success\n");
-		} else {
-			error_occurs = 1;
-		}
-		if (error_occurs == 0) {
-			if (ipmi_kontronoem_send_set_large_buffer(intf, 0x00, size) == 0) {
-				printf("IPMB was set\n");
-			} else {
-				/* Revert back the previous set large buffer */
-				error_occurs = 1;
-				ipmi_kontronoem_send_set_large_buffer( intf, 0x0e, 0 );
-			}
-		}
-		/* Restore target address */
-		intf->target_addr = prev_target_addr;
-	}
-	if (error_occurs == 0) {
-		if(ipmi_kontronoem_send_set_large_buffer(intf, 0x0e, size) == 0) {
-			/* printf("Set remote big buffer\n"); */
-		} else {
-			if (intf->target_addr > 0  && (intf->target_addr != intf->my_addr)) {
-				/* Error occurs revert back the previous set large buffer */
-				intf->target_addr = intf->my_addr;
-				/* ipmi_kontronoem_send_set_large_buffer(intf, 0x00, 0); */
-				ipmi_kontronoem_send_set_large_buffer(intf, 0x0e, 0);
-				intf->target_addr = prev_target_addr;
-			}
-		}
-	}
-	return error_occurs;
-}
-
-int
-ipmi_kontronoem_send_set_large_buffer(struct ipmi_intf *intf,
-		unsigned char channel, unsigned char size)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	uint8_t msg_data[2];
-	memset(msg_data, 0, sizeof(msg_data));
-	/* channel =~ 0x0e => Currently running interface */
-	msg_data[0] = channel;
-	msg_data[1] = size;
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = 0x3E;
-	/* Set Channel Buffer Length - OEM */
-	req.msg.cmd = 0x82;
-	req.msg.data = msg_data;
-	req.msg.data_len = 2;
-	req.msg.lun = 0x00;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL)  {
-		printf("Cannot send large buffer command\n");
-		return(-1);
-	} else if (rsp->ccode > 0)  {
-		printf("Invalid length for the selected interface (%s) %d\n",
-				val2str(rsp->ccode, completion_code_vals), rsp->ccode);
-		return(-1);
-	}
-	return 0;
-}
-
-/* ipmi_fru_set_serial_number -  Set the Serial Number in FRU
- *
- * @intf: ipmi interface
- * @id: fru id
- *
- * returns -1 on error
- * returns 1 if successful
- */
-static int
-ipmi_kontron_set_serial_number(struct ipmi_intf *intf)
-{
-	struct fru_header header;
-	struct fru_info fru;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	char *sn;
-	char *fru_area;
-	uint8_t checksum;
-	uint8_t *fru_data;
-	uint8_t msg_data[4];
-	uint8_t sn_size;
-	uint32_t board_sec_len;
-	uint32_t fru_data_offset;
-	uint32_t fru_data_offset_tmp;
-	uint32_t i;
-	uint32_t prod_sec_len;
-
-	sn = NULL;
-	fru_data = NULL;
-
-	memset(msg_data, 0, 4);
-	msg_data[0] = 0xb4;
-	msg_data[1] = 0x90;
-	msg_data[2] = 0x91;
-	msg_data[3] = 0x8b;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = 0x3E;
-	req.msg.cmd = 0x0C;
-	req.msg.data = msg_data;
-	req.msg.data_len = 4;
-	/* Set Lun, necessary for this oem command */
-	req.msg.lun = 0x03;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		printf(" Device not present (No Response)\n");
-		return (-1);
-	} else if (rsp->ccode > 0) {
-		printf(" This option is not implemented for this board\n");
-		return (-1);
-	}
-	sn_size = rsp->data_len;
-	sn = malloc(sn_size + 1);
-	if (sn == NULL) {
-		lprintf(LOG_ERR, "ipmitool: malloc failure");
-		return (-1);
-	}
-	memset(sn, 0, sn_size + 1);
-	memcpy(sn, rsp->data, sn_size);
-	if (verbose >= 1) {
-		printf("Original serial number is : [%s]\n", sn);
-	}
-	memset(msg_data, 0, 4);
-	msg_data[0] = 0;
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_STORAGE;
-	req.msg.cmd = GET_FRU_INFO;
-	req.msg.data = msg_data;
-	req.msg.data_len = 1;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		printf(" Device not present (No Response)\n");
-		free(sn);
-		sn = NULL;
-		return (-1);
-	} else if (rsp->ccode > 0) {
-		printf(" Device not present (%s)\n",
-				val2str(rsp->ccode, completion_code_vals));
-		free(sn);
-		sn = NULL;
-		return (-1);
-	}
-	memset(&fru, 0, sizeof(fru));
-	fru.size = (rsp->data[1] << 8) | rsp->data[0];
-	fru.access = rsp->data[2] & 0x1;
-	if (fru.size < 1) {
-		printf(" Invalid FRU size %d", fru.size);
-		free(sn);
-		sn = NULL;
-		return (-1);
-	}
-	/* retrieve the FRU header */
-	msg_data[0] = 0;
-	msg_data[1] = 0;
-	msg_data[2] = 0;
-	msg_data[3] = 8;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_STORAGE;
-	req.msg.cmd = GET_FRU_DATA;
-	req.msg.data = msg_data;
-	req.msg.data_len = 4;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		printf(" Device not present (No Response)\n");
-		free(sn);
-		sn = NULL;
-		return (-1);
-	} else if (rsp->ccode > 0) {
-		printf(" Device not present (%s)\n",
-				val2str(rsp->ccode, completion_code_vals));
-		free(sn);
-		sn = NULL;
-		return (-1);
-	}
-	if (verbose > 1) {
-		printbuf(rsp->data, rsp->data_len, "FRU DATA");
-	}
-	memcpy(&header, rsp->data + 1, 8);
-	if (header.version != 1) {
-		printf(" Unknown FRU header version 0x%02x",
-				header.version);
-		free(sn);
-		sn = NULL;
-		return(-1);
-	}
-	/* Set the Board Section */
-	board_sec_len = (header.offset.product * 8) - (header.offset.board * 8);
-	fru_data = malloc(fru.size);
-	if (fru_data == NULL) {
-		lprintf(LOG_ERR, "ipmitool: malloc failure");
-		free(sn);
-		sn = NULL;
-		return (-1);
-	}
-	memset(fru_data, 0, fru.size);
-	if (read_fru_area(intf, &fru, 0, (header.offset.board * 8),
-				board_sec_len, fru_data) < 0) {
-		free(sn);
-		sn = NULL;
-		free(fru_data);
-		fru_data = NULL;
-		return (-1);
-	}
-	/* Position at Board Manufacturer */
-	fru_data_offset = (header.offset.board * 8) + 6;
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset);
-	if (fru_area != NULL) {
-		free(fru_area);
-		fru_area = NULL;
-	}
-	/* Position at Board Product Name */
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset);
-	if (fru_area != NULL) {
-		free(fru_area);
-		fru_area = NULL;
-	}
-	fru_data_offset_tmp = fru_data_offset;
-	/* Position at Serial Number */
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset_tmp);
-	if (fru_area == NULL) {
-		lprintf(LOG_ERR, "Failed to read FRU Area string.");
-		free(fru_data);
-		fru_data = NULL;
-		free(sn);
-		sn = NULL;
-		return (-1);
-	}
-
-	fru_data_offset++;
-	if (strlen(fru_area) != sn_size) {
-		printf("The length of the serial number in the FRU Board Area is wrong.\n");
-		free(sn);
-		sn = NULL;
-		free(fru_data);
-		fru_data = NULL;
-		free(fru_area);
-		fru_area = NULL;
-		return(-1);
-	} else {
-		free(fru_area);
-		fru_area = NULL;
-	}
-	/* Copy the new serial number in the board section saved in memory*/
-	memcpy(fru_data + fru_data_offset, sn, sn_size);
-	checksum = 0;
-	/* Calculate Header Checksum */
-	for(i = (header.offset.board * 8);
-			i < (((header.offset.board * 8) + board_sec_len) - 2);
-			i++) {
-		checksum += fru_data[i];
-	}
-	checksum = (~checksum) + 1;
-	fru_data[(header.offset.board * 8) + board_sec_len - 1] = checksum;
-	/* Write the new FRU Board section */
-	if (write_fru_area(intf, &fru, 0, (header.offset.board * 8),
-				(header.offset.board * 8),
-				board_sec_len, fru_data) < 0) {
-		free(sn);
-		sn = NULL;
-		free(fru_data);
-		fru_data = NULL;
-		free(fru_area);
-		fru_area = NULL;
-		return(-1);
-	}
-	/* Set the Product Section */
-	prod_sec_len = (header.offset.multi * 8) - (header.offset.product * 8);
-	if (read_fru_area(intf, &fru, 0, (header.offset.product * 8),
-				prod_sec_len, fru_data) < 0) {
-		free(sn);
-		sn = NULL;
-		free(fru_data);
-		fru_data = NULL;
-		free(fru_area);
-		fru_area = NULL;
-		return(-1);
-	}
-	/* Position at Product Manufacturer */
-	fru_data_offset = (header.offset.product * 8) + 3;
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset);
-	if (fru_area != NULL) {
-		free(fru_area);
-		fru_area = NULL;
-	}
-	/* Position at Product Name */
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset);
-	if (fru_area != NULL) {
-		free(fru_area);
-		fru_area = NULL;
-	}
-	/* Position at Product Part */
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset);
-	if (fru_area != NULL) {
-		free(fru_area);
-		fru_area = NULL;
-	}
-	/* Position at Product Version */
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset);
-	if (fru_area != NULL) {
-		free(fru_area);
-		fru_area = NULL;
-	}
-	fru_data_offset_tmp = fru_data_offset;
-	/* Position at Serial Number */
-	fru_area = get_fru_area_str(fru_data, &fru_data_offset_tmp);
-	if (fru_area == NULL) {
-		lprintf(LOG_ERR, "Failed to read FRU Area string.");
-		free(sn);
-		sn = NULL;
-		free(fru_data);
-		fru_data = NULL;
-		return (-1);
-	}
-	fru_data_offset ++;
-	if (strlen(fru_area) != sn_size) {
-		free(sn);
-		sn = NULL;
-		free(fru_data);
-		fru_data = NULL;
-		free(fru_area);
-		fru_area = NULL;
-		printf("The length of the serial number in the FRU Product Area is wrong.\n");
-		return(-1);
-	}
-	/* Copy the new serial number in the product section saved in memory*/
-	memcpy(fru_data + fru_data_offset, sn, sn_size);
-	checksum = 0;
-	/* Calculate Header Checksum */
-	for (i = (header.offset.product * 8);
-			i < (((header.offset.product * 8) + prod_sec_len) - 2);
-			i ++) {
-		checksum += fru_data[i];
-	}
-	checksum = (~checksum) + 1;
-	fru_data[(header.offset.product * 8)+prod_sec_len - 1] = checksum;
-	/* Write the new FRU Board section */
-	if (write_fru_area(intf, &fru, 0, (header.offset.product * 8),
-				(header.offset.product * 8),
-				prod_sec_len, fru_data) < 0) {
-		free(sn);
-		sn = NULL;
-		free(fru_data);
-		fru_data = NULL;
-		free(fru_area);
-		fru_area = NULL;
-		return -1;
-	}
-	free(sn);
-	sn = NULL;
-	free(fru_data);
-	fru_data = NULL;
-	free(fru_area);
-	fru_area = NULL;
-	return(1);
-}
-
-/* ipmi_fru_set_mfg_date -  Set the Manufacturing Date in FRU
- *
- * @intf: ipmi interface
- * @id: fru id
- *
- * returns -1 on error
- * returns 1 if successful
- */
-static int
-ipmi_kontron_set_mfg_date (struct ipmi_intf *intf)
-{
-	struct fru_header header;
-	struct fru_info fru;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	uint8_t *fru_data;
-	uint8_t checksum;
-	uint8_t msg_data[4];
-	uint8_t mfg_date[3];
-	uint32_t board_sec_len;
-	uint32_t i;
-
-	memset(msg_data, 0, 4);
-	msg_data[0] = 0xb4;
-	msg_data[1] = 0x90;
-	msg_data[2] = 0x91;
-	msg_data[3] = 0x8b;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = 0x3E;
-	req.msg.cmd = 0x0E;
-	req.msg.data = msg_data;
-	req.msg.data_len = 4;
-	/* Set Lun temporary, necessary for this oem command */
-	req.msg.lun = 0x03;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL)  {
-		printf("Device not present (No Response)\n");
-		return(-1);
-	} else if (rsp->ccode > 0) {
-		printf("This option is not implemented for this board\n");
-		return(-1);
-	}
-	if (rsp->data_len != 3) {
-		printf("Invalid response for the Manufacturing date\n");
-		return(-1);
-	}
-	memset(mfg_date, 0, 3);
-	memcpy(mfg_date, rsp->data, 3);
-	memset(msg_data, 0, 4);
-	msg_data[0] = 0;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_STORAGE;
-	req.msg.cmd = GET_FRU_INFO;
-	req.msg.data = msg_data;
-	req.msg.data_len = 1;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		printf(" Device not present (No Response)\n");
-		return(-1);
-	} else if (rsp->ccode > 0) {
-		printf(" Device not present (%s)\n",
-				val2str(rsp->ccode, completion_code_vals));
-		return(-1);
-	}
-
-	memset(&fru, 0, sizeof(fru));
-	fru.size = (rsp->data[1] << 8) | rsp->data[0];
-	fru.access = rsp->data[2] & 0x1;
-	if (fru.size < 1) {
-		printf(" Invalid FRU size %d", fru.size);
-		return(-1);
-	}
-	/* retrieve the FRU header */
-	msg_data[0] = 0;
-	msg_data[1] = 0;
-	msg_data[2] = 0;
-	msg_data[3] = 8;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_STORAGE;
-	req.msg.cmd = GET_FRU_DATA;
-	req.msg.data = msg_data;
-	req.msg.data_len = 4;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		printf(" Device not present (No Response)\n");
-		return (-1);
-	} else if (rsp->ccode > 0) {
-		printf(" Device not present (%s)\n",
-				val2str(rsp->ccode, completion_code_vals));
-		return (-1);
-	}
-	if (verbose > 1) {
-		printbuf(rsp->data, rsp->data_len, "FRU DATA");
-	}
-	memcpy(&header, rsp->data + 1, 8);
-	if (header.version != 1) {
-		printf(" Unknown FRU header version 0x%02x",
-				header.version);
-		return(-1);
-	}
-	board_sec_len = (header.offset.product * 8) - (header.offset.board * 8);
-	fru_data = malloc(fru.size);
-	if(fru_data == NULL) {
-		lprintf(LOG_ERR, "ipmitool: malloc failure");
-		return(-1);
-	}
-	memset(fru_data, 0, fru.size);
-	if (read_fru_area(intf ,&fru ,0 ,(header.offset.board * 8),
-				board_sec_len ,fru_data) < 0) {
-		free(fru_data);
-		fru_data = NULL;
-		return(-1);
-	}
-	/* Copy the new manufacturing date in the board section saved in memory*/
-	memcpy(fru_data + (header.offset.board * 8) + 3, mfg_date, 3);
-	checksum = 0;
-	/* Calculate Header Checksum */
-	for (i = (header.offset.board * 8);
-			i < (((header.offset.board * 8) + board_sec_len) - 2);
-			i ++ ) {
-		checksum += fru_data[i];
-	}
-	checksum = (~checksum) + 1;
-	fru_data[(header.offset.board * 8)+board_sec_len - 1] = checksum;
-	/* Write the new FRU Board section */
-	if (write_fru_area(intf, &fru, 0, (header.offset.board * 8),
-				(header.offset.board * 8),
-				board_sec_len, fru_data) < 0) {
-		free(fru_data);
-		fru_data = NULL;
-		return (-1);
-	}
-	free(fru_data);
-	fru_data = NULL;
-	return (1);
-}
-
-static void
-ipmi_kontron_nextboot_help(void)
-{
-	int i;
-	printf("nextboot <device>\n"
-			"Supported devices:\n");
-	for (i = 0; bootdev[i] != 0; i++) {
-		printf("- %s\n", bootdev[i]);
-	}
-}
-
-/* ipmi_kontron_next_boot_set - Select the next boot order on CP6012
- *
- * @intf: ipmi interface
- * @id: fru id
- *
- * returns -1 on error
- * returns 1 if successful
- */
-static int
-ipmi_kontron_nextboot_set(struct ipmi_intf *intf, int argc, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	uint8_t msg_data[8];
-	int i;
-
-	memset(msg_data, 0, sizeof(msg_data));
-	msg_data[0] = 0xb4;
-	msg_data[1] = 0x90;
-	msg_data[2] = 0x91;
-	msg_data[3] = 0x8b;
-	msg_data[4] = 0x9d;
-	msg_data[5] = 0xFF;
-	msg_data[6] = 0xFF; /* any */
-	for (i = 0; bootdev[i] != 0; i++) {
-		if (strcmp(argv[0], bootdev[i]) == 0) {
-			msg_data[5] = i;
-			break;
-		}
-	}
-	/* Invalid device selected? */
-	if (msg_data[5] == 0xFF) {
-		printf("Unknown boot device: %s\n", argv[0]);
-		return (-1);
-	}
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = 0x3E;
-	req.msg.cmd = 0x02;
-	req.msg.data = msg_data;
-	req.msg.data_len = 7;
-	/* Set Lun temporary, necessary for this oem command */
-	req.msg.lun = 0x03;
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		printf("Device not present (No Response)\n");
-		return(-1);
-	} else if (rsp->ccode > 0) {
-		printf("Device not present (%s)\n",
-				val2str(rsp->ccode, completion_code_vals));
-		return (-1);
-	}
-	return 0;
-}
diff --git a/lib/ipmi_main.c b/lib/ipmi_main.c
index a752b59..c1489cb 100644
--- a/lib/ipmi_main.c
+++ b/lib/ipmi_main.c
@@ -67,7 +67,6 @@
 #include <ipmitool/ipmi_raw.h>
 #include <ipmitool/ipmi_pef.h>
 #include <ipmitool/ipmi_oem.h>
-#include <ipmitool/ipmi_ekanalyzer.h>
 #include <ipmitool/ipmi_picmg.h>
 
 #ifdef HAVE_CONFIG_H
@@ -349,8 +348,6 @@ ipmi_acquire_ipmb_address(struct ipmi_intf * intf)
 {
 	if (intf->picmg_avail) {
 		return ipmi_picmg_ipmb_address(intf);
-	} else if (intf->vita_avail) {
-		return ipmi_vita_ipmb_address(intf);
 	} else {
 		return 0;
     }
@@ -955,14 +952,12 @@ ipmi_main(int argc, char ** argv,
 
 	if (!ipmi_oem_active(ipmi_main_intf, "i82571spt")) {
 		/*
-		 * Attempt picmg/vita discovery of the actual interface
+		 * Attempt picmg discovery of the actual interface
 		 * address, unless the users specified an address.
 		 * Address specification always overrides discovery
 		 */
 		if (picmg_discover(ipmi_main_intf)) {
 			ipmi_main_intf->picmg_avail = 1;
-		} else if (vita_discover(ipmi_main_intf)) {
-			ipmi_main_intf->vita_avail = 1;
 		}
 	}
 
@@ -1053,14 +1048,10 @@ ipmi_main(int argc, char ** argv,
 	/* Enable Big Buffer when requested */
 	if ( my_long_packet_size != 0 ) {
 		/* Enable Big Buffer when requested */
-		if (!ipmi_oem_active(ipmi_main_intf, "kontron") ||
-			ipmi_kontronoem_set_large_buffer(ipmi_main_intf,
-					my_long_packet_size ) == 0) {
-			printf("Setting large buffer to %i\n", my_long_packet_size);
-			my_long_packet_set = 1;
-			ipmi_intf_set_max_request_data_size(ipmi_main_intf,
-					my_long_packet_size);
-		}
+		printf("Setting large buffer to %i\n", my_long_packet_size);
+		my_long_packet_set = 1;
+		ipmi_intf_set_max_request_data_size(ipmi_main_intf,
+				my_long_packet_size);
 	}
 
 	ipmi_main_intf->cmdlist = cmdlist;
@@ -1072,13 +1063,6 @@ ipmi_main(int argc, char ** argv,
 	else
 		rc = ipmi_cmd_run(ipmi_main_intf, NULL, 0, NULL);
 
-	if (my_long_packet_set == 1) {
-		if (ipmi_oem_active(ipmi_main_intf, "kontron")) {
-			/* Restore defaults */
-			ipmi_kontronoem_set_large_buffer( ipmi_main_intf, 0 );
-		}
-	}
-
 	/* clean repository caches */
 	ipmi_cleanup(ipmi_main_intf);
 
diff --git a/lib/ipmi_sunoem.c b/lib/ipmi_sunoem.c
deleted file mode 100644
index 7f7a58b..0000000
--- a/lib/ipmi_sunoem.c
+++ /dev/null
@@ -1,2431 +0,0 @@
-/*
- * Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <strings.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/time.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <errno.h>
-#include <time.h>
-#include <unistd.h>
-#include <signal.h>
-#include <ctype.h>
-#include <sys/time.h>
-#include <limits.h>
-#include <fcntl.h>
-
-#include <termios.h>
-
-#include <ipmitool/ipmi.h>
-#include <ipmitool/ipmi_intf.h>
-#include <ipmitool/helper.h>
-#include <ipmitool/log.h>
-#include <ipmitool/ipmi_sel.h>
-#include <ipmitool/ipmi_sdr.h>
-#include <ipmitool/ipmi_strings.h>
-#include <ipmitool/ipmi_channel.h>
-#include <ipmitool/ipmi_sunoem.h>
-#include <ipmitool/ipmi_raw.h>
-
-static const struct valstr sunoem_led_type_vals[] = {
-	{ 0, "OK2RM" },
-	{ 1, "SERVICE" },
-	{ 2, "ACT" },
-	{ 3, "LOCATE" },
-	{ 0xFF, NULL },
-};
-
-static const struct valstr sunoem_led_mode_vals[] = {
-	{ 0, "OFF" },
-	{ 1, "ON" },
-	{ 2, "STANDBY" },
-	{ 3, "SLOW" },
-	{ 4, "FAST" },
-	{ 0xFF, NULL },
-};
-
-static const struct valstr sunoem_led_mode_optvals[] = {
-	{ 0, "STEADY_OFF" },
-	{ 1, "STEADY_ON" },
-	{ 2, "STANDBY_BLINK" },
-	{ 3, "SLOW_BLINK" },
-	{ 4, "FAST_BLINK" },
-	{ 0xFF, NULL },
-};
-
-#define SUNOEM_SUCCESS 1
-
-#define IPMI_SUNOEM_GETFILE_VERSION {3,2,0,0}
-#define IPMI_SUNOEM_GETBEHAVIOR_VERSION {3,2,0,0}
-
-/*
- * PRINT_NORMAL: print out the LED value as normal
- * PRINT_ERROR: print out "na" for the LED value
- */
-typedef enum
-{
-	PRINT_NORMAL = 0, PRINT_ERROR
-} print_status_t;
-
-int ret_get = 0;
-int ret_set = 0;
-
-static void
-ipmi_sunoem_usage(void)
-{
-	lprintf(LOG_NOTICE, "Usage: sunoem <command> [option...]");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, "Commands:");
-	lprintf(LOG_NOTICE, " - cli [<command string> ...]");
-	lprintf(LOG_NOTICE, "      Execute SP CLI commands.");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - led get [<sensor_id>] [ledtype]");
-	lprintf(LOG_NOTICE, "      - Read status of LED found in Generic Device Locator.");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - led set <sensor_id> <led_mode> [led_type]");
-	lprintf(LOG_NOTICE, "      - Set mode of LED found in Generic Device Locator.");
-	lprintf(LOG_NOTICE, "      - You can pass 'all' as the <senso_rid> to change the LED mode of all sensors.");
-	lprintf(LOG_NOTICE, "      - Use 'sdr list generic' command to get list of Generic");
-	lprintf(LOG_NOTICE, "      - Devices that are controllable LEDs.");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, "      - Required SIS LED Mode:");
-	lprintf(LOG_NOTICE, "          OFF          Off");
-	lprintf(LOG_NOTICE, "          ON           Steady On");
-	lprintf(LOG_NOTICE, "          STANDBY      100ms on 2900ms off blink rate");
-	lprintf(LOG_NOTICE, "          SLOW         1HZ blink rate");
-	lprintf(LOG_NOTICE, "          FAST         4HZ blink rate");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, "      - Optional SIS LED Type:");
-	lprintf(LOG_NOTICE, "          OK2RM        OK to Remove");
-	lprintf(LOG_NOTICE, "          SERVICE      Service Required");
-	lprintf(LOG_NOTICE, "          ACT          Activity");
-	lprintf(LOG_NOTICE, "          LOCATE       Locate");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - nacname <ipmi_nac_name>");
-	lprintf(LOG_NOTICE, "      - Returns the full nac name");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - ping NUMBER <q>");
-	lprintf(LOG_NOTICE, "      - Send and Receive NUMBER (64 Byte) packets.");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, "      - q - Quiet. Displays output at start and end");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - getval <target_name>");
-	lprintf(LOG_NOTICE, "      - Returns the ILOM property value");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - setval <property name> <property value> <timeout>");
-	lprintf(LOG_NOTICE, "      - Sets the ILOM property value");
-	lprintf(LOG_NOTICE, "      - If timeout is not specified, the default is 5 sec.");
-	lprintf(LOG_NOTICE, "      - NOTE: must be executed locally on host, not remotely over LAN!");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - sshkey del <user_id>");
-	lprintf(LOG_NOTICE, "      - Delete ssh key for user id from authorized_keys,");
-	lprintf(LOG_NOTICE, "      - view users with 'user list' command.");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - sshkey set <user_id> <id_rsa.pub>");
-	lprintf(LOG_NOTICE, "      - Set ssh key for a userid into authorized_keys,");
-	lprintf(LOG_NOTICE, "      - view users with 'user list' command.");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - version");
-	lprintf(LOG_NOTICE, "      - Display the software version");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - nacname <ipmi_nac_name>");
-	lprintf(LOG_NOTICE, "      - Returns the full nac name");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - getfile <file_string_id> <destination_file_name>");
-	lprintf(LOG_NOTICE, "      - Copy file <file_string_id> to <destination_file_name>");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, "      - File string ids:");
-	lprintf(LOG_NOTICE, "          SSH_PUBKEYS");
-	lprintf(LOG_NOTICE, "          DIAG_PASSED");
-	lprintf(LOG_NOTICE, "          DIAG_FAILED");
-	lprintf(LOG_NOTICE, "          DIAG_END_TIME");
-	lprintf(LOG_NOTICE, "          DIAG_INVENTORY");
-	lprintf(LOG_NOTICE, "          DIAG_TEST_LOG");
-	lprintf(LOG_NOTICE, "          DIAG_START_TIME");
-	lprintf(LOG_NOTICE, "          DIAG_UEFI_LOG");
-	lprintf(LOG_NOTICE, "          DIAG_TEST_LOG");
-	lprintf(LOG_NOTICE, "          DIAG_LAST_LOG");
-	lprintf(LOG_NOTICE, "          DIAG_LAST_CMD");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, " - getbehavior <behavior_string_id>");
-	lprintf(LOG_NOTICE, "      - Test if ILOM behavior is enabled");
-	lprintf(LOG_NOTICE, "");
-	lprintf(LOG_NOTICE, "      - Behavior string ids:");
-	lprintf(LOG_NOTICE, "          SUPPORTS_SIGNED_PACKAGES");
-	lprintf(LOG_NOTICE, "          REQUIRES_SIGNED_PACKAGES");
-	lprintf(LOG_NOTICE, "");
-}
-
-#define SUNOEM_FAN_MODE_AUTO    0x00
-#define SUNOEM_FAN_MODE_MANUAL  0x01
-
-static void
-__sdr_list_empty(struct sdr_record_list * head)
-{
-	struct sdr_record_list * e, *f;
-	for (e = head; e != NULL; e = f) {
-		f = e->next;
-		free(e);
-	}
-	head = NULL;
-}
-
-/*
- *  led_print
- *  Print out the led name and the state, if stat is PRINT_NORMAL.
- *  Otherwise, print out the led name and "na".
- *  The state parameter is not referenced if stat is not PRINT_NORMAL.
- */
-static void
-led_print(const char * name, print_status_t stat, uint8_t state)
-{
-	const char *theValue;
-
-	if (stat == PRINT_NORMAL) {
-		theValue = val2str(state, sunoem_led_mode_vals);
-	} else {
-		theValue = "na";
-	}
-
-	if (csv_output) {
-		printf("%s,%s\n", name, theValue);
-	} else {
-		printf("%-16s | %s\n", name, theValue);
-	}
-}
-
-#define CC_NORMAL                  0x00
-#define CC_PARAM_OUT_OF_RANGE      0xc9
-#define CC_DEST_UNAVAILABLE        0xd3
-#define CC_UNSPECIFIED_ERR         0xff
-#define CC_INSUFFICIENT_PRIVILEGE  0xd4
-#define CC_INV_CMD                 0xc1
-#define CC_INV_DATA_FIELD          0xcc
-
-/*
- * sunoem_led_get(....)
- *
- * OUTPUT:
- *   SUNOEM_EC_INVALID_ARG         if dev is NULL,
- *   SUNOEM_EC_BMC_NOT_RESPONDING  if no reply is obtained from BMC,
- *   SUNOEM_EC_BMC_CCODE_NONZERO   if completion code is nonzero,
- *   SUNOEM_EC_SUCCESS             otherwise.
- */
-static sunoem_ec_t
-sunoem_led_get(struct ipmi_intf * intf,	struct sdr_record_generic_locator * dev,
-		int ledtype, struct ipmi_rs **loc_rsp)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t rqdata[7];
-	int rqdata_len;
-
-	if (dev == NULL) {
-		*loc_rsp = NULL;
-		return (SUNOEM_EC_INVALID_ARG);
-	}
-
-	rqdata[0] = dev->dev_slave_addr;
-	if (ledtype == 0xFF)
-		rqdata[1] = dev->oem;
-	else
-		rqdata[1] = ledtype;
-
-	rqdata[2] = dev->dev_access_addr;
-	rqdata[3] = dev->oem;
-	rqdata[4] = dev->entity.id;
-	rqdata[5] = dev->entity.instance;
-	rqdata[6] = 0;
-	rqdata_len = 7;
-
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_LED_GET;
-	req.msg.lun = dev->lun;
-	req.msg.data = rqdata;
-	req.msg.data_len = rqdata_len;
-
-	rsp = intf->sendrecv(intf, &req);
-	/*
-	 * Just return NULL if there was
-	 * an error.
-	 */
-	if (rsp == NULL) {
-		*loc_rsp = NULL;
-		return (SUNOEM_EC_BMC_NOT_RESPONDING);
-	} else if (rsp->ccode > 0) {
-		*loc_rsp = rsp;
-		return (SUNOEM_EC_BMC_CCODE_NONZERO);
-	} else {
-		*loc_rsp = rsp;
-		return (SUNOEM_EC_SUCCESS);
-	}
-}
-
-static struct ipmi_rs *
-sunoem_led_set(struct ipmi_intf * intf, struct sdr_record_generic_locator * dev,
-		int ledtype, int ledmode)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	uint8_t rqdata[9];
-	int rqdata_len;
-
-	if (dev == NULL)
-		return NULL;
-
-	rqdata[0] = dev->dev_slave_addr;
-
-	if (ledtype == 0xFF)
-		rqdata[1] = dev->oem;
-	else
-		rqdata[1] = ledtype;
-
-	rqdata[2] = dev->dev_access_addr;
-	rqdata[3] = dev->oem;
-	rqdata[4] = ledmode;
-	rqdata[5] = dev->entity.id;
-	rqdata[6] = dev->entity.instance;
-	rqdata[7] = 0;
-	rqdata[8] = 0;
-	rqdata_len = 9;
-
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_LED_SET;
-	req.msg.lun = dev->lun;
-	req.msg.data = rqdata;
-	req.msg.data_len = rqdata_len;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Sun OEM Set LED command failed.");
-		return NULL;
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Sun OEM Set LED command failed: %s",
-				val2str(rsp->ccode, completion_code_vals));
-		return NULL;
-	}
-
-	return (rsp);
-}
-
-static void
-sunoem_led_get_byentity(struct ipmi_intf * intf, uint8_t entity_id,
-		uint8_t entity_inst, int ledtype)
-{
-	struct ipmi_rs * rsp;
-	struct sdr_record_list *elist, *e;
-	struct entity_id entity;
-	sunoem_ec_t res;
-
-	if (entity_id == 0)
-		return;
-
-	/* lookup sdrs with this entity */
-	memset(&entity, 0, sizeof(struct entity_id));
-	entity.id = entity_id;
-	entity.instance = entity_inst;
-
-	elist = ipmi_sdr_find_sdr_byentity(intf, &entity);
-
-	if (elist == NULL)
-		ret_get = -1;
-
-	/* for each generic sensor get its led state */
-	for (e = elist; e != NULL; e = e->next) {
-		if (e->type != SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR)
-			continue;
-
-		res = sunoem_led_get(intf, e->record.genloc, ledtype, &rsp);
-
-		if (res == SUNOEM_EC_SUCCESS && rsp && rsp->data_len == 1) {
-			led_print((const char *) e->record.genloc->id_string, PRINT_NORMAL,
-					rsp->data[0]);
-		} else {
-			led_print((const char *) e->record.genloc->id_string, PRINT_ERROR,
-					0);
-			if (res != SUNOEM_EC_BMC_CCODE_NONZERO|| !rsp
-			|| rsp->ccode != CC_DEST_UNAVAILABLE) {
-				ret_get = -1;
-			}
-		}
-	}
-	__sdr_list_empty(elist);
-}
-
-static void
-sunoem_led_set_byentity(struct ipmi_intf * intf, uint8_t entity_id,
-		uint8_t entity_inst, int ledtype, int ledmode)
-{
-	struct ipmi_rs * rsp;
-	struct sdr_record_list *elist, *e;
-	struct entity_id entity;
-
-	if (entity_id == 0)
-		return;
-
-	/* lookup sdrs with this entity */
-	memset(&entity, 0, sizeof(struct entity_id));
-	entity.id = entity_id;
-	entity.instance = entity_inst;
-
-	elist = ipmi_sdr_find_sdr_byentity(intf, &entity);
-
-	if (elist == NULL)
-		ret_set = -1;
-
-	/* for each generic sensor set its led state */
-	for (e = elist; e != NULL; e = e->next) {
-
-		if (e->type != SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR)
-			continue;
-
-		rsp = sunoem_led_set(intf, e->record.genloc, ledtype, ledmode);
-		if (rsp && rsp->data_len == 0) {
-			led_print((const char *) e->record.genloc->id_string, PRINT_NORMAL,
-					ledmode);
-		} else if (rsp == NULL) {
-			ret_set = -1;
-		}
-	}
-
-	__sdr_list_empty(elist);
-}
-
-/*
- * IPMI Request Data: 5 bytes
- *
- * [byte 0]  devAddr     Value from the "Device Slave Address" field in
- *                       LED's Generic Device Locator record in the SDR
- * [byte 1]  led         LED Type: OK2RM, ACT, LOCATE, SERVICE
- * [byte 2]  ctrlrAddr   Controller address; value from the "Device
- *                       Access Address" field, 0x20 if the LED is local
- * [byte 3]  hwInfo      The OEM field from the SDR record
- * [byte 4]  force       1 = directly access the device
- *                       0 = go thru its controller
- *                       Ignored if LED is local
- *
- * The format below is for Sun Blade Modular systems only
- * [byte 4]  entityID    The entityID field from the SDR record
- * [byte 5]  entityIns   The entityIns field from the SDR record
- * [byte 6]  force       1 = directly access the device
- *                       0 = go thru its controller
- *                       Ignored if LED is local
- */
-static int
-ipmi_sunoem_led_get(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	struct ipmi_rs * rsp;
-	struct sdr_record_list *sdr;
-	struct sdr_record_list *alist, *a;
-	struct sdr_record_entity_assoc *assoc;
-	int ledtype = 0xFF;
-	int i;
-	sunoem_ec_t res;
-
-	/*
-	 * sunoem led/sbled get <id> [type]
-	 */
-
-	if (argc < 1 || strncmp(argv[0], "help", 4) == 0) {
-		ipmi_sunoem_usage();
-		return (0);
-	}
-
-	if (argc > 1) {
-		ledtype = str2val(argv[1], sunoem_led_type_vals);
-		if (ledtype == 0xFF)
-			lprintf(LOG_ERR,
-					"Unknow ledtype, will use data from the SDR oem field");
-	}
-
-	if (strncasecmp(argv[0], "all", 3) == 0) {
-		/* do all generic sensors */
-		alist = ipmi_sdr_find_sdr_bytype(intf,
-		SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR);
-
-		if (alist == NULL)
-			return (-1);
-
-		for (a = alist; a != NULL; a = a->next) {
-			if (a->type != SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR)
-				continue;
-			if (a->record.genloc->entity.logical)
-				continue;
-
-			res = sunoem_led_get(intf, a->record.genloc, ledtype, &rsp);
-
-			if (res == SUNOEM_EC_SUCCESS && rsp && rsp->data_len == 1) {
-				led_print((const char *) a->record.genloc->id_string,
-						PRINT_NORMAL, rsp->data[0]);
-			} else {
-				led_print((const char *) a->record.genloc->id_string,
-						PRINT_ERROR, 0);
-				if (res != SUNOEM_EC_BMC_CCODE_NONZERO|| !rsp ||
-				rsp->ccode != CC_DEST_UNAVAILABLE) {
-					ret_get = -1;
-				}
-			}
-		}
-		__sdr_list_empty(alist);
-
-		if (ret_get == -1)
-			return (-1);
-
-		return (0);
-	}
-
-	/* look up generic device locator record in SDR */
-	sdr = ipmi_sdr_find_sdr_byid(intf, argv[0]);
-
-	if (sdr == NULL) {
-		lprintf(LOG_ERR, "No Sensor Data Record found for %s", argv[0]);
-		return (-1);
-	}
-
-	if (sdr->type != SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR) {
-		lprintf(LOG_ERR, "Invalid SDR type %d", sdr->type);
-		return (-1);
-	}
-
-	if (!sdr->record.genloc->entity.logical) {
-		/*
-		 * handle physical entity
-		 */
-
-		res = sunoem_led_get(intf, sdr->record.genloc, ledtype, &rsp);
-
-		if (res == SUNOEM_EC_SUCCESS && rsp && rsp->data_len == 1) {
-			led_print((const char *) sdr->record.genloc->id_string,
-					PRINT_NORMAL, rsp->data[0]);
-
-		} else {
-			led_print((const char *) sdr->record.genloc->id_string, PRINT_ERROR,
-					0);
-			if (res != SUNOEM_EC_BMC_CCODE_NONZERO|| !rsp
-			|| rsp->ccode != CC_DEST_UNAVAILABLE) {
-				ret_get = -1;
-			}
-		}
-
-		if (ret_get == -1)
-			return (-1);
-
-		return (0);
-	}
-
-	/*
-	 * handle logical entity for LED grouping
-	 */
-
-	lprintf(LOG_INFO, "LED %s is logical device", argv[0]);
-
-	/* get entity assoc records */
-	alist = ipmi_sdr_find_sdr_bytype(intf, SDR_RECORD_TYPE_ENTITY_ASSOC);
-
-	if (alist == NULL)
-		return (-1);
-
-	for (a = alist; a != NULL; a = a->next) {
-		if (a->type != SDR_RECORD_TYPE_ENTITY_ASSOC)
-			continue;
-		assoc = a->record.entassoc;
-		if (assoc == NULL)
-			continue;
-
-		/* check that the entity id/instance matches our generic record */
-		if (assoc->entity.id != sdr->record.genloc->entity.id
-				|| assoc->entity.instance
-						!= sdr->record.genloc->entity.instance)
-			continue;
-
-		if (assoc->flags.isrange) {
-			/*
-			 * handle ranged entity associations
-			 *
-			 * the test for non-zero entity id is handled in
-			 * sunoem_led_get_byentity()
-			 */
-
-			/* first range set - id 1 and 2 must be equal */
-			if (assoc->entity_id_1 == assoc->entity_id_2)
-				for (i = assoc->entity_inst_1; i <= assoc->entity_inst_2; i++)
-					sunoem_led_get_byentity(intf, assoc->entity_id_1, i,
-							ledtype);
-
-			/* second range set - id 3 and 4 must be equal */
-			if (assoc->entity_id_3 == assoc->entity_id_4)
-				for (i = assoc->entity_inst_3; i <= assoc->entity_inst_4; i++)
-					sunoem_led_get_byentity(intf, assoc->entity_id_3, i,
-							ledtype);
-		} else {
-			/*
-			 * handle entity list
-			 */
-			sunoem_led_get_byentity(intf, assoc->entity_id_1,
-					assoc->entity_inst_1, ledtype);
-			sunoem_led_get_byentity(intf, assoc->entity_id_2,
-					assoc->entity_inst_2, ledtype);
-			sunoem_led_get_byentity(intf, assoc->entity_id_3,
-					assoc->entity_inst_3, ledtype);
-			sunoem_led_get_byentity(intf, assoc->entity_id_4,
-					assoc->entity_inst_4, ledtype);
-		}
-	}
-
-	__sdr_list_empty(alist);
-
-	if (ret_get == -1)
-		return (-1);
-
-	return (0);
-}
-
-/*
- * IPMI Request Data: 7 bytes
- *
- * [byte 0]  devAddr     Value from the "Device Slave Address" field in
- *                       LED's Generic Device Locator record in the SDR
- * [byte 1]  led         LED Type: OK2RM, ACT, LOCATE, SERVICE
- * [byte 2]  ctrlrAddr   Controller address; value from the "Device
- *                       Access Address" field, 0x20 if the LED is local
- * [byte 3]  hwInfo      The OEM field from the SDR record
- * [byte 4]  mode        LED Mode: OFF, ON, STANDBY, SLOW, FAST
- * [byte 5]  force       TRUE - directly access the device
- *                       FALSE - go thru its controller
- *                       Ignored if LED is local
- * [byte 6]  role        Used by BMC for authorization purposes
- *
- * The format below is for Sun Blade Modular systems only
- * [byte 5]  entityID    The entityID field from the SDR record
- * [byte 6]  entityIns   The entityIns field from the SDR record
- * [byte 7]  force       TRUE - directly access the device
- *                       FALSE - go thru its controller
- *                       Ignored if LED is local
- * [byte 8]  role        Used by BMC for authorization purposes
- *
- *
- * IPMI Response Data: 1 byte
- *
- * [byte 0]  mode     LED Mode: OFF, ON, STANDBY, SLOW, FAST
- */
-
-static int
-ipmi_sunoem_led_set(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	struct ipmi_rs * rsp;
-	struct sdr_record_list *sdr;
-	struct sdr_record_list *alist, *a;
-	struct sdr_record_entity_assoc *assoc;
-	int ledmode;
-	int ledtype = 0xFF;
-	int i;
-
-	/*
-	 * sunoem led/sbled set <id> <mode> [type]
-	 */
-
-	if (argc < 2 || strncmp(argv[0], "help", 4) == 0) {
-		ipmi_sunoem_usage();
-		return (0);
-	}
-
-	ledmode = str2val(argv[1], sunoem_led_mode_vals);
-	if (ledmode == 0xFF) {
-		ledmode = str2val(argv[1], sunoem_led_mode_optvals);
-		if (ledmode == 0xFF) {
-			lprintf(LOG_NOTICE, "Invalid LED Mode: %s", argv[1]);
-			return (-1);
-		}
-	}
-
-	if (argc > 3) {
-		ledtype = str2val(argv[2], sunoem_led_type_vals);
-		if (ledtype == 0xFF)
-			lprintf(LOG_ERR,
-					"Unknow ledtype, will use data from the SDR oem field");
-	}
-
-	if (strncasecmp(argv[0], "all", 3) == 0) {
-		/* do all generic sensors */
-		alist = ipmi_sdr_find_sdr_bytype(intf,
-		SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR);
-
-		if (alist == NULL)
-			return (-1);
-
-		for (a = alist; a != NULL; a = a->next) {
-			if (a->type != SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR)
-				continue;
-			if (a->record.genloc->entity.logical)
-				continue;
-			rsp = sunoem_led_set(intf, a->record.genloc, ledtype, ledmode);
-			if (rsp && rsp->ccode == 0)
-				led_print((const char *) a->record.genloc->id_string,
-						PRINT_NORMAL, ledmode);
-			else
-				ret_set = -1;
-		}
-		__sdr_list_empty(alist);
-
-		if (ret_set == -1)
-			return (-1);
-
-		return (0);
-	}
-
-	/* look up generic device locator records in SDR */
-	sdr = ipmi_sdr_find_sdr_byid(intf, argv[0]);
-
-	if (sdr == NULL) {
-		lprintf(LOG_ERR, "No Sensor Data Record found for %s", argv[0]);
-		return (-1);
-	}
-
-	if (sdr->type != SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR) {
-		lprintf(LOG_ERR, "Invalid SDR type %d", sdr->type);
-		return (-1);
-	}
-
-	if (!sdr->record.genloc->entity.logical) {
-		/*
-		 * handle physical entity
-		 */
-		rsp = sunoem_led_set(intf, sdr->record.genloc, ledtype, ledmode);
-		if (rsp && rsp->ccode == 0)
-			led_print(argv[0], PRINT_NORMAL, ledmode);
-		else
-			return (-1);
-
-		return (0);
-	}
-
-	/*
-	 * handle logical entity for LED grouping
-	 */
-
-	lprintf(LOG_INFO, "LED %s is logical device", argv[0]);
-
-	/* get entity assoc records */
-	alist = ipmi_sdr_find_sdr_bytype(intf, SDR_RECORD_TYPE_ENTITY_ASSOC);
-
-	if (alist == NULL)
-		return (-1);
-
-	for (a = alist; a != NULL; a = a->next) {
-		if (a->type != SDR_RECORD_TYPE_ENTITY_ASSOC)
-			continue;
-		assoc = a->record.entassoc;
-		if (assoc == NULL)
-			continue;
-
-		/* check that the entity id/instance matches our generic record */
-		if (assoc->entity.id != sdr->record.genloc->entity.id
-				|| assoc->entity.instance
-						!= sdr->record.genloc->entity.instance)
-			continue;
-
-		if (assoc->flags.isrange) {
-			/*
-			 * handle ranged entity associations
-			 *
-			 * the test for non-zero entity id is handled in
-			 * sunoem_led_get_byentity()
-			 */
-
-			/* first range set - id 1 and 2 must be equal */
-			if (assoc->entity_id_1 == assoc->entity_id_2)
-				for (i = assoc->entity_inst_1; i <= assoc->entity_inst_2; i++)
-					sunoem_led_set_byentity(intf, assoc->entity_id_1, i,
-							ledtype, ledmode);
-
-			/* second range set - id 3 and 4 must be equal */
-			if (assoc->entity_id_3 == assoc->entity_id_4)
-				for (i = assoc->entity_inst_3; i <= assoc->entity_inst_4; i++)
-					sunoem_led_set_byentity(intf, assoc->entity_id_3, i,
-							ledtype, ledmode);
-		} else {
-			/*
-			 * handle entity list
-			 */
-			sunoem_led_set_byentity(intf, assoc->entity_id_1,
-					assoc->entity_inst_1, ledtype, ledmode);
-			sunoem_led_set_byentity(intf, assoc->entity_id_2,
-					assoc->entity_inst_2, ledtype, ledmode);
-			sunoem_led_set_byentity(intf, assoc->entity_id_3,
-					assoc->entity_inst_3, ledtype, ledmode);
-			sunoem_led_set_byentity(intf, assoc->entity_id_4,
-					assoc->entity_inst_4, ledtype, ledmode);
-		}
-	}
-
-	__sdr_list_empty(alist);
-
-	if (ret_set == -1)
-		return (-1);
-
-	return (0);
-}
-
-static int
-ipmi_sunoem_sshkey_del(struct ipmi_intf * intf, uint8_t uid)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-
-	memset(&req, 0, sizeof(struct ipmi_rq));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_DEL_SSH_KEY;
-	req.msg.data = &uid;
-	req.msg.data_len = 1;
-
-	rsp = intf->sendrecv(intf, &req);
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Unable to delete ssh key for UID %d", uid);
-		return (-1);
-	} else if (rsp->ccode > 0) {
-		lprintf(LOG_ERR, "Unable to delete ssh key for UID %d: %s", uid,
-				val2str(rsp->ccode, completion_code_vals));
-		return (-1);
-	}
-
-	printf("Deleted SSH key for user id %d\n", uid);
-	return (0);
-}
-
-#define SSHKEY_BLOCK_SIZE	64
-static int
-ipmi_sunoem_sshkey_set(struct ipmi_intf * intf, uint8_t uid, char * ifile)
-{
-	struct ipmi_rs * rsp;
-	struct ipmi_rq req;
-	FILE * fp;
-	int count = 0;
-	uint8_t wbuf[SSHKEY_BLOCK_SIZE + 3];
-	int32_t i_size = 0;
-	int32_t r = 0;
-	int32_t size = 0;
-
-	if (ifile == NULL) {
-		lprintf(LOG_ERR, "Invalid or misisng input filename.");
-		return (-1);
-	}
-
-	fp = ipmi_open_file_read(ifile);
-	if (fp == NULL) {
-		lprintf(LOG_ERR, "Unable to open file '%s' for reading.", ifile);
-		return (-1);
-	}
-
-	memset(&req, 0, sizeof(struct ipmi_rq));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_SET_SSH_KEY;
-	req.msg.data = wbuf;
-
-	if (fseek(fp, 0, SEEK_END) == (-1)) {
-		lprintf(LOG_ERR, "Failed to seek in file '%s'.", ifile);
-		if (fp != NULL)
-			fclose(fp);
-
-		return (-1);
-	}
-
-	size = (int32_t) ftell(fp);
-	if (size < 0) {
-		lprintf(LOG_ERR, "Failed to seek in file '%s'.", ifile);
-		if (fp != NULL)
-			fclose(fp);
-
-		return (-1);
-	} else if (size == 0) {
-		lprintf(LOG_ERR, "File '%s' is empty.", ifile);
-		if (fp != NULL)
-			fclose(fp);
-
-		return (-1);
-	}
-
-	if (fseek(fp, 0, SEEK_SET) == (-1)) {
-		lprintf(LOG_ERR, "Failed to seek in file '%s'.", ifile);
-		if (fp != NULL)
-			fclose(fp);
-
-		return (-1);
-	}
-
-	printf("Setting SSH key for user id %d...", uid);
-
-	for (r = 0; r < size; r += i_size) {
-		i_size = size - r;
-		if (i_size > SSHKEY_BLOCK_SIZE)
-			i_size = SSHKEY_BLOCK_SIZE;
-
-		memset(wbuf, 0, SSHKEY_BLOCK_SIZE);
-		fseek(fp, r, SEEK_SET);
-		count = fread(wbuf + 3, 1, i_size, fp);
-		if (count != i_size) {
-			printf("failed\n");
-			lprintf(LOG_ERR, "Unable to read %ld bytes from file '%s'.", i_size,
-					ifile);
-			if (fp != NULL)
-				fclose(fp);
-
-			return (-1);
-		}
-
-		printf(".");
-		fflush(stdout);
-
-		wbuf[0] = uid;
-		if ((r + SSHKEY_BLOCK_SIZE) >= size)
-			wbuf[1] = 0xff;
-		else {
-			if ((r / SSHKEY_BLOCK_SIZE) > UINT8_MAX) {
-				printf("failed\n");
-				lprintf(LOG_ERR, "Unable to pack byte %ld from file '%s'.", r,
-						ifile);
-				if (fp != NULL)
-					fclose(fp);
-
-				return (-1);
-			}
-			wbuf[1] = (uint8_t) (r / SSHKEY_BLOCK_SIZE);
-		}
-
-		wbuf[2] = (uint8_t) i_size;
-
-		req.msg.data_len = i_size + 3;
-
-		rsp = intf->sendrecv(intf, &req);
-		if (rsp == NULL) {
-			printf("failed\n");
-			lprintf(LOG_ERR, "Unable to set ssh key for UID %d.", uid);
-			if (fp != NULL)
-				fclose(fp);
-
-			return (-1);
-		} /* if (rsp == NULL) */
-		if (rsp->ccode != 0) {
-			printf("failed\n");
-			lprintf(LOG_ERR, "Unable to set ssh key for UID %d, %s.", uid,
-					val2str(rsp->ccode, completion_code_vals));
-			if (fp != NULL)
-				fclose(fp);
-
-			return (-1);
-		} /* if (rsp->ccode != 0) */
-	}
-
-	printf("done\n");
-
-	fclose(fp);
-	return (0);
-}
-
-/*
- * This structure is used in both the request to and response from the BMC.
- */
-#define SUNOEM_CLI_LEGACY_VERSION       1
-#define SUNOEM_CLI_SEQNUM_VERSION       2
-#define SUNOEM_CLI_VERSION       SUNOEM_CLI_SEQNUM_VERSION
-#define SUNOEM_CLI_HEADER        8 /* command + spare + handle */
-#define SUNOEM_CLI_BUF_SIZE      (80 - SUNOEM_CLI_HEADER) /* Total 80 bytes */
-#define SUNOEM_CLI_MSG_SIZE(msg) (SUNOEM_CLI_HEADER + strlen((msg).buf) + 1)
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	/*
-	 * Set version to SUNOEM_CLI_VERSION.
-	 */
-	uint8_t version;
-	/*
-	 * The command in a request, or in a response indicates an error if
-	 * non-zero.
-	 */
-	uint8_t command_response;
-	uint8_t seqnum;
-	uint8_t spare;
-	/*
-	 * Opaque 4-byte handle, supplied in the response to an OPEN request,
-	 * and used in all subsequent POLL and CLOSE requests.
-	 */
-	uint8_t handle[4];
-	/*
-	 * The client data in a request, or the server data in a response. Must
-	 * by null terminated, i.e., it must be at least one byte, but can be
-	 * smaller if there's less data.
-	 */
-	char buf[SUNOEM_CLI_BUF_SIZE];
-}__attribute__((packed)) sunoem_cli_msg_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-/*
- * Command codes for the command_request field in each request.
- */
-#define SUNOEM_CLI_CMD_OPEN   0 /* Open a new connection */
-#define SUNOEM_CLI_CMD_FORCE  1 /* Close any existing connection, then open */
-#define SUNOEM_CLI_CMD_CLOSE  2 /* Close the current connection */
-#define SUNOEM_CLI_CMD_POLL   3 /* Poll for new data to/from the server */
-#define SUNOEM_CLI_CMD_EOF    4 /* Poll, client is out of data */
-
-#define SUNOEM_CLI_MAX_RETRY  3 /* Maximum number of retries */
-
-#define SUNOEM_CLI_INVALID_VER_ERR "Invalid version"
-#define SUNOEM_CLI_BUSY_ERR        "Busy"
-
-typedef enum
-{
-	C_CTL_B = 0x02, /* same as left arrow */
-	C_CTL_C = 0x03,
-	C_CTL_D = 0x04,
-	C_CTL_F = 0x06, /* same as right arrow */
-	C_CTL_N = 0x0E, /* same as down arrow */
-	C_CTL_P = 0x10, /* same as up arrow */
-	C_DEL = 0x7f
-} canon_char_t;
-
-static int
-sunoem_cli_unbufmode_start(FILE *f, struct termios *orig_ts)
-{
-	struct termios ts;
-	int rc;
-
-	if ((rc = tcgetattr(fileno(f), &ts))) {
-		return (rc);
-	}
-	*orig_ts = ts;
-	ts.c_lflag &= ~(ICANON | ECHO | ISIG);
-	ts.c_cc[VMIN] = 1;
-	if ((rc = tcsetattr(fileno(f), TCSAFLUSH, &ts))) {
-		return (rc);
-	}
-
-	return (0);
-}
-
-static int
-sunoem_cli_unbufmode_stop(FILE *f, struct termios *ts)
-{
-	int rc;
-
-	if ((rc = tcsetattr(fileno(f), TCSAFLUSH, ts))) {
-		return (rc);
-	}
-
-	return (0);
-}
-
-static int
-ipmi_sunoem_cli(struct ipmi_intf * intf, int argc, char *argv[])
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	sunoem_cli_msg_t cli_req;
-	sunoem_cli_msg_t *cli_rsp;
-	int arg_num = 0;
-	int arg_pos = 0;
-	time_t wait_time = 0;
-	int retries;
-	static uint8_t SunOemCliActingVersion = SUNOEM_CLI_VERSION;
-
-	unsigned short first_char = 0; /*first char on the line*/
-	struct termios orig_ts;
-	int error = 0;
-
-	time_t now = 0;
-	int delay = 0;
-
-	/* Prepare to open an SP shell session */
-	memset(&cli_req, 0, sizeof(cli_req));
-	cli_req.version = SunOemCliActingVersion;
-	cli_req.command_response = SUNOEM_CLI_CMD_OPEN;
-	if (argc > 0 && strcmp(argv[0], "force") == 0) {
-		cli_req.command_response = SUNOEM_CLI_CMD_FORCE;
-		argc--;
-		argv++;
-	}
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_CLI;
-	req.msg.data = (uint8_t *) &cli_req;
-	req.msg.data_len = SUNOEM_CLI_HEADER + 1;
-	retries = 0;
-	while (1) {
-		cli_req.version = SunOemCliActingVersion;
-		rsp = intf->sendrecv(intf, &req);
-		if (rsp == NULL) {
-			lprintf(LOG_ERR, "Sun OEM cli command failed");
-			return (-1);
-		}
-		cli_rsp = (sunoem_cli_msg_t *) rsp->data;
-		if ((cli_rsp->command_response != 0) || (rsp->ccode != 0)) {
-			if (strncmp(cli_rsp->buf, SUNOEM_CLI_INVALID_VER_ERR,
-					sizeof(SUNOEM_CLI_INVALID_VER_ERR) - 1) == 0
-					|| strncmp(&(cli_rsp->buf[1]), SUNOEM_CLI_INVALID_VER_ERR,
-							sizeof(SUNOEM_CLI_INVALID_VER_ERR) - 1) == 0) {
-				if (SunOemCliActingVersion == SUNOEM_CLI_VERSION) {
-					/* Server doesn't support version SUNOEM_CLI_VERSION
-					 Fall back to legacy version, and try again*/
-					SunOemCliActingVersion = SUNOEM_CLI_LEGACY_VERSION;
-					continue;
-				}
-				/* Server doesn't support legacy version either */
-				lprintf(LOG_ERR, "Failed to connect: %s", cli_rsp->buf);
-				return (-1);
-			} else if (strncmp(cli_rsp->buf, SUNOEM_CLI_BUSY_ERR,
-					sizeof(SUNOEM_CLI_BUSY_ERR) - 1) == 0) {
-				if (retries++ < SUNOEM_CLI_MAX_RETRY) {
-					lprintf(LOG_INFO, "Failed to connect: %s, retrying",
-							cli_rsp->buf);
-					sleep(2);
-					continue;
-				}
-				lprintf(LOG_ERR, "Failed to connect: %s", cli_rsp->buf);
-				return (-1);
-			} else {
-				lprintf(LOG_ERR, "Failed to connect: %s", cli_rsp->buf);
-				return (-1);
-			}
-		}
-		break;
-	}
-	if (SunOemCliActingVersion == SUNOEM_CLI_SEQNUM_VERSION) {
-		/*
-		 * Bit 1 of seqnum is used as an alternating sequence number
-		 * to allow a server that supports it to detect when a retry is being sent from the host IPMI driver.
-		 * Typically when this occurs, the server's last response message would have been dropped.
-		 * Once the server detects this condition, it will know that it should retry sending the response.
-		 */
-		cli_req.seqnum ^= 0x1;
-	}
-	printf("Connected. Use ^D to exit.\n");
-	fflush(NULL);
-
-	/*
-	 * Remember the handle provided in the response, and issue a
-	 * series of "poll" commands to send and get data
-	 */
-	memcpy(cli_req.handle, cli_rsp->handle, 4);
-	cli_req.command_response = SUNOEM_CLI_CMD_POLL;
-	/*
-	 * If no arguments make input unbuffered and so interactive
-	 */
-	if (argc == 0) {
-		if (sunoem_cli_unbufmode_start(stdin, &orig_ts)) {
-			lprintf(LOG_ERR, "Failed to set interactive mode: %s",
-					strerror(errno));
-			return (-1);
-		}
-	}
-	while (rsp->ccode == 0 && cli_rsp->command_response == 0) {
-		int rc = 0;
-		int count = 0;
-		cli_req.buf[0] = '\0';
-		if (argc == 0) {
-			/*
-			 * Accept input from stdin. Use select so we don't hang if
-			 * there's no input to read. Select timeout is 500 msec.
-			 */
-			struct timeval tv = { 0, 500000 }; /* 500 msec */
-			fd_set rfds;
-			FD_ZERO(&rfds);
-			FD_SET(0, &rfds);
-			rc = select(1, &rfds, NULL, NULL, &tv);
-			if (rc < 0) {
-				/* Select returned an error so close and exit */
-				printf("Broken pipe\n");
-				cli_req.command_response = SUNOEM_CLI_CMD_CLOSE;
-			} else if (rc > 0) {
-				/* Read data from stdin */
-				count = read(0, cli_req.buf, 1 /* sizeof (cli_req.buf) - 1 */);
-				/*
-				 * If select said there was data but there was nothing to
-				 * read. This implies user hit ^D.
-				 * Also handle ^D input when pressed as first char at a new line.
-				 */
-				if (count <= 0 || (first_char && cli_req.buf[0] == C_CTL_D)) {
-					cli_req.command_response = SUNOEM_CLI_CMD_EOF;
-					count = 0;
-				}
-				first_char = cli_req.buf[0] == '\n' || cli_req.buf[0] == '\r';
-			}
-		} else {
-			/*
-			 * Get data from command line arguments
-			 */
-			now = time(NULL);
-			if (now < wait_time) {
-				/* Do nothing; we're waiting */
-			} else if (arg_num >= argc) {
-				/* Last arg was sent. Set EOF */
-				cli_req.command_response = SUNOEM_CLI_CMD_EOF;
-			} else if (strncmp(argv[arg_num], "@wait=", 6) == 0) {
-				/* This is a wait command */
-				char *s = &argv[arg_num][6];
-				delay = 0;
-				if (*s != '\0') {
-					if (str2int(s, &delay)) {
-						delay = 0;
-					}
-					if (delay < 0) {
-						delay = 0;
-					}
-				}
-				wait_time = now + delay;
-				arg_num++;
-			} else {
-				/*
-				 * Take data from args. It may be that the argument is larger
-				 * than the request buffer can hold. So pull off BUF_SIZE
-				 * number of characters at a time. When we've consumed the
-				 * entire arg, append a newline and advance to the next arg.
-				 */
-				int i;
-				char *s = argv[arg_num];
-				for (i = arg_pos;
-						s[i] != '\0' && count < (SUNOEM_CLI_BUF_SIZE - 2);
-						i++, count++) {
-					cli_req.buf[count] = s[i];
-				}
-				if (s[i] == '\0') {
-					/* Reached end of the arg string, so append a newline */
-					cli_req.buf[count++] = '\n';
-					/* Reset pos to 0 and advance to the next arg next time */
-					arg_pos = 0;
-					arg_num++;
-				} else {
-					/*
-					 * Otherwise, there's still more characters in the arg
-					 * to send, so remember where we left off
-					 */
-					arg_pos = i;
-				}
-			}
-		}
-		/*
-		 * Now send the clients's data (if any) and get data back from the
-		 * server. Loop while the server is giving us data until we suck
-		 * it dry.
-		 */
-		do {
-			cli_req.buf[count++] = '\0'; /* Terminate the string */
-			memset(&req, 0, sizeof(req));
-			req.msg.netfn = IPMI_NETFN_SUNOEM;
-			req.msg.cmd = 0x19;
-			req.msg.data = (uint8_t *) &cli_req;
-			req.msg.data_len = SUNOEM_CLI_HEADER + count;
-			for (retries = 0; retries <= SUNOEM_CLI_MAX_RETRY; retries++) {
-				rsp = intf->sendrecv(intf, &req);
-				if (rsp == NULL) {
-					lprintf(LOG_ERR, "Communication error.");
-					error = 1;
-					goto cleanup;
-				}
-				if (rsp->ccode == IPMI_CC_TIMEOUT) { /* Retry if timed out. */
-					if (retries == SUNOEM_CLI_MAX_RETRY) { /* If it's the last retry. */
-						lprintf(LOG_ERR, "Excessive timeout.");
-						error = 1;
-						goto cleanup;
-					}
-					continue;
-				}
-				break;
-			} /* for (retries = 0; retries <= SUNOEM_CLI_MAX_RETRY; retries++) */
-
-			if (SunOemCliActingVersion == SUNOEM_CLI_SEQNUM_VERSION) {
-				cli_req.seqnum ^= 0x1; /* Toggle sequence number after request is sent */
-			}
-
-			cli_rsp = (sunoem_cli_msg_t *) rsp->data;
-			/* Make sure response string is null terminated */
-			cli_rsp->buf[sizeof(cli_rsp->buf) - 1] = '\0';
-			printf("%s", cli_rsp->buf);
-			fflush(NULL); /* Flush partial lines to stdout */
-			count = 0; /* Don't re-send the client's data */
-			if (cli_req.command_response == SUNOEM_CLI_CMD_EOF
-					&& cli_rsp->command_response != 0 && rsp->ccode == 0) {
-				cli_rsp->command_response = 1;
-			}
-		} while (cli_rsp->command_response == 0 && cli_rsp->buf[0] != '\0');
-	}
-
-cleanup:
-	/* Restore original input mode if cli was running interactively */
-	if (argc == 0) {
-		if (sunoem_cli_unbufmode_stop(stdin, &orig_ts)) {
-			lprintf(LOG_ERR, "Failed to restore interactive mode: %s",
-					strerror(errno));
-			return (-1);
-		}
-	}
-
-	return ((error == 0 && cli_rsp->command_response == SUNOEM_SUCCESS) ? 0 : -1);
-}
-#define ECHO_DATA_SIZE 64
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	uint16_t seq_num;
-	unsigned char data[ECHO_DATA_SIZE];
-}__attribute__((packed)) sunoem_echo_msg_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-/*
- * Send and receive X packets to the BMC. Each packet has a
- * payload size of (sunoem_echo_msg_t) bytes. Each packet is tagged with a
- * sequence number
- */
-static int
-ipmi_sunoem_echo(struct ipmi_intf * intf, int argc, char *argv[])
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	sunoem_echo_msg_t echo_req;
-	sunoem_echo_msg_t *echo_rsp;
-	struct timeval start_time;
-	struct timeval end_time;
-
-	int rc = 0;
-	int received = 0;
-	int transmitted = 0;
-	int quiet_mode = 0;
-
-	uint16_t num, i, j;
-	uint32_t total_time, resp_time, min_time, max_time;
-
-	if (argc < 1) {
-		return (1);
-	}
-
-	if (argc == 2) {
-		if (*(argv[1]) == 'q') {
-			quiet_mode = 1;
-		} else {
-			lprintf(LOG_ERR, "Unknown option '%s' given.", argv[1]);
-			return (-1);
-		}
-	} else if (argc > 2) {
-		lprintf(LOG_ERR,
-				"Too many parameters given. See help for more information.");
-		return (-1);
-	}
-	/* The number of packets to send/receive */
-	if (str2ushort(argv[0], &num) != 0) {
-		lprintf(LOG_ERR,
-				"Given number of packets is either invalid or out of range.");
-		return (-1);
-	}
-
-	/* Fill in data packet */
-	for (i = 0; i < ECHO_DATA_SIZE; i++) {
-		echo_req.data[i] = (uint8_t) i;
-	}
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_ECHO;
-	req.msg.data = (uint8_t *) &echo_req;
-	req.msg.data_len = sizeof(sunoem_echo_msg_t);
-	echo_req.seq_num = i;
-	min_time = INT_MAX;
-	max_time = 0;
-	total_time = 0;
-	for (i = 0; i < num; i++) {
-		echo_req.seq_num = i;
-		transmitted++;
-		gettimeofday(&start_time, NULL);
-		rsp = intf->sendrecv(intf, &req);
-		gettimeofday(&end_time, NULL);
-		resp_time = ((end_time.tv_sec - start_time.tv_sec) * 1000)
-				+ ((end_time.tv_usec - start_time.tv_usec) / 1000);
-		if ((rsp == NULL) || (rsp->ccode != 0)) {
-			lprintf(LOG_ERR, "Sun OEM echo command failed. Seq # %d",
-					echo_req.seq_num);
-			rc = (-2);
-			break;
-		}
-		echo_rsp = (sunoem_echo_msg_t *) rsp->data;
-
-		/* Test if sequence # is valid */
-		if (echo_rsp->seq_num != echo_req.seq_num) {
-			printf("Invalid Seq # Expecting %d Received %d\n", echo_req.seq_num,
-					echo_rsp->seq_num);
-			rc = (-2);
-			break;
-		}
-
-		/* Test if response length is valid */
-		if (rsp->session.msglen == req.msg.data_len) {
-			printf("Invalid payload size for seq # %d. "
-					"Expecting %d Received %d\n", echo_rsp->seq_num,
-					req.msg.data_len, rsp->session.msglen);
-			rc = (-2);
-			break;
-		}
-
-		/* Test if the data is valid */
-		for (j = 0; j < ECHO_DATA_SIZE; j++) {
-			if (echo_rsp->data[j] != j) {
-				printf("Corrupt data packet. Seq # %d Offset %d\n",
-						echo_rsp->seq_num, j);
-				break;
-			}
-		} /* for (j = 0; j < ECHO_DATA_SIZE; j++) */
-
-		/* If the for loop terminated early - data is corrupt */
-		if (j != ECHO_DATA_SIZE) {
-			rc = (-2);
-			break;
-		}
-
-		/* cumalative time */
-		total_time += resp_time;
-
-		/* min time */
-		if (resp_time < min_time) {
-			min_time = resp_time;
-		}
-
-		/* max time */
-		if (resp_time > max_time) {
-			max_time = resp_time;
-		}
-
-		received++;
-		if (!quiet_mode) {
-			printf("Receive %u Bytes - Seq. # %d time=%d ms\n",
-					sizeof(sunoem_echo_msg_t), echo_rsp->seq_num, resp_time);
-		}
-	} /* for (i = 0; i < num; i++) */
-	printf("%d packets transmitted, %d packets received\n", transmitted,
-			received);
-	if (received) {
-		printf("round-trip min/avg/max = %d/%d/%d ms\n", min_time,
-				total_time / received, max_time);
-	}
-
-	return (rc);
-} /* ipmi_sunoem_echo(...) */
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	unsigned char oem_record_ver_num;
-	unsigned char major;
-	unsigned char minor;
-	unsigned char update;
-	unsigned char micro;
-	char nano[10];
-	char revision[10];
-	char version[40];
-	/*
-	 * When adding new fields (using the spare bytes),
-	 * add it immediately after the spare field to
-	 * ensure backward compatability.
-	 *
-	 * e.g.   char version[40];
-	 *        unsigned char spare[11];
-	 *        int new_item;
-	 *    } sunoem_version_response_t;
-	 */
-	unsigned char spare[15];
-}__attribute__((packed)) sunoem_version_response_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-typedef struct
-{
-	unsigned char major;
-	unsigned char minor;
-	unsigned char update;
-	unsigned char micro;
-} supported_version_t;
-
-static int
-ipmi_sunoem_getversion(struct ipmi_intf * intf,
-		sunoem_version_response_t **version_rsp)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_VERSION;
-	req.msg.data = NULL;
-	req.msg.data_len = 0;
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Sun OEM Get SP Version Failed.");
-		return (-1);
-	}
-	if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Sun OEM Get SP Version Failed: %d", rsp->ccode);
-		return (-1);
-	}
-
-	*version_rsp = (sunoem_version_response_t *) rsp->data;
-
-	return (0);
-}
-
-static void
-ipmi_sunoem_print_required_version(const supported_version_t* supp_ver)
-{
-	lprintf(LOG_ERR, "Command is not supported by this version of ILOM,"
-			" required at least: %d.%d.%d.%d", supp_ver->major, supp_ver->minor,
-			supp_ver->update, supp_ver->micro);
-}
-
-/*
- * Function checks current version result against required version.
- * Returns:
- *  - negative value if current ILOM version is smaller than required or
- *    in case of error
- *  - positive value if current ILOM version is greater than required
- *  - 0 if there is an exact ILOM version match
- */
-static int
-ipmi_sunoem_checkversion(struct ipmi_intf * intf, supported_version_t* supp_ver)
-{
-	sunoem_version_response_t *version_rsp;
-	int i = 1;
-
-	if (ipmi_sunoem_getversion(intf, &version_rsp)) {
-		lprintf(LOG_ERR, "Unable to get ILOM version");
-		return (-1);
-	}
-
-	if (version_rsp->major < supp_ver->major) return (-i);
-	if (version_rsp->major > supp_ver->major) return (i);
-	/*version_rsp->major == supp_ver->major*/
-	++i;
-
-	if (version_rsp->minor < supp_ver->minor) return (-i);
-	if (version_rsp->minor > supp_ver->minor) return (i);
-	/*version_rsp->minor == supp_ver->minor*/
-	++i;
-
-	if (version_rsp->update < supp_ver->update) return (-i);
-	if (version_rsp->update > supp_ver->update) return (i);
-	/*version_rsp->update == supp_ver->update*/
-	++i;
-
-	if (version_rsp->micro < supp_ver->micro) return (-i);
-	if (version_rsp->micro > supp_ver->micro) return (i);
-	/*version_rsp->micro == supp_ver->micro*/
-
-	return (0);
-}
-
-/*
- * Extract the SP version data including
- * - major #
- * - minor #
- * - update #
- * - micro #
- * - nano #
- * - Revision/Build #
- */
-static int
-ipmi_sunoem_version(struct ipmi_intf * intf)
-{
-	sunoem_version_response_t *version_rsp;
-	int rc = ipmi_sunoem_getversion(intf, &version_rsp);
-
-	if (!rc) {
-		printf("Version: %s\n", version_rsp->version);
-	}
-
-	return (rc);
-}
-
-/*
- * IPMI Max string length is 16 bytes
- * define in usr/src/common/include/ami/IPMI_SDRRecord.h
- */
-#define MAX_ID_STR_LEN  16
-#define MAX_SUNOEM_NAC_SIZE 64
-#define LUAPI_MAX_OBJ_PATH_LEN 256
-#define LUAPI_MAX_OBJ_VAL_LEN 1024
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	unsigned char seq_num;
-	char nac_name[MAX_SUNOEM_NAC_SIZE];
-}__attribute__((packed)) sunoem_nacname_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-/*
- * Retrieve the full NAC name of the IPMI target.
- *
- * The returned nac name may be larger than the payload size.
- * In which case, it make take several request/payload to retrieve
- * the entire full path name
- *
- * The initial seq_num is set to 0. If the return seq_num is incremented,
- * only the 1st 72 bytes of the nac name is returned and the caller
- * needs to get the next set of string data.
- * If the returned seq_num is identical to the input seq_num, all data
- * has been returned.
- */
-static int
-ipmi_sunoem_nacname(struct ipmi_intf * intf, int argc, char *argv[])
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	sunoem_nacname_t nacname_req;
-	sunoem_nacname_t *nacname_rsp;
-	char full_nac_name[LUAPI_MAX_OBJ_PATH_LEN];
-
-	if (argc < 1) {
-		return (1);
-	}
-
-	if (strlen(argv[0]) > MAX_ID_STR_LEN) {
-		lprintf(LOG_ERR,
-				"Sun OEM nacname command failed: Max size on IPMI name");
-		return (-1);
-	}
-
-	nacname_req.seq_num = 0;
-	strcpy(nacname_req.nac_name, argv[0]);
-
-	full_nac_name[0] = '\0';
-	while (1) {
-		memset(&req, 0, sizeof(req));
-		req.msg.netfn = IPMI_NETFN_SUNOEM;
-		req.msg.cmd = IPMI_SUNOEM_NACNAME;
-		req.msg.data = (uint8_t *) &nacname_req;
-		req.msg.data_len = sizeof(sunoem_nacname_t);
-		rsp = intf->sendrecv(intf, &req);
-
-		if (rsp == NULL) {
-			lprintf(LOG_ERR, "Sun OEM nacname command failed.");
-			return (-1);
-		}
-		if (rsp->ccode != 0) {
-			lprintf(LOG_ERR, "Sun OEM nacname command failed: %d", rsp->ccode);
-			return (-1);
-		}
-
-		nacname_rsp = (sunoem_nacname_t *) rsp->data;
-		strncat(full_nac_name, nacname_rsp->nac_name, MAX_SUNOEM_NAC_SIZE);
-
-		/*
-		 * break out of the loop if there is no more data
-		 * In most cases, if not all, the NAC name fits into a
-		 * single payload
-		 */
-		if (nacname_req.seq_num == nacname_rsp->seq_num) {
-			break;
-		}
-
-		/* Get the next seq of string bytes */
-		nacname_req.seq_num = nacname_rsp->seq_num;
-
-		/* Check if we exceeded the size of the full nac name */
-		if ((nacname_req.seq_num * MAX_SUNOEM_NAC_SIZE) > LUAPI_MAX_OBJ_PATH_LEN) {
-			lprintf(LOG_ERR,
-					"Sun OEM nacname command failed: invalid path length");
-			return (-1);
-		}
-	}
-
-	printf("NAC Name: %s\n", full_nac_name);
-	return (0);
-}
-
-/* Constants used by ipmi_sunoem_getval */
-#define MAX_SUNOEM_VAL_PAYLOAD 79
-#define MAX_SUNOEM_VAL_COMPACT_PAYLOAD 56
-
-/*
- * SUNOEM GET/SET LUAPI Commands
- *
- * SUNOEM_REQ_VAL - Request LUAPI Property Value
- * SUNOEM_GET_VAL - Return the value from  SUNOEM_REQ_VAL
- * SUNOEM_SET_VAL - Set the LUAPI Property value
- * SUNOEM_GET_STATUS - Return the Status from SUNOEM_SET_VAL
- */
-#define SUNOEM_REQ_VAL 1
-#define SUNOEM_GET_VAL 2
-#define SUNOEM_SET_VAL 3
-#define SUNOEM_GET_STATUS 4
-
-/* Status Code */
-#define SUNOEM_REQ_RECV 1
-#define SUNOEM_REQ_FAILED 2
-#define SUNOEM_DATA_READY 3
-#define SUNOEM_DATA_NOT_READY 4
-#define SUNOEM_DATA_NOT_FOUND 5
-#define GETVAL_MAX_RETRIES 5
-
-/* Parameter type Codes */
-#define SUNOEM_LUAPI_TARGET 0
-#define SUNOEM_LUAPI_VALUE  1
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	unsigned char cmd_code;
-	unsigned char luapi_value[MAX_SUNOEM_VAL_PAYLOAD];
-}__attribute__((packed)) sunoem_getval_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-/*
- * REQUEST PAYLOAD
- *
- * cmd_code - SUNOEM GET/SET LUAPI Cmds - see above
- * param_type: 0: luapi_data contains the luapi property name
- *             1: luapi_data contains the luapi value
- * luapi_data: Either luapi property name or value
- * tid: Transaction ID. If 0. This is the initial request for the
- *      param_type. If tid > 0, this luapi_data string is a concatenation
- *      of the previous request. Handle cases where the LUAPI target name
- *      or value is > MAX_SUNOEM_VAL_COMPACT_PAYLOAD
- * eof: If non zero, this is the last payload for the request
- */
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	unsigned char cmd_code;
-	unsigned char param_type;
-	unsigned char tid;
-	unsigned char eof;
-	char luapi_data[MAX_SUNOEM_VAL_COMPACT_PAYLOAD];
-}__attribute__((packed)) sunoem_setval_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-/*
- * RESPONSE PAYLOAD
- *
- * status_code - see above for code definitions
- * tid - transaction ID - assigned ny the ILOM stack
- */
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	unsigned char status_code;
-	unsigned char tid;
-}__attribute__((packed)) sunoem_setval_resp_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-/*
- * Return the ILOM target property value
- */
-static int
-ipmi_sunoem_getval(struct ipmi_intf * intf, int argc, char *argv[])
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	sunoem_getval_t getval_req;
-	sunoem_getval_t *getval_rsp;
-	int i;
-
-	const char* sp_path = "/SP";
-	supported_version_t supp_ver = { 3, 2, 0, 0 };
-
-	if (argc < 1) {
-		return (1);
-	}
-
-	if (strlen(argv[0]) > MAX_SUNOEM_VAL_PAYLOAD) {
-		lprintf(LOG_ERR,
-				"Sun OEM get value command failed: Max size on IPMI name");
-		return (-1);
-	}
-
-	if ((ipmi_sunoem_checkversion(intf, &supp_ver) < 0)
-			&& (!strncmp(argv[0], sp_path, strlen(sp_path)))) {
-		argv[0][1] = 'X'; /*replace SP by X to gain access to hidden properties*/
-		memmove(&argv[0][2], &argv[0][3], strlen(argv[0]) - 2);
-	}
-
-	/*
-	 * Setup the initial request to fetch the data.
-	 * Upon function return, the next cmd (SUNOEM_GET_VAL)
-	 * can be requested.
-	 */
-	memset(&getval_req, 0, sizeof(getval_req));
-	strncpy((char*) getval_req.luapi_value, argv[0], MAX_SUNOEM_VAL_PAYLOAD);
-	getval_req.cmd_code = SUNOEM_REQ_VAL;
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_GETVAL;
-	req.msg.data = (uint8_t *) &getval_req;
-	req.msg.data_len = sizeof(sunoem_getval_t);
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Sun OEM getval1 command failed.");
-		return (-1);
-	}
-	if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Sun OEM getval1 command failed: %d", rsp->ccode);
-		return (-1);
-	}
-
-	/*
-	 * Fetch the data value - if it is not ready,
-	 * retry the request up to GETVAL_MAX_RETRIES
-	 */
-	for (i = 0; i < GETVAL_MAX_RETRIES; i++) {
-		memset(&req, 0, sizeof(req));
-		req.msg.netfn = IPMI_NETFN_SUNOEM;
-		req.msg.cmd = IPMI_SUNOEM_GETVAL;
-		getval_req.cmd_code = SUNOEM_GET_VAL;
-		req.msg.data = (uint8_t *) &getval_req;
-		req.msg.data_len = sizeof(sunoem_getval_t);
-		rsp = intf->sendrecv(intf, &req);
-
-		if (rsp == NULL) {
-			lprintf(LOG_ERR, "Sun OEM getval2 command failed.");
-			return (-1);
-		}
-
-		if (rsp->ccode != 0) {
-			lprintf(LOG_ERR, "Sun OEM getval2 command failed: %d", rsp->ccode);
-			return (-1);
-		}
-
-		getval_rsp = (sunoem_getval_t *) rsp->data;
-
-		if (getval_rsp->cmd_code == SUNOEM_DATA_READY) {
-			printf("Target Value: %s\n", getval_rsp->luapi_value);
-			return (0);
-		} else if (getval_rsp->cmd_code == SUNOEM_DATA_NOT_FOUND) {
-			lprintf(LOG_ERR, "Target: %s not found", getval_req.luapi_value);
-			return (-1);
-		}
-
-		sleep(1);
-	}
-
-	lprintf(LOG_ERR, "Unable to retrieve target value.");
-	return (-1);
-}
-
-static int
-send_luapi_prop_name(struct ipmi_intf * intf, int len, char *prop_name,
-		unsigned char *tid_num)
-{
-	int i = 0;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	sunoem_setval_t setval_req;
-	sunoem_setval_resp_t *setval_rsp;
-
-	*tid_num = 0;
-	while (i < len) {
-		/*
-		 * Setup the request,
-		 * Upon function return, the next cmd (SUNOEM_SET_VAL)
-		 * can be requested.
-		 */
-		memset(&req, 0, sizeof(req));
-		memset(&setval_req, 0, sizeof(sunoem_setval_t));
-		req.msg.netfn = IPMI_NETFN_SUNOEM;
-		req.msg.cmd = IPMI_SUNOEM_SETVAL;
-		setval_req.cmd_code = SUNOEM_SET_VAL;
-		setval_req.param_type = SUNOEM_LUAPI_TARGET;
-		setval_req.tid = *tid_num;
-		setval_req.eof = 0;
-		/*
-		 * If the property name is > payload, only copy
-		 * the payload size and increment the string offset (i)
-		 * for the next payload
-		 */
-		if (strlen(&(prop_name[i])) > MAX_SUNOEM_VAL_COMPACT_PAYLOAD) {
-			strncpy(setval_req.luapi_data, &(prop_name[i]),
-			MAX_SUNOEM_VAL_COMPACT_PAYLOAD);
-		} else {
-			strncpy(setval_req.luapi_data, &(prop_name[i]),
-					strlen(&(prop_name[i])));
-		}
-		req.msg.data = (uint8_t *) &setval_req;
-		req.msg.data_len = sizeof(sunoem_setval_t);
-		rsp = intf->sendrecv(intf, &req);
-
-		if (rsp == NULL) {
-			lprintf(LOG_ERR, "Sun OEM setval prop name: response is NULL");
-			return (-1);
-		}
-
-		if (rsp->ccode != 0) {
-			lprintf(LOG_ERR, "Sun OEM setval prop name: request failed: %d",
-					rsp->ccode);
-			return (-1);
-		}
-
-		setval_rsp = (sunoem_setval_resp_t *) rsp->data;
-
-		/*
-		 * If the return code is other than data received, the
-		 * request failed
-		 */
-		if (setval_rsp->status_code != SUNOEM_REQ_RECV) {
-			lprintf(LOG_ERR,
-					"Sun OEM setval prop name: invalid status code: %d",
-					setval_rsp->status_code);
-			return (-1);
-		}
-		/* Use the tid returned by ILOM */
-		*tid_num = setval_rsp->tid;
-		/* Increment the string offset */
-		i += MAX_SUNOEM_VAL_COMPACT_PAYLOAD;
-	}
-
-	return (0);
-}
-
-static int
-send_luapi_prop_value(struct ipmi_intf * intf, int len,	char *prop_value,
-		unsigned char tid_num)
-{
-	int i = 0;
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	sunoem_setval_t setval_req;
-	sunoem_setval_resp_t *setval_rsp;
-
-	while (i < len) {
-		/*
-		 * Setup the request,
-		 * Upon function return, the next cmd (SUNOEM_GET_VAL)
-		 * can be requested.
-		 */
-		memset(&req, 0, sizeof(req));
-		memset(&setval_req, 0, sizeof(sunoem_setval_t));
-		req.msg.netfn = IPMI_NETFN_SUNOEM;
-		req.msg.cmd = IPMI_SUNOEM_SETVAL;
-		setval_req.cmd_code = SUNOEM_SET_VAL;
-		setval_req.param_type = SUNOEM_LUAPI_VALUE;
-		setval_req.tid = tid_num;
-		/*
-		 * If the property name is > payload, only copy the
-		 * the payload size and increment the string offset
-		 * for the next payload
-		 */
-		if (strlen(&(prop_value[i])) > MAX_SUNOEM_VAL_COMPACT_PAYLOAD) {
-			strncpy(setval_req.luapi_data, &(prop_value[i]),
-			MAX_SUNOEM_VAL_COMPACT_PAYLOAD);
-		} else {
-			/* Captured the entire string, mark this as the last payload */
-			strncpy(setval_req.luapi_data, &(prop_value[i]),
-					strlen(&(prop_value[i])));
-			setval_req.eof = 1;
-		}
-		req.msg.data = (uint8_t *) &setval_req;
-		req.msg.data_len = sizeof(sunoem_setval_t);
-		rsp = intf->sendrecv(intf, &req);
-
-		if (rsp == NULL) {
-			lprintf(LOG_ERR, "Sun OEM setval prop value: response is NULL");
-			return (-1);
-		}
-
-		if (rsp->ccode != 0) {
-			lprintf(LOG_ERR, "Sun OEM setval prop value: request failed: %d",
-					rsp->ccode);
-			return (-1);
-		}
-
-		setval_rsp = (sunoem_setval_resp_t *) rsp->data;
-
-		/*
-		 * If the return code is other than data received, the
-		 * request failed
-		 */
-		if (setval_rsp->status_code != SUNOEM_REQ_RECV) {
-			lprintf(LOG_ERR,
-					"Sun OEM setval prop value: invalid status code: %d",
-					setval_rsp->status_code);
-			return (-1);
-		}
-
-		/* Increment the string offset */
-		i += MAX_SUNOEM_VAL_COMPACT_PAYLOAD;
-	}
-	return (0);
-}
-
-static int
-ipmi_sunoem_setval(struct ipmi_intf * intf, int argc, char *argv[])
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	sunoem_setval_t setval_req;
-	sunoem_setval_resp_t *setval_rsp;
-	int prop_len;
-	int value_len;
-	int i;
-	unsigned char tid_num;
-	int retries;
-
-	prop_len = strlen(argv[0]);
-	value_len = strlen(argv[1]);
-	if (prop_len > LUAPI_MAX_OBJ_PATH_LEN) {
-		lprintf(LOG_ERR,
-				"Sun OEM set value command failed: Max size on property name");
-		return (-1);
-	}
-	if (value_len > LUAPI_MAX_OBJ_VAL_LEN) {
-		lprintf(LOG_ERR,
-				"Sun OEM set value command failed: Max size on property value");
-		return (-1);
-	}
-
-	/* Test if there is a timeout specified */
-	if (argc == 3) {
-		if ((str2int(argv[2], &retries) != 0) || retries < 0) {
-			lprintf(LOG_ERR,
-					"Invalid input given or out of range for time-out parameter.");
-			return (-1);
-		}
-	} else {
-		retries = GETVAL_MAX_RETRIES;
-	}
-
-	/* Send the property name 1st */
-	if (send_luapi_prop_name(intf, prop_len, argv[0], &tid_num) != 0) {
-		/* return if there is an error */
-		return (-1);
-	}
-
-	if (send_luapi_prop_value(intf, value_len, argv[1], tid_num) != 0) {
-		/* return if there is an error */
-		return (-1);
-	}
-
-	/*
-	 * Get The status of the command.
-	 * if it is not ready, retry the request up to
-	 * GETVAL_MAX_RETRIES
-	 */
-	for (i = 0; i < retries; i++) {
-		memset(&req, 0, sizeof(req));
-		req.msg.netfn = IPMI_NETFN_SUNOEM;
-		req.msg.cmd = IPMI_SUNOEM_SETVAL;
-		setval_req.cmd_code = SUNOEM_GET_STATUS;
-		setval_req.tid = tid_num;
-		req.msg.data = (uint8_t *) &setval_req;
-		req.msg.data_len = sizeof(sunoem_setval_t);
-		rsp = intf->sendrecv(intf, &req);
-
-		if (rsp == NULL) {
-			lprintf(LOG_ERR, "Sun OEM setval command failed.");
-			return (-1);
-		}
-
-		if (rsp->ccode != 0) {
-			lprintf(LOG_ERR, "Sun OEM setval command failed: %d", rsp->ccode);
-			return (-1);
-		}
-
-		setval_rsp = (sunoem_setval_resp_t *) rsp->data;
-
-		if (setval_rsp->status_code == SUNOEM_DATA_READY) {
-			printf("Sun OEM setval command successful.\n");
-			return (0);
-		} else if (setval_rsp->status_code != SUNOEM_DATA_NOT_READY) {
-			lprintf(LOG_ERR, "Sun OEM setval command failed.");
-			return (-1);
-		}
-
-		sleep(1);
-	}
-	/* If we reached here, retries exceeded */
-	lprintf(LOG_ERR, "Sun OEM setval command failed: Command Timed Out");
-
-	return (-1);
-}
-
-#define MAX_FILE_DATA_SIZE            1024
-#define MAX_FILEID_LEN                16
-#define CORE_TUNNEL_SUBCMD_GET_FILE   11
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	unsigned char cmd_code;
-	unsigned char file_id[MAX_FILEID_LEN];
-	unsigned int block_num;
-}__attribute__((packed)) getfile_req_t;
-
-typedef struct
-{
-	unsigned int block_num;
-	unsigned int data_size;
-	unsigned char eof;
-	unsigned char data[MAX_FILE_DATA_SIZE];
-}__attribute__((packed)) getfile_rsp_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-static int
-ipmi_sunoem_getfile(struct ipmi_intf * intf, int argc, char *argv[])
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	getfile_req_t getfile_req;
-	getfile_rsp_t *getfile_rsp;
-	int block_num = 0;
-	int nbo_blk_num; /* Network Byte Order Block Num */
-	FILE *fp;
-	unsigned data_size;
-	supported_version_t supp_ver = IPMI_SUNOEM_GETFILE_VERSION;
-
-	if (argc < 1) {
-		return (-1);
-	}
-
-	/*check if command is supported by this version of ilom*/
-	if (ipmi_sunoem_checkversion(intf, &supp_ver) < 0) {
-		ipmi_sunoem_print_required_version(&supp_ver);
-		return (-1);
-	}
-
-	/*
-	 * File ID is < MAX_FILEID_LEN
-	 * Save 1 byte for null Terminated string
-	 */
-	if (strlen(argv[0]) >= MAX_FILE_DATA_SIZE) {
-		lprintf(LOG_ERR, "File ID >= %d characters", MAX_FILEID_LEN);
-		return (-1);
-	}
-
-	memset(&getfile_req, 0, sizeof(getfile_req));
-	strncpy((char*) getfile_req.file_id, argv[0], MAX_FILEID_LEN - 1);
-
-	/* Create the destination file */
-	fp = ipmi_open_file_write(argv[1]);
-	if (fp == NULL) {
-		lprintf(LOG_ERR, "Unable to open file: %s", argv[1]);
-		return (-1);
-	}
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_CORE_TUNNEL;
-	req.msg.data = (uint8_t *) &getfile_req;
-	req.msg.data_len = sizeof(getfile_req_t);
-	getfile_req.cmd_code = CORE_TUNNEL_SUBCMD_GET_FILE;
-
-	do {
-
-		nbo_blk_num = htonl(block_num);
-		/* Block Num must be in network byte order */
-		memcpy(&(getfile_req.block_num), &nbo_blk_num,
-				sizeof(getfile_req.block_num));
-
-		rsp = intf->sendrecv(intf, &req);
-
-		if (rsp == NULL) {
-			lprintf(LOG_ERR, "Sun OEM getfile command failed.");
-			fclose(fp);
-			return (-1);
-		}
-		if (rsp->ccode != 0) {
-			lprintf(LOG_ERR, "Sun OEM getfile command failed: %d", rsp->ccode);
-			fclose(fp);
-			return (-1);
-		}
-
-		getfile_rsp = (getfile_rsp_t *) rsp->data;
-
-		memcpy(&data_size, &(getfile_rsp->data_size),
-				sizeof(getfile_rsp->data_size));
-		data_size = ntohl(data_size);
-
-		if (data_size > MAX_FILE_DATA_SIZE) {
-			lprintf(LOG_ERR, "Sun OEM getfile invalid data size: %d",
-					data_size);
-			fclose(fp);
-			return (-1);
-		}
-
-		/* Check if Block Num matches */
-		if (memcmp(&(getfile_req.block_num), &(getfile_rsp->block_num),
-				sizeof(getfile_req.block_num)) != 0) {
-			lprintf(LOG_ERR, "Sun OEM getfile Incorrect Block Num Returned");
-			lprintf(LOG_ERR, "Expecting: %x Received: %x",
-					getfile_req.block_num, getfile_rsp->block_num);
-			fclose(fp);
-			return (-1);
-		}
-
-		if (fwrite(getfile_rsp->data, 1, data_size, fp) != data_size) {
-			lprintf(LOG_ERR, "Sun OEM getfile write failed: %d", rsp->ccode);
-			fclose(fp);
-			return (-1);
-		}
-
-		block_num++;
-	} while (getfile_rsp->eof == 0);
-
-	fclose(fp);
-
-	return (0);
-}
-
-/*
- * Query BMC for capability/behavior.
- */
-
-#define CORE_TUNNEL_SUBCMD_GET_BEHAVIOR   15
-#define SUNOEM_BEHAVIORID_SIZE            32
-
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(push, 1)
-#endif
-typedef struct
-{
-	unsigned char cmd_code;
-	unsigned char behavior_id[SUNOEM_BEHAVIORID_SIZE];
-}__attribute__((packed)) getbehavior_req_t;
-
-typedef struct
-{
-	unsigned char enabled;
-}__attribute__((packed)) getbehavior_rsp_t;
-#ifdef HAVE_PRAGMA_PACK
-#pragma pack(pop)
-#endif
-
-static int
-ipmi_sunoem_getbehavior(struct ipmi_intf * intf, int argc, char *argv[])
-{
-	struct ipmi_rq req;
-	struct ipmi_rs *rsp;
-	getbehavior_req_t getbehavior_req;
-	getbehavior_rsp_t *getbehavior_rsp;
-	supported_version_t supp_ver = IPMI_SUNOEM_GETBEHAVIOR_VERSION;
-
-	if (argc < 1) {
-		return (-1);
-	}
-
-	/*check if command is supported by this version of ilom*/
-	if (ipmi_sunoem_checkversion(intf, &supp_ver) < 0) {
-		ipmi_sunoem_print_required_version(&supp_ver);
-		return (-1);
-	}
-
-	/*
-	 * Behavior ID is < SUNOEM_BEHAVIORID_SIZE.
-	 * Save 1 byte for null terminated string
-	 */
-	if (strlen(argv[0]) >= SUNOEM_BEHAVIORID_SIZE) {
-		lprintf(LOG_ERR, "Behavior ID >= %d characters",
-		SUNOEM_BEHAVIORID_SIZE);
-		return (-1);
-	}
-
-	memset(&getbehavior_req, 0, sizeof(getbehavior_req));
-	strncpy(getbehavior_req.behavior_id, argv[0], SUNOEM_BEHAVIORID_SIZE - 1);
-
-	memset(&req, 0, sizeof(req));
-	req.msg.netfn = IPMI_NETFN_SUNOEM;
-	req.msg.cmd = IPMI_SUNOEM_CORE_TUNNEL;
-	req.msg.data = (uint8_t *) &getbehavior_req;
-	req.msg.data_len = sizeof(getbehavior_req_t);
-	getbehavior_req.cmd_code = CORE_TUNNEL_SUBCMD_GET_BEHAVIOR;
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "Sun OEM getbehavior command failed.");
-		return (-1);
-	}
-
-	if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Sun OEM getbehavior command failed: %d", rsp->ccode);
-		return (-1);
-	}
-
-	getbehavior_rsp = (getbehavior_rsp_t *) rsp->data;
-	printf("ILOM behavior %s %s enabled\n", getbehavior_req.behavior_id,
-			getbehavior_rsp->enabled ? "is" : "is not");
-
-	return (0);
-}
-
-int
-ipmi_sunoem_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-	int rc = 0;
-
-	if (argc == 0 || strcmp(argv[0], "help") == 0) {
-		ipmi_sunoem_usage();
-		return (0);
-	} /* if (argc == 0 || strcmp(argv[0], "help") == 0) */
-
-	if (strcmp(argv[0], "cli") == 0) {
-		rc = ipmi_sunoem_cli(intf, argc - 1, &argv[1]);
-	} else if ((strcmp(argv[0], "led") == 0) || (strcmp(argv[0], "sbled") == 0)) {
-		if (argc < 2) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-
-		if (strcmp(argv[1], "get") == 0) {
-			if (argc < 3) {
-				char * arg[] = { "all" };
-				rc = ipmi_sunoem_led_get(intf, 1, arg);
-			} else {
-				rc = ipmi_sunoem_led_get(intf, argc - 2, &(argv[2]));
-			}
-		} else if (strcmp(argv[1], "set") == 0) {
-			if (argc < 4) {
-				ipmi_sunoem_usage();
-				return (-1);
-			}
-			rc = ipmi_sunoem_led_set(intf, argc - 2, &(argv[2]));
-		} else {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-	} else if (strcmp(argv[0], "sshkey") == 0) {
-		uint8_t uid = 0;
-		if (argc < 3) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-		rc = str2uchar(argv[2], &uid);
-		if (rc == 0) {
-			/* conversion should be OK. */
-		} else if (rc == 2) {
-			lprintf(LOG_NOTICE, "Invalid interval given.");
-			return (-1);
-		} else {
-			/* defaults to rc = 3 */
-			lprintf(LOG_NOTICE, "Given interval is too big.");
-			return (-1);
-		}
-
-		if (strcmp(argv[1], "del") == 0) {
-			/* number of arguments, three, is already checked at this point */
-			rc = ipmi_sunoem_sshkey_del(intf, uid);
-		} else if (strcmp(argv[1], "set") == 0) {
-			if (argc < 4) {
-				ipmi_sunoem_usage();
-				return (-1);
-			}
-			rc = ipmi_sunoem_sshkey_set(intf, uid, argv[3]);
-		} else {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-	} else if (strcmp(argv[0], "ping") == 0) {
-		if (argc < 2) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-		rc = ipmi_sunoem_echo(intf, argc - 1, &(argv[1]));
-	} else if (strcmp(argv[0], "version") == 0) {
-		rc = ipmi_sunoem_version(intf);
-	} else if (strcmp(argv[0], "nacname") == 0) {
-		if (argc < 2) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-		rc = ipmi_sunoem_nacname(intf, argc - 1, &(argv[1]));
-	} else if (strcmp(argv[0], "getval") == 0) {
-		if (argc < 2) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-		rc = ipmi_sunoem_getval(intf, argc - 1, &(argv[1]));
-	} else if (strcmp(argv[0], "setval") == 0) {
-		if (argc < 3) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-		rc = ipmi_sunoem_setval(intf, argc - 1, &(argv[1]));
-	} else if (strcmp(argv[0], "getfile") == 0) {
-		if (argc < 3) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-		rc = ipmi_sunoem_getfile(intf, argc - 1, &(argv[1]));
-	} else if (strcmp(argv[0], "getbehavior") == 0) {
-		if (argc < 2) {
-			ipmi_sunoem_usage();
-			return (-1);
-		}
-		rc = ipmi_sunoem_getbehavior(intf, argc - 1, &(argv[1]));
-	} else {
-		lprintf(LOG_ERR, "Invalid sunoem command: %s", argv[0]);
-		return (-1);
-	} /* if (strcmp(argv[0], "cli") == 0) */
-
-	return (rc);
-}
diff --git a/lib/ipmi_vita.c b/lib/ipmi_vita.c
deleted file mode 100644
index 3900974..0000000
--- a/lib/ipmi_vita.c
+++ /dev/null
@@ -1,1012 +0,0 @@
-/*
- * Copyright (c) 2014 Pigeon Point Systems. All right reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * Neither the name of Pigeon Point Systems, or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * This software is provided "AS IS, " without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * PIGEON POINT SYSTEMS ("PPS") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * PPS OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF PPS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include <ipmitool/ipmi_intf.h>
-#include <ipmitool/ipmi_picmg.h>
-#include <ipmitool/ipmi_vita.h>
-#include <ipmitool/ipmi_fru.h>
-#include <ipmitool/ipmi_strings.h>
-#include <ipmitool/log.h>
-
-/* Handled VITA 46.11 commands */
-#define VITA_CMD_HELP		0
-#define VITA_CMD_PROPERTIES	1
-#define VITA_CMD_FRUCONTROL	2
-#define VITA_CMD_ADDRINFO	3
-#define VITA_CMD_ACTIVATE	4
-#define VITA_CMD_DEACTIVATE	5
-#define VITA_CMD_POLICY_GET	6
-#define VITA_CMD_POLICY_SET	7
-#define VITA_CMD_LED_PROP	8
-#define VITA_CMD_LED_CAP	9
-#define VITA_CMD_LED_GET	10
-#define VITA_CMD_LED_SET	11
-#define VITA_CMD_UNKNOWN	255
-
-/* VITA 46.11 Site Type strings */
-static struct valstr vita_site_types[] = {
-	{ VITA_FRONT_VPX_MODULE, "Front Loading VPX Plug-In Module" },
-	{ VITA_POWER_ENTRY, "Power Entry Module" },
-	{ VITA_CHASSIS_FRU, "Chassic FRU Information Module" },
-	{ VITA_DEDICATED_CHMC, "Dedicated Chassis Manager" },
-	{ VITA_FAN_TRAY, "Fan Tray" },
-	{ VITA_FAN_TRAY_FILTER, "Fan Tray Filter" },
-	{ VITA_ALARM_PANEL, "Alarm Panel" },
-	{ VITA_XMC, "XMC" },
-	{ VITA_VPX_RTM, "VPX Rear Transition Module" },
-	{ VITA_FRONT_VME_MODULE, "Front Loading VME Plug-In Module" },
-	{ VITA_FRONT_VXS_MODULE, "Front Loading VXS Plug-In Module" },
-	{ VITA_POWER_SUPPLY, "Power Supply" },
-	{ VITA_FRONT_VITA62_MODULE, "Front Loading VITA 62 Module\n" },
-	{ VITA_71_MODULE, "VITA 71 Module\n" },
-	{ VITA_FMC, "FMC\n" },
-	{ 0, NULL }
-};
-
-/* VITA 46.11 command help strings */
-static struct valstr vita_help_strings[] = {
-	{
-		VITA_CMD_HELP,
-		"VITA commands:\n"
-		"    properties        - get VSO properties\n"
-		"    frucontrol        - FRU control\n"
-		"    addrinfo          - get address information\n"
-		"    activate          - activate a FRU\n"
-		"    deactivate        - deactivate a FRU\n"
-		"    policy get        - get the FRU activation policy\n"
-		"    policy set        - set the FRU activation policy\n"
-		"    led prop          - get led properties\n"
-		"    led cap           - get led color capabilities\n"
-		"    led get           - get led state\n"
-		"    led set           - set led state"
-	},
-	{
-		VITA_CMD_FRUCONTROL,
-		"usage: frucontrol <FRU-ID> <OPTION>\n"
-		"    OPTION: 0 - Cold Reset\n"
-		"            1 - Warm Reset\n"
-		"            2 - Graceful Reboot\n"
-		"            3 - Issue Diagnostic Interrupt"
-	},
-	{
-		VITA_CMD_ADDRINFO,
-		"usage: addrinfo [<FRU-ID>]"
-	},
-	{
-		VITA_CMD_ACTIVATE,
-		"usage: activate <FRU-ID>"
-	},
-	{
-		VITA_CMD_DEACTIVATE,
-		"usage: deactivate <FRU-ID>"
-	},
-    	{
-		VITA_CMD_POLICY_GET,
-		"usage: policy get <FRU-ID>"
-	},
-	{
-		VITA_CMD_POLICY_SET,
-		"usage: policy set <FRU-ID> <MASK> <VALUE>\n"
-		"    MASK:  [3] affect the Default-Activation-Locked Policy Bit\n"
-		"           [2] affect the Commanded-Deactivation-Ignored Policy Bit\n"
-		"           [1] affect the Deactivation-Locked Policy Bit\n"
-		"           [0] affect the Activation-Locked Policy Bit\n"
-		"    VALUE: [3] value for the Default-Activation-Locked Policy Bit\n"
-		"           [2] value for the Commanded-Deactivation-Ignored Policy Bit\n"
-		"           [1] value for the Deactivation-Locked Policy Bit\n"
-		"           [0] value for the Activation-Locked Policy Bit"
-	},
-	{
-		VITA_CMD_LED_PROP,
-		"usage: led prop <FRU-ID>"
-	},
-	{
-		VITA_CMD_LED_CAP,
-		"usage: led cap <FRU-ID> <LED-ID"
-	},
-	{
-		VITA_CMD_LED_GET,
-		"usage: led get <FRU-ID> <LED-ID",
-	},
-	{
-		VITA_CMD_LED_SET,
-		"usage: led set <FRU-ID> <LED-ID> <FUNCTION> <DURATION> <COLOR>\n"
-		"    <FRU-ID>\n"
-		"    <LED-ID>   0-0xFE:    Specified LED\n"
-		"               0xFF:      All LEDs under management control\n"
-		"    <FUNCTION> 0:       LED OFF override\n"
-		"               1 - 250: LED blinking override (off duration)\n"
-		"               251:     LED Lamp Test\n"
-		"               252:     LED restore to local control\n"
-		"               255:     LED ON override\n"
-		"    <DURATION> 1 - 127: LED Lamp Test / on duration\n"
-		"    <COLOR>    1:   BLUE\n"
-		"               2:   RED\n"
-		"               3:   GREEN\n"
-		"               4:   AMBER\n"
-		"               5:   ORANGE\n"
-		"               6:   WHITE\n"
-		"               0xE: do not change\n"
-		"               0xF: use default color"
-	},
-	{
-		VITA_CMD_UNKNOWN,
-		"Unknown command"
-	},
-	{ 0, NULL }
-};
-
-/* check if VITA 46.11 is supported */
-uint8_t
-vita_discover(struct ipmi_intf *intf)
-{
-	struct ipmi_rq req;
-	struct ipmi_rs *rsp;
-	unsigned char msg_data;
-	int vita_avail = 0;
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_VSO_CAPABILITIES_CMD;
-	req.msg.data = &msg_data;
-	req.msg.data_len = 1;
-
-	msg_data = GROUP_EXT_VITA;
-
-	lprintf(LOG_INFO, "Running Get VSO Capabilities my_addr %#x, "
-		"transit %#x, target %#x",
-		intf->my_addr, intf->transit_addr, intf->target_addr);
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received");
-	} else if (rsp->ccode == 0xC1) {
-		lprintf(LOG_INFO, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-	} else if (rsp->ccode == 0xCC) {
-		lprintf(LOG_INFO, "Invalid data field received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_INFO, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-	} else if (rsp->data_len < 5) {
-		lprintf(LOG_INFO, "Invalid response length %d",
-			rsp->data_len);
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_INFO, "Invalid group extension %#x",
-			rsp->data[0]);
-	} else if ((rsp->data[3] & 0x03) != 0) {
-		lprintf(LOG_INFO, "Unknown VSO Standard %d",
-			(rsp->data[3] & 0x03));
-	} else if ((rsp->data[4] & 0x0F) != 1) {
-		lprintf(LOG_INFO, "Unknown VSO Specification Revision %d.%d",
-			(rsp->data[4] & 0x0F), (rsp->data[4] >> 4));
-	} else {
-		vita_avail = 1;
-		lprintf(LOG_INFO, "Discovered VITA 46.11 Revision %d.%d",
-			(rsp->data[4] & 0x0F), (rsp->data[4] >> 4));
-	}
-
-	return vita_avail;
-}
-
-uint8_t
-ipmi_vita_ipmb_address(struct ipmi_intf *intf)
-{
-	struct ipmi_rq req;
-	struct ipmi_rs *rsp;
-	unsigned char msg_data;
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_FRU_ADDRESS_INFO_CMD;
-	req.msg.data = &msg_data;
-	req.msg.data_len = 1;
-
-	msg_data = GROUP_EXT_VITA;
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received");
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-	} else if (rsp->data_len < 7) {
-		lprintf(LOG_ERR, "Invalid response length %d",
-			rsp->data_len);
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x",
-			rsp->data[0]);
-	} else {
-		return rsp->data[2];
-	}
-
-	return 0;
-}
-
-static int
-ipmi_vita_getaddr(struct ipmi_intf *intf, int argc, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[2];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_FRU_ADDRESS_INFO_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 2;
-
-	msg_data[0] = GROUP_EXT_VITA;		/* VITA identifier */
-	msg_data[1] = 0;			/* default FRU ID */
-
-	if (argc > 0) {
-		/* validate and get FRU Device ID */
-		if (is_fru_id(argv[0], &msg_data[1]) != 0) {
-			return -1;
-		}
-	}
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 7) {
-		lprintf(LOG_ERR, "Invalid response length %d",
-			rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x",
-			rsp->data[0]);
-		return -1;
-	}
-
-	printf("Hardware Address : 0x%02x\n", rsp->data[1]);
-	printf("IPMB-0 Address   : 0x%02x\n", rsp->data[2]);
-	printf("FRU ID           : 0x%02x\n", rsp->data[4]);
-	printf("Site ID          : 0x%02x\n", rsp->data[5]);
-	printf("Site Type        : %s\n", val2str(rsp->data[6],
-		vita_site_types));
-	if (rsp->data_len > 8) {
-		printf("Channel 7 Address: 0x%02x\n", rsp->data[8]);
-	}
-
-	return 0;
-}
-
-static int
-ipmi_vita_get_vso_capabilities(struct ipmi_intf *intf)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data, tmp;
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_VSO_CAPABILITIES_CMD;
-	req.msg.data = &msg_data;
-	req.msg.data_len = 1;
-
-	msg_data = GROUP_EXT_VITA;		/* VITA identifier */
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 5) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("VSO Identifier    : 0x%02x\n", rsp->data[0]);
-	printf("IPMC Identifier   : 0x%02x\n", rsp->data[1]);
-	printf("    Tier  %d\n", (rsp->data[1] & 0x03) + 1);
-	printf("    Layer %d\n", ((rsp->data[1] & 0x30) >> 4) + 1);
-
-	printf("IPMB Capabilities : 0x%02x\n", rsp->data[2]);
-
-	tmp = (rsp->data[2] & 0x30) >> 4;
-
-	printf("    Frequency  %skHz\n",
-		tmp == 0 ? "100" : tmp == 1 ? "400" : "RESERVED");
-
-	tmp = rsp->data[2] & 3;
-
-	if (tmp == 1) {
-		printf("    2 IPMB interfaces supported\n");
-	} else if (tmp == 0) {
-		printf("    1 IPMB interface supported\n");
-	}
-
-	printf("VSO Standard      : %s\n",
-		(rsp->data[3] & 0x3) == 0 ? "VITA 46.11" : "RESERVED");
-
-	printf("VSO Spec Revision : %d.%d\n", rsp->data[4] & 0xf,
-		rsp->data[4] >> 4);
-
-	printf("Max FRU Device ID : 0x%02x\n", rsp->data[5]);
-	printf("FRU Device ID     : 0x%02x\n", rsp->data[6]);
-
-	return 0;
-}
-
-static int
-ipmi_vita_set_fru_activation(struct ipmi_intf *intf,
-	char **argv, unsigned char command)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[3];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_SET_FRU_ACTIVATION_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 3;
-
-	msg_data[0]	= GROUP_EXT_VITA;		/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-	msg_data[2]	= command;			/* command */
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 1) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("FRU has been successfully %s\n",
-		command ? "activated" : "deactivated");
-
-	return 0;
-}
-
-static int
-ipmi_vita_get_fru_state_policy_bits(struct ipmi_intf *intf, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[2];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_FRU_STATE_POLICY_BITS_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 2;
-
-	msg_data[0] = GROUP_EXT_VITA;			/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 2) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("FRU State Policy Bits:	%xh\n", rsp->data[1]);
-	printf("    Default-Activation-Locked Policy Bit is %d\n",
-		rsp->data[1] & 0x08 ? 1 : 0);
-	printf("    Commanded-Deactivation-Ignored Policy Bit is %d\n",
-		rsp->data[1] & 0x04 ? 1 : 0);
-	printf("    Deactivation-Locked Policy Bit is %d\n",
-		rsp->data[1] & 0x02 ? 1 : 0);
-	printf("    Activation-Locked Policy Bit is %d\n",
-		rsp->data[1] & 0x01);
-
-	return 0;
-}
-
-static int
-ipmi_vita_set_fru_state_policy_bits(struct ipmi_intf *intf, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[4];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_SET_FRU_STATE_POLICY_BITS_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 4;
-
-	msg_data[0] = GROUP_EXT_VITA;			/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-	if (str2uchar(argv[1], &msg_data[2]) != 0) {	/* bits mask */
-		return -1;
-	}
-	if (str2uchar(argv[2], &msg_data[3]) != 0) {	/* bits */
-		return -1;
-	}
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 1) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("FRU state policy bits have been updated\n");
-
-	return 0;
-}
-
-static int
-ipmi_vita_get_led_properties(struct ipmi_intf *intf, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[2];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_FRU_LED_PROPERTIES_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 2;
-
-	msg_data[0] = GROUP_EXT_VITA;			/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 3) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("LED Count:	   %#x\n", rsp->data[2]);
-
-	return 0;
-}
-
-static int
-ipmi_vita_get_led_color_capabilities(struct ipmi_intf *intf, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[3];
-	int i;
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_LED_COLOR_CAPABILITIES_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 3;
-
-	msg_data[0] = GROUP_EXT_VITA;			/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-	if (str2uchar(argv[1], &msg_data[2]) != 0) {	/* LED-ID */
-		return -1;
-	}
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 4) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("LED Color Capabilities: ");
-	for (i = 0; i < 8; i++) {
-		if (rsp->data[1] & (0x01 << i)) {
-			printf("%s, ", led_color_str[i]);
-		}
-	}
-	putchar('\n');
-
-	printf("Default LED Color in\n");
-	printf("      LOCAL control:  %s\n", led_color_str[rsp->data[2]]);
-	printf("      OVERRIDE state: %s\n", led_color_str[rsp->data[3]]);
-
-	if (rsp->data_len == 5) {
-		printf("LED flags:\n");
-		if (rsp->data[4] & 2) {
-			printf("      [HW RESTRICT]\n");
-		}
-		if (rsp->data[4] & 1) {
-			printf("      [PAYLOAD PWR]\n");
-		}
-	}
-
-	return 0;
-}
-
-static int
-ipmi_vita_get_led_state(struct ipmi_intf *intf, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[3];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_GET_FRU_LED_STATE_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 3;
-
-	msg_data[0] = GROUP_EXT_VITA;			/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-	if (str2uchar(argv[1], &msg_data[2]) != 0) {	/* LED-ID */
-		return -1;
-	}
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 5
-		|| ((rsp->data[1] & 0x2) && rsp->data_len < 8)
-		|| ((rsp->data[1] & 0x4) && rsp->data_len < 9)) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("LED states:                   %x\t", rsp->data[1]);
-	if (rsp->data[1] & 0x1) {
-		printf("[LOCAL CONTROL] ");
-	}
-	if (rsp->data[1] & 0x2) {
-		printf("[OVERRIDE] ");
-	}
-	if (rsp->data[1] & 0x4) {
-		printf("[LAMPTEST] ");
-	}
-	if (rsp->data[1] & 0x8) {
-		printf("[HW RESTRICT] ");
-	}
-	putchar('\n');
-
-	if (rsp->data[1] & 1) {
-		printf("  Local Control function:     %x\t", rsp->data[2]);
-		if (rsp->data[2] == 0x0) {
-			printf("[OFF]\n");
-		} else if (rsp->data[2] == 0xff) {
-			printf("[ON]\n");
-		} else {
-			printf("[BLINKING]\n");
-		}
-		printf("  Local Control On-Duration:  %x\n", rsp->data[3]);
-		printf("  Local Control Color:        %x\t[%s]\n",
-			rsp->data[4], led_color_str[rsp->data[4] & 7]);
-	}
-
-	/* override state or lamp test */
-	if (rsp->data[1] & 0x06) {
-		printf("  Override function:     %x\t", rsp->data[5]);
-		if (rsp->data[5] == 0x0) {
-			printf("[OFF]\n");
-		} else if (rsp->data[5] == 0xff) {
-			printf("[ON]\n");
-		} else {
-			printf("[BLINKING]\n");
-		}
-		printf("  Override On-Duration:  %x\n", rsp->data[6]);
-		printf("  Override Color:        %x\t[%s]\n",
-			rsp->data[7], led_color_str[rsp->data[7] & 7]);
-		if (rsp->data[1] == 0x04) {
-			printf("  Lamp test duration:    %x\n", rsp->data[8]);
-		}
-	}
-
-	return 0;
-}
-
-static int
-ipmi_vita_set_led_state(struct ipmi_intf *intf, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[6];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_SET_FRU_LED_STATE_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 6;
-
-	msg_data[0] = GROUP_EXT_VITA;			/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-	if (str2uchar(argv[1], &msg_data[2]) != 0) {	/* LED-ID */
-		return -1;
-	}
-	if (str2uchar(argv[2], &msg_data[3]) != 0) {	/* LED function */
-		return -1;
-	}
-	if (str2uchar(argv[3], &msg_data[4]) != 0) {	/* LED on duration */
-		return -1;
-	}
-	if (str2uchar(argv[4], &msg_data[5]) != 0) {	/* LED color */
-		return -1;
-	}
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 1) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("LED state has been updated\n");
-
-	return 0;
-}
-
-static int
-ipmi_vita_fru_control(struct ipmi_intf *intf, char **argv)
-{
-	struct ipmi_rs *rsp;
-	struct ipmi_rq req;
-	unsigned char msg_data[3];
-
-	memset(&req, 0, sizeof(req));
-
-	req.msg.netfn = IPMI_NETFN_PICMG;
-	req.msg.cmd = VITA_FRU_CONTROL_CMD;
-	req.msg.data = msg_data;
-	req.msg.data_len = 3;
-
-	msg_data[0] = GROUP_EXT_VITA;			/* VITA identifier */
-	if (is_fru_id(argv[0], &msg_data[1]) != 0) {	/* FRU ID */
-		return -1;
-	}
-	if (str2uchar(argv[1], &msg_data[2]) != 0) {	/* control option */
-		return -1;
-	}
-
-	printf("FRU Device Id: %d FRU Control Option: %s\n", msg_data[1],
-		val2str(msg_data[2], picmg_frucontrol_vals));
-
-	rsp = intf->sendrecv(intf, &req);
-
-	if (rsp == NULL) {
-		lprintf(LOG_ERR, "No valid response received.");
-		return -1;
-	} else if (rsp->ccode != 0) {
-		lprintf(LOG_ERR, "Invalid completion code received: %s",
-			val2str(rsp->ccode, completion_code_vals));
-		return -1;
-	} else if (rsp->data_len < 1) {
-		lprintf(LOG_ERR, "Invalid response length %d", rsp->data_len);
-		return -1;
-	} else if (rsp->data[0] != GROUP_EXT_VITA) {
-		lprintf(LOG_ERR, "Invalid group extension %#x", rsp->data[0]);
-		return -1;
-	}
-
-	printf("FRU Control: ok\n");
-
-	return 0;
-}
-
-static int
-ipmi_vita_get_cmd(int argc, char **argv)
-{
-	if (argc < 1 || !strncmp(argv[0], "help", 4)) {
-		return VITA_CMD_HELP;
-	}
-
-	/* Get VSO Properties */
-	if (!strncmp(argv[0], "properties", 10)) {
-		return VITA_CMD_PROPERTIES;
-	}
-
-	/* FRU Control command */
-	if (!strncmp(argv[0], "frucontrol", 10)) {
-		return VITA_CMD_FRUCONTROL;
-	}
-
-	/* Get FRU Address Info command */
-	if (!strncmp(argv[0], "addrinfo", 8)) {
-		return VITA_CMD_ADDRINFO;
-	}
-
-	/* Set FRU Activation (activate) command */
-	if (!strncmp(argv[0], "activate", 8)) {
-		return VITA_CMD_ACTIVATE;
-	}
-
-	/* Set FRU Activation (deactivate) command */
-	if (!strncmp(argv[0], "deactivate", 10)) {
-		return VITA_CMD_DEACTIVATE;
-	}
-
-	/* FRU State Policy Bits commands */
-	if (!strncmp(argv[0], "policy", 6)) {
-		if (argc < 2) {
-			return VITA_CMD_UNKNOWN;
-		}
-
-		/* Get FRU State Policy Bits command */
-		if (!strncmp(argv[1], "get", 3)) {
-			return VITA_CMD_POLICY_GET;
-		}
-
-		/* Set FRU State Policy Bits command */
-		if (!strncmp(argv[1], "set", 3)) {
-			return VITA_CMD_POLICY_SET;
-		}
-
-		/* unknown command */
-		return VITA_CMD_UNKNOWN;
-	}
-
-	/* FRU LED commands */
-	if (!strncmp(argv[0], "led", 3)) {
-		if (argc < 2) {
-			return VITA_CMD_UNKNOWN;
-		}
-
-		/* FRU LED Get Properties */
-		if (!strncmp(argv[1], "prop", 4)) {
-			return VITA_CMD_LED_PROP;
-		}
-
-		/* FRU LED Get Capabilities */
-		if (!strncmp(argv[1], "cap", 3)) {
-			return VITA_CMD_LED_CAP;
-		}
-
-		/* FRU LED Get State */
-		if (!strncmp(argv[1], "get", 3)) {
-			return VITA_CMD_LED_GET;
-		}
-
-		/* FRU LED Set State */
-		if (!strncmp(argv[1], "set", 3)) {
-			return VITA_CMD_LED_SET;
-		}
-
-		/* unknown command */
-		return VITA_CMD_UNKNOWN;
-	}
-
-	/* unknown command */
-	return VITA_CMD_UNKNOWN;
-}
-
-int
-ipmi_vita_main (struct ipmi_intf *intf, int argc, char **argv)
-{
-	int rc = -1, show_help = 0;
-	int cmd = ipmi_vita_get_cmd(argc, argv);
-
-	switch (cmd) {
-	case VITA_CMD_HELP:
-		cmd = ipmi_vita_get_cmd(argc - 1, &argv[1]);
-		show_help = 1;
-		rc = 0;
-		break;
-
-	case VITA_CMD_PROPERTIES:
-		rc = ipmi_vita_get_vso_capabilities(intf);
-		break;
-
-	case VITA_CMD_FRUCONTROL:
-		if (argc > 2) {
-			rc = ipmi_vita_fru_control(intf, &argv[1]);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_ADDRINFO:
-		rc = ipmi_vita_getaddr(intf, argc - 1, &argv[1]);
-		break;
-
-	case VITA_CMD_ACTIVATE:
-		if (argc > 1) {
-			rc = ipmi_vita_set_fru_activation(intf, &argv[1], 1);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_DEACTIVATE:
-		if (argc > 1) {
-			rc = ipmi_vita_set_fru_activation(intf, &argv[1], 0);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_POLICY_GET:
-		if (argc > 2) {
-			rc = ipmi_vita_get_fru_state_policy_bits(intf,
-				&argv[2]);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_POLICY_SET:
-		if (argc > 4) {
-			rc = ipmi_vita_set_fru_state_policy_bits(intf,
-				&argv[2]);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_LED_PROP:
-		if (argc > 2) {
-			rc = ipmi_vita_get_led_properties(intf, &argv[2]);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_LED_CAP:
-		if (argc > 3) {
-			rc = ipmi_vita_get_led_color_capabilities(intf,
-				&argv[2]);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_LED_GET:
-		if (argc > 3) {
-			rc = ipmi_vita_get_led_state(intf, &argv[2]);
-		} else {
-			show_help = 1;
-		}
-		break;
-
-	case VITA_CMD_LED_SET:
-		if (argc > 6) {
-			rc = ipmi_vita_set_led_state(intf, &argv[2]);
-		} else {
-			show_help = 1;
-		}
-		break;
-	default:
-		lprintf(LOG_NOTICE, "Unknown command");
-		cmd = VITA_CMD_HELP;
-		show_help = 1;
-		break;
-	}
-
-	if (show_help) {
-		lprintf(LOG_NOTICE, "%s", val2str(cmd, vita_help_strings));
-	}
-
-	return rc;
-}
diff --git a/src/ipmitool.c b/src/ipmitool.c
index 164fd44..30193cf 100644
--- a/src/ipmitool.c
+++ b/src/ipmitool.c
@@ -55,17 +55,11 @@
 #include <ipmitool/ipmi_raw.h>
 #include <ipmitool/ipmi_pef.h>
 #include <ipmitool/ipmi_oem.h>
-#include <ipmitool/ipmi_sunoem.h>
-#include <ipmitool/ipmi_fwum.h>
 #include <ipmitool/ipmi_picmg.h>
-#include <ipmitool/ipmi_kontronoem.h>
 #include <ipmitool/ipmi_firewall.h>
 #include <ipmitool/ipmi_hpmfwupg.h>
-#include <ipmitool/ipmi_delloem.h>
-#include <ipmitool/ipmi_ekanalyzer.h>
 #include <ipmitool/ipmi_ime.h>
 #include <ipmitool/ipmi_dcmi.h>
-#include <ipmitool/ipmi_vita.h>
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
@@ -106,12 +100,8 @@ struct ipmi_cmd ipmitool_cmd_list[] = {
 	{ ipmi_session_main, "session", "Print session information" },
 	{ ipmi_dcmi_main,    "dcmi",    "Data Center Management Interface"},
 	{ ipmi_nm_main,      "nm",      "Node Manager Interface"},
-	{ ipmi_sunoem_main,  "sunoem",  "OEM Commands for Sun servers" },
-	{ ipmi_kontronoem_main, "kontronoem", "OEM Commands for Kontron devices"},
 	{ ipmi_picmg_main,   "picmg",   "Run a PICMG/ATCA extended cmd"},
-	{ ipmi_fwum_main,    "fwum",	"Update IPMC using Kontron OEM Firmware Update Manager" },
 	{ ipmi_firewall_main,"firewall","Configure Firmware Firewall" },
-	{ ipmi_delloem_main, "delloem", "OEM Commands for Dell systems" },
 #ifdef HAVE_READLINE
 	{ ipmi_shell_main,   "shell",   "Launch interactive IPMI shell" },
 #endif
@@ -119,9 +109,7 @@ struct ipmi_cmd ipmitool_cmd_list[] = {
 	{ ipmi_set_main,     "set",     "Set runtime variable for shell and exec" },
 	{ ipmi_echo_main,    "echo",    NULL }, /* for echoing lines to stdout in scripts */
 	{ ipmi_hpmfwupg_main,"hpm", "Update HPM components using PICMG HPM.1 file"},
-	{ ipmi_ekanalyzer_main,"ekanalyzer", "run FRU-Ekeying analyzer using FRU files"},
 	{ ipmi_ime_main,          "ime", "Update Intel Manageability Engine Firmware"},
-	{ ipmi_vita_main,   "vita",   "Run a VITA 46.11 extended cmd"},
 	{ NULL },
 };
 